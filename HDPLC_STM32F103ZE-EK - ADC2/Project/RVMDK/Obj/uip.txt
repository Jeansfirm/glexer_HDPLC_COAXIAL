; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\uip.o --depend=.\Obj\uip.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Libraries\uIP-1.0\uip\uip.c]
                          THUMB

                          AREA ||i.chksum||, CODE, READONLY, ALIGN=1

                  chksum PROC
;;;279    static u16_t
;;;280    chksum(u16_t sum, const u8_t *data, u16_t len)
000000  b510              PUSH     {r4,lr}
;;;281    {
;;;282      u16_t t;
;;;283      const u8_t *dataptr;
;;;284      const u8_t *last_byte;
;;;285    
;;;286      dataptr = data;
;;;287      last_byte = data + len - 1;
000002  440a              ADD      r2,r2,r1
000004  1e52              SUBS     r2,r2,#1
;;;288    
;;;289      while(dataptr < last_byte) {	/* At least two more bytes */
000006  e00b              B        |L1.32|
                  |L1.8|
;;;290        t = (dataptr[0] << 8) + dataptr[1];
000008  784b              LDRB     r3,[r1,#1]
00000a  780c              LDRB     r4,[r1,#0]
00000c  eb032304          ADD      r3,r3,r4,LSL #8
000010  b29b              UXTH     r3,r3
;;;291        sum += t;
000012  4418              ADD      r0,r0,r3
000014  b280              UXTH     r0,r0
;;;292        if(sum < t) {
000016  4298              CMP      r0,r3
000018  d201              BCS      |L1.30|
;;;293          sum++;		/* carry */
00001a  1c40              ADDS     r0,r0,#1
00001c  b280              UXTH     r0,r0
                  |L1.30|
;;;294        }
;;;295        dataptr += 2;
00001e  1c89              ADDS     r1,r1,#2
                  |L1.32|
000020  4291              CMP      r1,r2                 ;289
000022  d3f1              BCC      |L1.8|
;;;296      }
;;;297    
;;;298      if(dataptr == last_byte) {
000024  4291              CMP      r1,r2
000026  d107              BNE      |L1.56|
;;;299        t = (dataptr[0] << 8) + 0;
000028  7809              LDRB     r1,[r1,#0]
00002a  0209              LSLS     r1,r1,#8
;;;300        sum += t;
00002c  4408              ADD      r0,r0,r1
00002e  b280              UXTH     r0,r0
;;;301        if(sum < t) {
000030  4288              CMP      r0,r1
000032  d201              BCS      |L1.56|
;;;302          sum++;		/* carry */
000034  1c40              ADDS     r0,r0,#1
000036  b280              UXTH     r0,r0
                  |L1.56|
;;;303        }
;;;304      }
;;;305    
;;;306      /* Return sum in host byte order. */
;;;307      return sum;
;;;308    }
000038  bd10              POP      {r4,pc}
;;;309    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.htons||, CODE, READONLY, ALIGN=1

                  htons PROC
;;;1882   u16_t
;;;1883   htons(u16_t val)
000000  0201              LSLS     r1,r0,#8
;;;1884   {
;;;1885     return HTONS(val);
000002  ea412010          ORR      r0,r1,r0,LSR #8
000006  b280              UXTH     r0,r0
;;;1886   }
000008  4770              BX       lr
;;;1887   /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_add32||, CODE, READONLY, ALIGN=2

                  uip_add32 PROC
;;;248    void
;;;249    uip_add32(u8_t *op32, u16_t op16)
000000  b570              PUSH     {r4-r6,lr}
;;;250    {
;;;251      uip_acc32[3] = op32[3] + (op16 & 0xff);
000002  78c3              LDRB     r3,[r0,#3]
000004  b2cd              UXTB     r5,r1
000006  4a14              LDR      r2,|L3.88|
000008  442b              ADD      r3,r3,r5
00000a  b2de              UXTB     r6,r3
00000c  70d6              STRB     r6,[r2,#3]
;;;252      uip_acc32[2] = op32[2] + (op16 >> 8);
00000e  7883              LDRB     r3,[r0,#2]
000010  eb032311          ADD      r3,r3,r1,LSR #8
000014  b2db              UXTB     r3,r3
000016  7093              STRB     r3,[r2,#2]
;;;253      uip_acc32[1] = op32[1];
000018  7844              LDRB     r4,[r0,#1]
00001a  7054              STRB     r4,[r2,#1]
;;;254      uip_acc32[0] = op32[0];
00001c  7800              LDRB     r0,[r0,#0]
;;;255    
;;;256      if(uip_acc32[2] < (op16 >> 8)) {
00001e  ebb32f11          CMP      r3,r1,LSR #8
000022  7010              STRB     r0,[r2,#0]            ;254
000024  d206              BCS      |L3.52|
;;;257        ++uip_acc32[1];
000026  1c64              ADDS     r4,r4,#1
000028  f01401ff          ANDS     r1,r4,#0xff
00002c  7051              STRB     r1,[r2,#1]
;;;258        if(uip_acc32[1] == 0) {
00002e  d101              BNE      |L3.52|
;;;259          ++uip_acc32[0];
000030  1c40              ADDS     r0,r0,#1
000032  7010              STRB     r0,[r2,#0]
                  |L3.52|
;;;260        }
;;;261      }
;;;262    
;;;263    
;;;264      if(uip_acc32[3] < (op16 & 0xff)) {
000034  42ae              CMP      r6,r5
000036  d20d              BCS      |L3.84|
;;;265        ++uip_acc32[2];
000038  1c5b              ADDS     r3,r3,#1
00003a  f01300ff          ANDS     r0,r3,#0xff
00003e  7090              STRB     r0,[r2,#2]
;;;266        if(uip_acc32[2] == 0) {
000040  d108              BNE      |L3.84|
;;;267          ++uip_acc32[1];
000042  7850              LDRB     r0,[r2,#1]  ; uip_acc32
000044  1c40              ADDS     r0,r0,#1
000046  f01000ff          ANDS     r0,r0,#0xff
00004a  7050              STRB     r0,[r2,#1]
;;;268          if(uip_acc32[1] == 0) {
00004c  d102              BNE      |L3.84|
;;;269    	++uip_acc32[0];
00004e  7810              LDRB     r0,[r2,#0]  ; uip_acc32
000050  1c40              ADDS     r0,r0,#1
000052  7010              STRB     r0,[r2,#0]
                  |L3.84|
;;;270          }
;;;271        }
;;;272      }
;;;273    }
000054  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      ||area_number.24||+0x28

                          AREA ||i.uip_add_rcv_nxt||, CODE, READONLY, ALIGN=2

                  uip_add_rcv_nxt PROC
;;;671    static void
;;;672    uip_add_rcv_nxt(u16_t n)
000000  b510              PUSH     {r4,lr}
;;;673    {
;;;674      uip_add32(uip_conn->rcv_nxt, n);
000002  4c09              LDR      r4,|L4.40|
000004  4601              MOV      r1,r0
000006  69e0              LDR      r0,[r4,#0x1c]  ; uip_conn
000008  3008              ADDS     r0,r0,#8
00000a  f7fffffe          BL       uip_add32
;;;675      uip_conn->rcv_nxt[0] = uip_acc32[0];
00000e  f1040028          ADD      r0,r4,#0x28
000012  69e1              LDR      r1,[r4,#0x1c]  ; uip_conn
000014  7802              LDRB     r2,[r0,#0]  ; uip_acc32
000016  720a              STRB     r2,[r1,#8]
;;;676      uip_conn->rcv_nxt[1] = uip_acc32[1];
000018  7842              LDRB     r2,[r0,#1]  ; uip_acc32
00001a  724a              STRB     r2,[r1,#9]
;;;677      uip_conn->rcv_nxt[2] = uip_acc32[2];
00001c  7882              LDRB     r2,[r0,#2]  ; uip_acc32
00001e  728a              STRB     r2,[r1,#0xa]
;;;678      uip_conn->rcv_nxt[3] = uip_acc32[3];
000020  78c0              LDRB     r0,[r0,#3]  ; uip_acc32
000022  72c8              STRB     r0,[r1,#0xb]
;;;679    }
000024  bd10              POP      {r4,pc}
;;;680    /*---------------------------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      ||area_number.24||

                          AREA ||i.uip_chksum||, CODE, READONLY, ALIGN=1

                  uip_chksum PROC
;;;310    u16_t
;;;311    uip_chksum(u16_t *data, u16_t len)
000000  460a              MOV      r2,r1
;;;312    {
000002  b510              PUSH     {r4,lr}
;;;313      return htons(chksum(0, (u8_t *)data, len));
000004  4601              MOV      r1,r0
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       chksum
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      htons
;;;314    }
;;;315    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_connect||, CODE, READONLY, ALIGN=2

                  uip_connect PROC
;;;406    struct uip_conn *
;;;407    uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;408    {
000004  4689              MOV      r9,r1
;;;409      register struct uip_conn *conn, *cconn;
;;;410    
;;;411      /* Find an unused local port. */
;;;412     again:
;;;413      ++lastport;
;;;414    
;;;415      if(lastport >= 32000) {
;;;416        lastport = 4096;
;;;417      }
;;;418    
;;;419      /* Check if this port is already in use, and if so try to find
;;;420         another one. */
;;;421      for(c = 0; c < UIP_CONNS; ++c) {
;;;422        conn = &uip_conns[c];
000006  4a36              LDR      r2,|L6.224|
000008  4936              LDR      r1,|L6.228|
00000a  4680              MOV      r8,r0                 ;408
00000c  f44f47fa          MOV      r7,#0x7d00            ;415
000010  f44f5c80          MOV      r12,#0x1000           ;416
000014  2600              MOVS     r6,#0                 ;421
                  |L6.22|
000016  8948              LDRH     r0,[r1,#0xa]          ;413  ; lastport
000018  1c40              ADDS     r0,r0,#1              ;413
00001a  b280              UXTH     r0,r0                 ;413
00001c  8148              STRH     r0,[r1,#0xa]          ;413
00001e  42b8              CMP      r0,r7                 ;415
000020  d301              BCC      |L6.38|
000022  f8a1c00a          STRH     r12,[r1,#0xa]         ;416
                  |L6.38|
000026  704e              STRB     r6,[r1,#1]            ;421
000028  894b              LDRH     r3,[r1,#0xa]          ;413
;;;423        if(conn->tcpstateflags != UIP_CLOSED &&
;;;424           conn->lport == htons(lastport)) {
00002a  0218              LSLS     r0,r3,#8
00002c  ea402013          ORR      r0,r0,r3,LSR #8
000030  b284              UXTH     r4,r0
                  |L6.50|
000032  784b              LDRB     r3,[r1,#1]            ;422  ; c
000034  eb030043          ADD      r0,r3,r3,LSL #1       ;422
000038  ebc01043          RSB      r0,r0,r3,LSL #5       ;422
00003c  eb020080          ADD      r0,r2,r0,LSL #2       ;422
000040  7e45              LDRB     r5,[r0,#0x19]         ;423
000042  b115              CBZ      r5,|L6.74|
000044  8880              LDRH     r0,[r0,#4]
000046  4284              CMP      r4,r0
000048  d0e5              BEQ      |L6.22|
                  |L6.74|
00004a  1c5b              ADDS     r3,r3,#1              ;421
00004c  b2d8              UXTB     r0,r3                 ;421
00004e  7048              STRB     r0,[r1,#1]            ;421
000050  2828              CMP      r0,#0x28              ;421
000052  d3ee              BCC      |L6.50|
;;;425          goto again;
;;;426        }
;;;427      }
;;;428    
;;;429      conn = 0;
000054  2300              MOVS     r3,#0
;;;430      for(c = 0; c < UIP_CONNS; ++c) {
000056  704e              STRB     r6,[r1,#1]
                  |L6.88|
;;;431        cconn = &uip_conns[c];
000058  784c              LDRB     r4,[r1,#1]  ; c
00005a  eb040044          ADD      r0,r4,r4,LSL #1
00005e  ebc01044          RSB      r0,r0,r4,LSL #5
000062  eb020080          ADD      r0,r2,r0,LSL #2
;;;432        if(cconn->tcpstateflags == UIP_CLOSED) {
000066  7e45              LDRB     r5,[r0,#0x19]
000068  b115              CBZ      r5,|L6.112|
;;;433          conn = cconn;
;;;434          break;
;;;435        }
;;;436        if(cconn->tcpstateflags == UIP_TIME_WAIT) {
00006a  2d07              CMP      r5,#7
00006c  d002              BEQ      |L6.116|
00006e  e007              B        |L6.128|
                  |L6.112|
000070  4603              MOV      r3,r0                 ;433
000072  e00a              B        |L6.138|
                  |L6.116|
;;;437          if(conn == 0 ||
000074  b11b              CBZ      r3,|L6.126|
;;;438    	 cconn->timer > conn->timer) {
000076  7e85              LDRB     r5,[r0,#0x1a]
000078  7e9f              LDRB     r7,[r3,#0x1a]
00007a  42bd              CMP      r5,r7
00007c  d900              BLS      |L6.128|
                  |L6.126|
;;;439    	conn = cconn;
00007e  4603              MOV      r3,r0
                  |L6.128|
000080  1c64              ADDS     r4,r4,#1              ;430
000082  b2e0              UXTB     r0,r4                 ;430
000084  7048              STRB     r0,[r1,#1]            ;430
000086  2828              CMP      r0,#0x28              ;430
000088  d3e6              BCC      |L6.88|
                  |L6.138|
;;;440          }
;;;441        }
;;;442      }
;;;443    
;;;444      if(conn == 0) {
00008a  b33b              CBZ      r3,|L6.220|
;;;445        return 0;
;;;446      }
;;;447    
;;;448      conn->tcpstateflags = UIP_SYN_SENT;
00008c  2002              MOVS     r0,#2
00008e  7658              STRB     r0,[r3,#0x19]
;;;449    
;;;450      conn->snd_nxt[0] = iss[0];
000090  4814              LDR      r0,|L6.228|
000092  3024              ADDS     r0,r0,#0x24
000094  7802              LDRB     r2,[r0,#0]  ; iss
000096  731a              STRB     r2,[r3,#0xc]
;;;451      conn->snd_nxt[1] = iss[1];
000098  7842              LDRB     r2,[r0,#1]  ; iss
00009a  735a              STRB     r2,[r3,#0xd]
;;;452      conn->snd_nxt[2] = iss[2];
00009c  7882              LDRB     r2,[r0,#2]  ; iss
00009e  739a              STRB     r2,[r3,#0xe]
;;;453      conn->snd_nxt[3] = iss[3];
0000a0  78c0              LDRB     r0,[r0,#3]  ; iss
0000a2  73d8              STRB     r0,[r3,#0xf]
;;;454    
;;;455      conn->initialmss = conn->mss = UIP_TCP_MSS;
0000a4  f64070ca          MOV      r0,#0xfca
0000a8  8258              STRH     r0,[r3,#0x12]
0000aa  8298              STRH     r0,[r3,#0x14]
;;;456    
;;;457      conn->len = 1;   /* TCP length of the SYN is one. */
0000ac  2001              MOVS     r0,#1
0000ae  8218              STRH     r0,[r3,#0x10]
;;;458      conn->nrtx = 0;
0000b0  76de              STRB     r6,[r3,#0x1b]
;;;459      conn->timer = 1; /* Send the SYN next time around. */
0000b2  7698              STRB     r0,[r3,#0x1a]
;;;460      conn->rto = UIP_RTO;
0000b4  2003              MOVS     r0,#3
0000b6  7618              STRB     r0,[r3,#0x18]
;;;461      conn->sa = 0;
0000b8  759e              STRB     r6,[r3,#0x16]
;;;462      conn->sv = 16;   /* Initial value of the RTT variance. */
0000ba  2010              MOVS     r0,#0x10
0000bc  75d8              STRB     r0,[r3,#0x17]
;;;463      conn->lport = htons(lastport);
0000be  8948              LDRH     r0,[r1,#0xa]  ; lastport
0000c0  f7fffffe          BL       htons
0000c4  8098              STRH     r0,[r3,#4]
;;;464      conn->rport = rport;
0000c6  f8a39006          STRH     r9,[r3,#6]
;;;465      uip_ipaddr_copy(&conn->ripaddr, ripaddr);
0000ca  f8b80000          LDRH     r0,[r8,#0]
0000ce  8018              STRH     r0,[r3,#0]
0000d0  f8b80002          LDRH     r0,[r8,#2]
0000d4  8058              STRH     r0,[r3,#2]
;;;466    
;;;467      return conn;
0000d6  4618              MOV      r0,r3
                  |L6.216|
;;;468    }
0000d8  e8bd83f0          POP      {r4-r9,pc}
                  |L6.220|
0000dc  2000              MOVS     r0,#0                 ;445
0000de  e7fb              B        |L6.216|
;;;469    #endif /* UIP_ACTIVE_OPEN */
                          ENDP

                  |L6.224|
                          DCD      ||.bss||+0x1004
                  |L6.228|
                          DCD      ||area_number.24||

                          AREA ||i.uip_init||, CODE, READONLY, ALIGN=2

                  uip_init PROC
;;;378    void
;;;379    uip_init(void)
000000  b510              PUSH     {r4,lr}
;;;380    {
;;;381      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4816              LDR      r0,|L7.92|
000004  2100              MOVS     r1,#0
;;;382        uip_listenports[c] = 0;
000006  4c16              LDR      r4,|L7.96|
000008  7041              STRB     r1,[r0,#1]            ;381
                  |L7.10|
00000a  7842              LDRB     r2,[r0,#1]  ; c
00000c  1c53              ADDS     r3,r2,#1              ;381
00000e  b2db              UXTB     r3,r3                 ;381
000010  f8241012          STRH     r1,[r4,r2,LSL #1]
000014  7043              STRB     r3,[r0,#1]            ;381
000016  2b28              CMP      r3,#0x28              ;381
000018  d3f7              BCC      |L7.10|
;;;383      }
;;;384      for(c = 0; c < UIP_CONNS; ++c) {
;;;385        uip_conns[c].tcpstateflags = UIP_CLOSED;
00001a  4b12              LDR      r3,|L7.100|
00001c  7041              STRB     r1,[r0,#1]            ;384
                  |L7.30|
00001e  7842              LDRB     r2,[r0,#1]  ; c
000020  eb020442          ADD      r4,r2,r2,LSL #1
000024  ebc41442          RSB      r4,r4,r2,LSL #5
000028  eb030484          ADD      r4,r3,r4,LSL #2
00002c  1c52              ADDS     r2,r2,#1              ;384
00002e  b2d2              UXTB     r2,r2                 ;384
000030  7661              STRB     r1,[r4,#0x19]
000032  7042              STRB     r2,[r0,#1]            ;384
000034  2a28              CMP      r2,#0x28              ;384
000036  d3f2              BCC      |L7.30|
;;;386      }
;;;387    #if UIP_ACTIVE_OPEN
;;;388      lastport = 1024;
000038  f44f6280          MOV      r2,#0x400
;;;389    #endif /* UIP_ACTIVE_OPEN */
;;;390    
;;;391    #if UIP_UDP
;;;392      for(c = 0; c < UIP_UDP_CONNS; ++c) {
;;;393        uip_udp_conns[c].lport = 0;
00003c  4b08              LDR      r3,|L7.96|
00003e  8142              STRH     r2,[r0,#0xa]          ;388
000040  7041              STRB     r1,[r0,#1]            ;392
000042  3350              ADDS     r3,r3,#0x50
                  |L7.68|
000044  7842              LDRB     r2,[r0,#1]  ; c
000046  eb020442          ADD      r4,r2,r2,LSL #1
00004a  eb0304c4          ADD      r4,r3,r4,LSL #3
00004e  1c52              ADDS     r2,r2,#1              ;392
000050  b2d2              UXTB     r2,r2                 ;392
000052  80a1              STRH     r1,[r4,#4]
000054  7042              STRB     r2,[r0,#1]            ;392
000056  2a0a              CMP      r2,#0xa               ;392
000058  d3f4              BCC      |L7.68|
;;;394      }
;;;395    #endif /* UIP_UDP */
;;;396    
;;;397    
;;;398      /* IPv4 initialization. */
;;;399    #if UIP_FIXEDADDR == 0
;;;400      /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
;;;401    #endif /* UIP_FIXEDADDR */
;;;402    
;;;403    }
00005a  bd10              POP      {r4,pc}
;;;404    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L7.92|
                          DCD      ||area_number.24||
                  |L7.96|
                          DCD      ||.bss||+0x2224
                  |L7.100|
                          DCD      ||.bss||+0x1004

                          AREA ||i.uip_ipchksum||, CODE, READONLY, ALIGN=2

                  uip_ipchksum PROC
;;;317    u16_t
;;;318    uip_ipchksum(void)
000000  b510              PUSH     {r4,lr}
;;;319    {
;;;320      u16_t sum;
;;;321    
;;;322      sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
000002  2214              MOVS     r2,#0x14
000004  4906              LDR      r1,|L8.32|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       chksum
;;;323      DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
;;;324      return (sum == 0) ? 0xffff : htons(sum);
00000c  f64f71ff          MOV      r1,#0xffff
000010  b118              CBZ      r0,|L8.26|
000012  0201              LSLS     r1,r0,#8
000014  ea412010          ORR      r0,r1,r0,LSR #8
000018  b281              UXTH     r1,r0
                  |L8.26|
00001a  4608              MOV      r0,r1
;;;325    }
00001c  bd10              POP      {r4,pc}
;;;326    #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      ||.bss||+0xe

                          AREA ||i.uip_listen||, CODE, READONLY, ALIGN=2

                  uip_listen PROC
;;;528    void
;;;529    uip_listen(u16_t port)
000000  4909              LDR      r1,|L9.40|
;;;530    {
000002  b510              PUSH     {r4,lr}
;;;531      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000004  2200              MOVS     r2,#0
;;;532        if(uip_listenports[c] == 0) {
000006  4b09              LDR      r3,|L9.44|
000008  704a              STRB     r2,[r1,#1]            ;531
                  |L9.10|
00000a  b2d2              UXTB     r2,r2
00000c  f8334012          LDRH     r4,[r3,r2,LSL #1]
000010  b12c              CBZ      r4,|L9.30|
000012  1c52              ADDS     r2,r2,#1              ;531
000014  b2d2              UXTB     r2,r2                 ;531
000016  704a              STRB     r2,[r1,#1]            ;531
000018  2a28              CMP      r2,#0x28              ;531
00001a  d3f6              BCC      |L9.10|
;;;533          uip_listenports[c] = port;
;;;534          return;
;;;535        }
;;;536      }
;;;537    }
00001c  bd10              POP      {r4,pc}
                  |L9.30|
00001e  b2d1              UXTB     r1,r2                 ;533
000020  f8230011          STRH     r0,[r3,r1,LSL #1]     ;533
000024  bd10              POP      {r4,pc}
;;;538    /*---------------------------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      ||area_number.24||
                  |L9.44|
                          DCD      ||.bss||+0x2224

                          AREA ||i.uip_process||, CODE, READONLY, ALIGN=2

                  uip_process PROC
;;;681    void
;;;682    uip_process(u8_t flag)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;683    {
;;;684      register struct uip_conn *uip_connr = uip_conn;
000004  4ffe              LDR      r7,|L10.1024|
;;;685    
;;;686    #if UIP_UDP
;;;687      if(flag == UIP_UDP_SEND_CONN) {
;;;688        goto udp_send;
;;;689      }
;;;690    #endif /* UIP_UDP */
;;;691    
;;;692      uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
000006  4dff              LDR      r5,|L10.1028|
;;;693    
;;;694      /* Check if we were invoked because of a poll request for a
;;;695         particular connection. */
;;;696      if(flag == UIP_POLL_REQUEST) {
;;;697        if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
;;;698           !uip_outstanding(uip_connr)) {
000008  2600              MOVS     r6,#0
00000a  f1050136          ADD      r1,r5,#0x36           ;692
;;;699    	uip_flags = UIP_POLL;
;;;700    	UIP_APPCALL();
;;;701    	goto appsend;
;;;702        }
;;;703        goto drop;
;;;704    
;;;705        /* Check if we were invoked because of the perodic timer fireing. */
;;;706      } else if(flag == UIP_TIMER) {
;;;707    #if UIP_REASSEMBLY
;;;708        if(uip_reasstmr != 0) {
;;;709          --uip_reasstmr;
;;;710        }
;;;711    #endif /* UIP_REASSEMBLY */
;;;712        /* Increase the initial sequence number. */
;;;713        if(++iss[3] == 0) {
;;;714          if(++iss[2] == 0) {
;;;715    	if(++iss[1] == 0) {
;;;716    	  ++iss[0];
;;;717    	}
;;;718          }
;;;719        }
;;;720    
;;;721        /* Reset the length variables. */
;;;722        uip_len = 0;
;;;723        uip_slen = 0;
;;;724    
;;;725        /* Check if the connection is in a state in which we simply wait
;;;726           for the connection to time out. If so, we increase the
;;;727           connection's timer and remove the connection if it times
;;;728           out. */
;;;729        if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
;;;730           uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
;;;731          ++(uip_connr->timer);
;;;732          if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
;;;733    	uip_connr->tcpstateflags = UIP_CLOSED;
;;;734          }
;;;735        } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
;;;736          /* If the connection has outstanding data, we increase the
;;;737    	 connection's timer and see if it has reached the RTO value
;;;738    	 in which case we retransmit. */
;;;739          if(uip_outstanding(uip_connr)) {
;;;740    	if(uip_connr->timer-- == 0) {
;;;741    	  if(uip_connr->nrtx == UIP_MAXRTX ||
;;;742    	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
;;;743    	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
;;;744    	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
;;;745    	    uip_connr->tcpstateflags = UIP_CLOSED;
;;;746    
;;;747    	    /* We call UIP_APPCALL() with uip_flags set to
;;;748    	       UIP_TIMEDOUT to inform the application that the
;;;749    	       connection has timed out. */
;;;750    	    uip_flags = UIP_TIMEDOUT;
;;;751    	    UIP_APPCALL();
;;;752    
;;;753    	    /* We also send a reset packet to the remote host. */
;;;754    	    BUF->flags = TCP_RST | TCP_ACK;
;;;755    	    goto tcp_send_nodata;
;;;756    	  }
;;;757    
;;;758    	  /* Exponential backoff. */
;;;759    	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
;;;760    					 4:
;;;761    					 uip_connr->nrtx);
;;;762    	  ++(uip_connr->nrtx);
;;;763    
;;;764    	  /* Ok, so we need to retransmit. We do this differently
;;;765    	     depending on which state we are in. In ESTABLISHED, we
;;;766    	     call upon the application so that it may prepare the
;;;767    	     data for the retransmit. In SYN_RCVD, we resend the
;;;768    	     SYNACK that we sent earlier and in LAST_ACK we have to
;;;769    	     retransmit our FINACK. */
;;;770    	  UIP_STAT(++uip_stat.tcp.rexmit);
00000e  f8dfb3f8          LDR      r11,|L10.1032|
000012  69fc              LDR      r4,[r7,#0x1c]         ;687  ; uip_conn
000014  4689              MOV      r9,r1                 ;692
000016  2804              CMP      r0,#4                 ;687
000018  d079              BEQ      |L10.270|
00001a  6179              STR      r1,[r7,#0x14]         ;692  ; uip_appdata
;;;771    	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
;;;772    	  case UIP_SYN_RCVD:
;;;773    	    /* In the SYN_RCVD state, we should retransmit our
;;;774                   SYNACK. */
;;;775    	    goto tcp_send_synack;
;;;776    
;;;777    #if UIP_ACTIVE_OPEN
;;;778    	  case UIP_SYN_SENT:
;;;779    	    /* In the SYN_SENT state, we retransmit out SYN. */
;;;780    	    BUF->flags = 0;
;;;781    	    goto tcp_send_syn;
;;;782    #endif /* UIP_ACTIVE_OPEN */
;;;783    
;;;784    	  case UIP_ESTABLISHED:
;;;785    	    /* In the ESTABLISHED state, we call upon the application
;;;786                   to do the actual retransmit after which we jump into
;;;787                   the code for sending out the packet (the apprexmit
;;;788                   label). */
;;;789    	    uip_flags = UIP_REXMIT;
;;;790    	    UIP_APPCALL();
;;;791    	    goto apprexmit;
;;;792    
;;;793    	  case UIP_FIN_WAIT_1:
;;;794    	  case UIP_CLOSING:
;;;795    	  case UIP_LAST_ACK:
;;;796    	    /* In all these states we should retransmit a FINACK. */
;;;797    	    goto tcp_send_finack;
;;;798    
;;;799    	  }
;;;800    	}
;;;801          } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
;;;802    	/* If there was no need for a retransmission, we poll the
;;;803               application for new data. */
;;;804    	uip_flags = UIP_POLL;
;;;805    	UIP_APPCALL();
;;;806    	goto appsend;
;;;807          }
;;;808        }
;;;809        goto drop;
;;;810      }
;;;811    #if UIP_UDP
;;;812      if(flag == UIP_UDP_TIMER) {
;;;813        if(uip_udp_conn->lport != 0) {
;;;814          uip_conn = NULL;
;;;815          uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;816          uip_len = uip_slen = 0;
;;;817          uip_flags = UIP_POLL;
;;;818          UIP_UDP_APPCALL();
;;;819          goto udp_send;
;;;820        } else {
;;;821          goto drop;
;;;822        }
;;;823      }
;;;824    #endif
;;;825    
;;;826      /* This is where the input processing starts. */
;;;827      UIP_STAT(++uip_stat.ip.recv);
;;;828    
;;;829      /* Start of IP input header processing code. */
;;;830    
;;;831    #if UIP_CONF_IPV6
;;;832      /* Check validity of the IP header. */
;;;833      if((BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
;;;834        UIP_STAT(++uip_stat.ip.drop);
;;;835        UIP_STAT(++uip_stat.ip.vhlerr);
;;;836        UIP_LOG("ipv6: invalid version.");
;;;837        goto drop;
;;;838      }
;;;839    #else /* UIP_CONF_IPV6 */
;;;840      /* Check validity of the IP header. */
;;;841      if(BUF->vhl != 0x45)  { /* IP version and header length. */
;;;842        UIP_STAT(++uip_stat.ip.drop);
;;;843        UIP_STAT(++uip_stat.ip.vhlerr);
;;;844        UIP_LOG("ip: invalid version or header length.");
;;;845        goto drop;
;;;846      }
;;;847    #endif /* UIP_CONF_IPV6 */
;;;848    
;;;849      /* Check the size of the packet. If the size reported to us in
;;;850         uip_len is smaller the size reported in the IP header, we assume
;;;851         that the packet has been corrupted in transit. If the size of
;;;852         uip_len is larger than the size reported in the IP packet header,
;;;853         the packet has been padded and we set uip_len to the correct
;;;854         value.. */
;;;855    
;;;856      if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
;;;857        uip_len = (BUF->len[0] << 8) + BUF->len[1];
;;;858    #if UIP_CONF_IPV6
;;;859        uip_len += 40; /* The length reported in the IPv6 header is the
;;;860    		      length of the payload that follows the
;;;861    		      header. However, uIP uses the uip_len variable
;;;862    		      for holding the size of the entire packet,
;;;863    		      including the IP header. For IPv4 this is not a
;;;864    		      problem as the length field in the IPv4 header
;;;865    		      contains the length of the entire packet. But
;;;866    		      for IPv6 we need to add the size of the IPv6
;;;867    		      header (40 bytes). */
;;;868    #endif /* UIP_CONF_IPV6 */
;;;869      } else {
;;;870        UIP_LOG("ip: packet shorter than reported in IP header.");
;;;871        goto drop;
;;;872      }
;;;873    
;;;874    #if !UIP_CONF_IPV6
;;;875      /* Check the fragment flag. */
;;;876      if((BUF->ipoffset[0] & 0x3f) != 0 ||
;;;877         BUF->ipoffset[1] != 0) {
;;;878    #if UIP_REASSEMBLY
;;;879        uip_len = uip_reass();
;;;880        if(uip_len == 0) {
;;;881          goto drop;
;;;882        }
;;;883    #else /* UIP_REASSEMBLY */
;;;884        UIP_STAT(++uip_stat.ip.drop);
;;;885        UIP_STAT(++uip_stat.ip.fragerr);
;;;886        UIP_LOG("ip: fragment dropped.");
;;;887        goto drop;
;;;888    #endif /* UIP_REASSEMBLY */
;;;889      }
;;;890    #endif /* UIP_CONF_IPV6 */
;;;891    
;;;892      if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
;;;893        /* If we are configured to use ping IP address configuration and
;;;894           hasn't been assigned an IP address yet, we accept all ICMP
;;;895           packets. */
;;;896    #if UIP_PINGADDRCONF && !UIP_CONF_IPV6
;;;897        if(BUF->proto == UIP_PROTO_ICMP) {
;;;898          UIP_LOG("ip: possible ping config packet received.");
;;;899          goto icmp_input;
;;;900        } else {
;;;901          UIP_LOG("ip: packet dropped since no address assigned.");
;;;902          goto drop;
;;;903        }
;;;904    #endif /* UIP_PINGADDRCONF */
;;;905    
;;;906      } else {
;;;907        /* If IP broadcast support is configured, we check for a broadcast
;;;908           UDP packet, which may be destined to us. */
;;;909    #if UIP_BROADCAST
;;;910        DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
;;;911        if(BUF->proto == UIP_PROTO_UDP &&
;;;912           uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr)
;;;913           /*&&
;;;914    	 uip_ipchksum() == 0xffff*/) {
;;;915          goto udp_input;
;;;916        }
;;;917    #endif /* UIP_BROADCAST */
;;;918    
;;;919        /* Check if the packet is destined for our IP address. */
;;;920    #if !UIP_CONF_IPV6
;;;921        if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
;;;922          UIP_STAT(++uip_stat.ip.drop);
;;;923          goto drop;
;;;924        }
;;;925    #else /* UIP_CONF_IPV6 */
;;;926        /* For IPv6, packet reception is a little trickier as we need to
;;;927           make sure that we listen to certain multicast addresses (all
;;;928           hosts multicast address, and the solicited-node multicast
;;;929           address) as well. However, we will cheat here and accept all
;;;930           multicast packets that are sent to the ff02::/16 addresses. */
;;;931        if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr) &&
;;;932           BUF->destipaddr[0] != HTONS(0xff02)) {
;;;933          UIP_STAT(++uip_stat.ip.drop);
;;;934          goto drop;
;;;935        }
;;;936    #endif /* UIP_CONF_IPV6 */
;;;937      }
;;;938    
;;;939    #if !UIP_CONF_IPV6
;;;940      if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
;;;941    				    checksum. */
;;;942        UIP_STAT(++uip_stat.ip.drop);
;;;943        UIP_STAT(++uip_stat.ip.chkerr);
;;;944        UIP_LOG("ip: bad checksum.");
;;;945        goto drop;
;;;946      }
;;;947    #endif /* UIP_CONF_IPV6 */
;;;948    
;;;949    
;;;950      if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
;;;951    				       proceed with TCP input
;;;952    				       processing. */
;;;953        goto tcp_input;
;;;954      }
;;;955    
;;;956    #if UIP_UDP
;;;957      if(BUF->proto == UIP_PROTO_UDP) {
;;;958        goto udp_input;
;;;959      }
;;;960    #endif /* UIP_UDP */
;;;961    
;;;962    #if !UIP_CONF_IPV6
;;;963      /* ICMPv4 processing code follows. */
;;;964      if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
;;;965    					here. */
;;;966        UIP_STAT(++uip_stat.ip.drop);
;;;967        UIP_STAT(++uip_stat.ip.protoerr);
;;;968        UIP_LOG("ip: neither tcp nor icmp.");
;;;969        goto drop;
;;;970      }
;;;971    
;;;972    #if UIP_PINGADDRCONF
;;;973     icmp_input:
;;;974    #endif /* UIP_PINGADDRCONF */
;;;975      UIP_STAT(++uip_stat.icmp.recv);
;;;976    
;;;977      /* ICMP echo (i.e., ping) processing. This is simple, we only change
;;;978         the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
;;;979         checksum before we return the packet. */
;;;980      if(ICMPBUF->type != ICMP_ECHO) {
;;;981        UIP_STAT(++uip_stat.icmp.drop);
;;;982        UIP_STAT(++uip_stat.icmp.typeerr);
;;;983        UIP_LOG("icmp: not icmp echo.");
;;;984        goto drop;
;;;985      }
;;;986    
;;;987      /* If we are configured to use ping IP address assignment, we use
;;;988         the destination IP address of this ping packet and assign it to
;;;989         ourself. */
;;;990    #if UIP_PINGADDRCONF
;;;991      if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
;;;992        uip_hostaddr[0] = BUF->destipaddr[0];
;;;993        uip_hostaddr[1] = BUF->destipaddr[1];
;;;994      }
;;;995    #endif /* UIP_PINGADDRCONF */
;;;996    
;;;997      ICMPBUF->type = ICMP_ECHO_REPLY;
;;;998    
;;;999      if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
;;;1000       ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
;;;1001     } else {
;;;1002       ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
;;;1003     }
;;;1004   
;;;1005     /* Swap IP addresses. */
;;;1006     uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
;;;1007     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1008   
;;;1009     UIP_STAT(++uip_stat.icmp.sent);
;;;1010     goto send;
;;;1011   
;;;1012     /* End of IPv4 input header processing code. */
;;;1013   #else /* !UIP_CONF_IPV6 */
;;;1014   
;;;1015     /* This is IPv6 ICMPv6 processing code. */
;;;1016     DEBUG_PRINTF("icmp6_input: length %d\n", uip_len);
;;;1017   
;;;1018     if(BUF->proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
;;;1019   					 here. */
;;;1020       UIP_STAT(++uip_stat.ip.drop);
;;;1021       UIP_STAT(++uip_stat.ip.protoerr);
;;;1022       UIP_LOG("ip: neither tcp nor icmp6.");
;;;1023       goto drop;
;;;1024     }
;;;1025   
;;;1026     UIP_STAT(++uip_stat.icmp.recv);
;;;1027   
;;;1028     /* If we get a neighbor solicitation for our address we should send
;;;1029        a neighbor advertisement message back. */
;;;1030     if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION) {
;;;1031       if(uip_ipaddr_cmp(ICMPBUF->icmp6data, uip_hostaddr)) {
;;;1032   
;;;1033         if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
;;;1034   	/* Save the sender's address in our neighbor list. */
;;;1035   	uip_neighbor_add(ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
;;;1036         }
;;;1037   
;;;1038         /* We should now send a neighbor advertisement back to where the
;;;1039   	 neighbor solicication came from. */
;;;1040         ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
;;;1041         ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
;;;1042   
;;;1043         ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
;;;1044   
;;;1045         uip_ipaddr_copy(ICMPBUF->destipaddr, ICMPBUF->srcipaddr);
;;;1046         uip_ipaddr_copy(ICMPBUF->srcipaddr, uip_hostaddr);
;;;1047         ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
;;;1048         ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
;;;1049         memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
;;;1050         ICMPBUF->icmpchksum = 0;
;;;1051         ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1052         goto send;
;;;1053   
;;;1054       }
;;;1055       goto drop;
;;;1056     } else if(ICMPBUF->type == ICMP6_ECHO) {
;;;1057       /* ICMP echo (i.e., ping) processing. This is simple, we only
;;;1058          change the ICMP type from ECHO to ECHO_REPLY and update the
;;;1059          ICMP checksum before we return the packet. */
;;;1060   
;;;1061       ICMPBUF->type = ICMP6_ECHO_REPLY;
;;;1062   
;;;1063       uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
;;;1064       uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1065       ICMPBUF->icmpchksum = 0;
;;;1066       ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1067   
;;;1068       UIP_STAT(++uip_stat.icmp.sent);
;;;1069       goto send;
;;;1070     } else {
;;;1071       DEBUG_PRINTF("Unknown icmp6 message type %d\n", ICMPBUF->type);
;;;1072       UIP_STAT(++uip_stat.icmp.drop);
;;;1073       UIP_STAT(++uip_stat.icmp.typeerr);
;;;1074       UIP_LOG("icmp: unknown ICMP message.");
;;;1075       goto drop;
;;;1076     }
;;;1077   
;;;1078     /* End of IPv6 ICMP processing. */
;;;1079   
;;;1080   #endif /* !UIP_CONF_IPV6 */
;;;1081   
;;;1082   #if UIP_UDP
;;;1083     /* UDP input processing. */
;;;1084    udp_input:
;;;1085     /* UDP processing is really just a hack. We don't do anything to the
;;;1086        UDP/IP headers, but let the UDP application do all the hard
;;;1087        work. If the application sets uip_slen, it has a packet to
;;;1088        send. */
;;;1089   #if UIP_UDP_CHECKSUMS
;;;1090     uip_len = uip_len - UIP_IPUDPH_LEN;
;;;1091     uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;1092     if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
;;;1093       UIP_STAT(++uip_stat.udp.drop);
;;;1094       UIP_STAT(++uip_stat.udp.chkerr);
;;;1095       UIP_LOG("udp: bad checksum.");
;;;1096       goto drop;
;;;1097     }
;;;1098   #else /* UIP_UDP_CHECKSUMS */
;;;1099     uip_len = uip_len - UIP_IPUDPH_LEN;
;;;1100   #endif /* UIP_UDP_CHECKSUMS */
;;;1101   
;;;1102     /* Demultiplex this UDP packet between the UDP "connections". */
;;;1103     for(uip_udp_conn = &uip_udp_conns[0];
;;;1104         uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
;;;1105         ++uip_udp_conn) {
;;;1106       /* If the local UDP port is non-zero, the connection is considered
;;;1107          to be used. If so, the local port number is checked against the
;;;1108          destination port number in the received packet. If the two port
;;;1109          numbers match, the remote port number is checked if the
;;;1110          connection is bound to a remote port. Finally, if the
;;;1111          connection is bound to a remote IP address, the source IP
;;;1112          address of the packet is checked. */
;;;1113       if(uip_udp_conn->lport != 0 &&
;;;1114          UDPBUF->destport == uip_udp_conn->lport &&
;;;1115          (uip_udp_conn->rport == 0 ||
;;;1116           UDPBUF->srcport == uip_udp_conn->rport) &&
;;;1117          (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
;;;1118   	uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_ones_addr) ||
;;;1119   	uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) {
;;;1120         goto udp_found;
;;;1121       }
;;;1122     }
;;;1123     UIP_LOG("udp: no matching connection found");
;;;1124     goto drop;
;;;1125   
;;;1126    udp_found:
;;;1127     uip_conn = NULL;
;;;1128     uip_flags = UIP_NEWDATA;
;;;1129     uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;1130     uip_slen = 0;
;;;1131     UIP_UDP_APPCALL();
;;;1132    udp_send:
;;;1133     if(uip_slen == 0) {
;;;1134       goto drop;
;;;1135     }
;;;1136     uip_len = uip_slen + UIP_IPUDPH_LEN;
;;;1137   
;;;1138   #if UIP_CONF_IPV6
;;;1139     /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1140        length. */
;;;1141     BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1142     BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1143   #else /* UIP_CONF_IPV6 */
;;;1144     BUF->len[0] = (uip_len >> 8);
;;;1145     BUF->len[1] = (uip_len & 0xff);
;;;1146   #endif /* UIP_CONF_IPV6 */
;;;1147   
;;;1148     BUF->ttl = uip_udp_conn->ttl;
;;;1149     BUF->proto = UIP_PROTO_UDP;
;;;1150   
;;;1151     UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
;;;1152     UDPBUF->udpchksum = 0;
;;;1153   
;;;1154     BUF->srcport  = uip_udp_conn->lport;
;;;1155     BUF->destport = uip_udp_conn->rport;
;;;1156   
;;;1157     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1158     uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
;;;1159   
;;;1160     uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
;;;1161   
;;;1162   #if UIP_UDP_CHECKSUMS
;;;1163     /* Calculate UDP checksum. */
;;;1164     UDPBUF->udpchksum = ~(uip_udpchksum());
;;;1165     if(UDPBUF->udpchksum == 0) {
;;;1166       UDPBUF->udpchksum = 0xffff;
;;;1167     }
;;;1168   #endif /* UIP_UDP_CHECKSUMS */
;;;1169   
;;;1170     goto ip_send_nolen;
;;;1171   #endif /* UIP_UDP */
;;;1172   
;;;1173     /* TCP input processing. */
;;;1174    tcp_input:
;;;1175     UIP_STAT(++uip_stat.tcp.recv);
;;;1176   
;;;1177     /* Start of TCP input header processing code. */
;;;1178   
;;;1179     if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
;;;1180   				       checksum. */
;;;1181       UIP_STAT(++uip_stat.tcp.drop);
;;;1182       UIP_STAT(++uip_stat.tcp.chkerr);
;;;1183       UIP_LOG("tcp: bad checksum.");
;;;1184       goto drop;
;;;1185     }
;;;1186   
;;;1187   
;;;1188     /* Demultiplex this segment. */
;;;1189     /* First check any active connections. */
;;;1190     for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
;;;1191         ++uip_connr) {
;;;1192       if(uip_connr->tcpstateflags != UIP_CLOSED &&
;;;1193          BUF->destport == uip_connr->lport &&
;;;1194          BUF->srcport == uip_connr->rport &&
;;;1195          uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
;;;1196         goto found;
;;;1197       }
;;;1198     }
;;;1199   
;;;1200     /* If we didn't find and active connection that expected the packet,
;;;1201        either this packet is an old duplicate, or this is a SYN packet
;;;1202        destined for a connection in LISTEN. If the SYN flag isn't set,
;;;1203        it is an old packet and we send a RST. */
;;;1204     if((BUF->flags & TCP_CTL) != TCP_SYN) {
;;;1205       goto reset;
;;;1206     }
;;;1207   
;;;1208     tmp16 = BUF->destport;
;;;1209     /* Next, check listening connections. */
;;;1210     for(c = 0; c < UIP_LISTENPORTS; ++c) {
;;;1211       if(tmp16 == uip_listenports[c])
;;;1212         goto found_listen;
;;;1213     }
;;;1214   
;;;1215     /* No matching connection found, so we send a RST packet. */
;;;1216     UIP_STAT(++uip_stat.tcp.synrst);
;;;1217    reset:
;;;1218   
;;;1219     /* We do not send resets in response to resets. */
;;;1220     if(BUF->flags & TCP_RST) {
;;;1221       goto drop;
;;;1222     }
;;;1223   
;;;1224     UIP_STAT(++uip_stat.tcp.rst);
;;;1225   
;;;1226     BUF->flags = TCP_RST | TCP_ACK;
;;;1227     uip_len = UIP_IPTCPH_LEN;
;;;1228     BUF->tcpoffset = 5 << 4;
;;;1229   
;;;1230     /* Flip the seqno and ackno fields in the TCP header. */
;;;1231     c = BUF->seqno[3];
;;;1232     BUF->seqno[3] = BUF->ackno[3];
;;;1233     BUF->ackno[3] = c;
;;;1234   
;;;1235     c = BUF->seqno[2];
;;;1236     BUF->seqno[2] = BUF->ackno[2];
;;;1237     BUF->ackno[2] = c;
;;;1238   
;;;1239     c = BUF->seqno[1];
;;;1240     BUF->seqno[1] = BUF->ackno[1];
;;;1241     BUF->ackno[1] = c;
;;;1242   
;;;1243     c = BUF->seqno[0];
;;;1244     BUF->seqno[0] = BUF->ackno[0];
;;;1245     BUF->ackno[0] = c;
;;;1246   
;;;1247     /* We also have to increase the sequence number we are
;;;1248        acknowledging. If the least significant byte overflowed, we need
;;;1249        to propagate the carry to the other bytes as well. */
;;;1250     if(++BUF->ackno[3] == 0) {
;;;1251       if(++BUF->ackno[2] == 0) {
;;;1252         if(++BUF->ackno[1] == 0) {
;;;1253   	++BUF->ackno[0];
;;;1254         }
;;;1255       }
;;;1256     }
;;;1257   
;;;1258     /* Swap port numbers. */
;;;1259     tmp16 = BUF->srcport;
;;;1260     BUF->srcport = BUF->destport;
;;;1261     BUF->destport = tmp16;
;;;1262   
;;;1263     /* Swap IP addresses. */
;;;1264     uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
;;;1265     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1266   
;;;1267     /* And send out the RST packet! */
;;;1268     goto tcp_send_noconn;
;;;1269   
;;;1270     /* This label will be jumped to if we matched the incoming packet
;;;1271        with a connection in LISTEN. In that case, we should create a new
;;;1272        connection and send a SYNACK in return. */
;;;1273    found_listen:
;;;1274     /* First we check if there are any connections avaliable. Unused
;;;1275        connections are kept in the same table as used connections, but
;;;1276        unused ones have the tcpstate set to CLOSED. Also, connections in
;;;1277        TIME_WAIT are kept track of and we'll use the oldest one if no
;;;1278        CLOSED connections are found. Thanks to Eddie C. Dost for a very
;;;1279        nice algorithm for the TIME_WAIT search. */
;;;1280     uip_connr = 0;
;;;1281     for(c = 0; c < UIP_CONNS; ++c) {
;;;1282       if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
;;;1283         uip_connr = &uip_conns[c];
;;;1284         break;
;;;1285       }
;;;1286       if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
;;;1287         if(uip_connr == 0 ||
;;;1288   	 uip_conns[c].timer > uip_connr->timer) {
;;;1289   	uip_connr = &uip_conns[c];
;;;1290         }
;;;1291       }
;;;1292     }
;;;1293   
;;;1294     if(uip_connr == 0) {
;;;1295       /* All connections are used already, we drop packet and hope that
;;;1296          the remote end will retransmit the packet at a time when we
;;;1297          have more spare connections. */
;;;1298       UIP_STAT(++uip_stat.tcp.syndrop);
;;;1299       UIP_LOG("tcp: found no unused connections.");
;;;1300       goto drop;
;;;1301     }
;;;1302     uip_conn = uip_connr;
;;;1303   
;;;1304     /* Fill in the necessary fields for the new connection. */
;;;1305     uip_connr->rto = uip_connr->timer = UIP_RTO;
;;;1306     uip_connr->sa = 0;
;;;1307     uip_connr->sv = 4;
;;;1308     uip_connr->nrtx = 0;
;;;1309     uip_connr->lport = BUF->destport;
;;;1310     uip_connr->rport = BUF->srcport;
;;;1311     uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
;;;1312     uip_connr->tcpstateflags = UIP_SYN_RCVD;
;;;1313   
;;;1314     uip_connr->snd_nxt[0] = iss[0];
;;;1315     uip_connr->snd_nxt[1] = iss[1];
;;;1316     uip_connr->snd_nxt[2] = iss[2];
;;;1317     uip_connr->snd_nxt[3] = iss[3];
;;;1318     uip_connr->len = 1;
;;;1319   
;;;1320     /* rcv_nxt should be the seqno from the incoming packet + 1. */
;;;1321     uip_connr->rcv_nxt[3] = BUF->seqno[3];
;;;1322     uip_connr->rcv_nxt[2] = BUF->seqno[2];
;;;1323     uip_connr->rcv_nxt[1] = BUF->seqno[1];
;;;1324     uip_connr->rcv_nxt[0] = BUF->seqno[0];
;;;1325     uip_add_rcv_nxt(1);
;;;1326   
;;;1327     /* Parse the TCP MSS option, if present. */
;;;1328     if((BUF->tcpoffset & 0xf0) > 0x50) {
;;;1329       for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
;;;1330         opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
;;;1331         if(opt == TCP_OPT_END) {
;;;1332   	/* End of options. */
;;;1333   	break;
;;;1334         } else if(opt == TCP_OPT_NOOP) {
;;;1335   	++c;
;;;1336   	/* NOP option. */
;;;1337         } else if(opt == TCP_OPT_MSS &&
;;;1338   		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
;;;1339   	/* An MSS option with the right option length. */
;;;1340   	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
;;;1341   	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
;;;1342   	uip_connr->initialmss = uip_connr->mss =
;;;1343   	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
;;;1344   
;;;1345   	/* And we are done processing options. */
;;;1346   	break;
;;;1347         } else {
;;;1348   	/* All other options have a length field, so that we easily
;;;1349   	   can skip past them. */
;;;1350   	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
;;;1351   	  /* If the length field is zero, the options are malformed
;;;1352   	     and we don't process them further. */
;;;1353   	  break;
;;;1354   	}
;;;1355   	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
;;;1356         }
;;;1357       }
;;;1358     }
;;;1359   
;;;1360     /* Our response will be a SYNACK. */
;;;1361   #if UIP_ACTIVE_OPEN
;;;1362    tcp_send_synack:
;;;1363     BUF->flags = TCP_ACK;
00001c  f04f0a10          MOV      r10,#0x10
000020  61b9              STR      r1,[r7,#0x18]         ;696  ; uip_sappdata
000022  2803              CMP      r0,#3                 ;696
000024  d019              BEQ      |L10.90|
000026  2802              CMP      r0,#2                 ;706
000028  d022              BEQ      |L10.112|
00002a  390c              SUBS     r1,r1,#0xc            ;692
00002c  4688              MOV      r8,r1                 ;815
00002e  2805              CMP      r0,#5                 ;812
000030  d06e              BEQ      |L10.272|
000032  f8bb0002          LDRH     r0,[r11,#2]           ;827  ; uip_stat
000036  465c              MOV      r4,r11                ;827
000038  1c40              ADDS     r0,r0,#1              ;827
00003a  f8ab0002          STRH     r0,[r11,#2]           ;827
00003e  4658              MOV      r0,r11                ;770
000040  7ba9              LDRB     r1,[r5,#0xe]          ;841  ; uip_buf
000042  8800              LDRH     r0,[r0,#0]            ;842
000044  1c40              ADDS     r0,r0,#1              ;842
000046  b280              UXTH     r0,r0                 ;842
000048  2945              CMP      r1,#0x45              ;841
00004a  d063              BEQ      |L10.276|
00004c  8020              STRH     r0,[r4,#0]            ;842
00004e  88e0              LDRH     r0,[r4,#6]            ;843  ; uip_stat
000050  1c40              ADDS     r0,r0,#1              ;843
000052  f8ab0006          STRH     r0,[r11,#6]           ;843
000056  a0ed              ADR      r0,|L10.1036|
000058  e2fa              B        |L10.1616|
                  |L10.90|
00005a  7e60              LDRB     r0,[r4,#0x19]         ;697
00005c  f000000f          AND      r0,r0,#0xf            ;697
000060  2803              CMP      r0,#3                 ;697
                  |L10.98|
000062  d12b              BNE      |L10.188|
000064  8a20              LDRH     r0,[r4,#0x10]         ;698
000066  2800              CMP      r0,#0                 ;698
000068  d1fb              BNE      |L10.98|
                  |L10.106|
00006a  2008              MOVS     r0,#8                 ;699
00006c  7038              STRB     r0,[r7,#0]            ;699
00006e  e3f8              B        |L10.2146|
                  |L10.112|
000070  48e3              LDR      r0,|L10.1024|
000072  3024              ADDS     r0,r0,#0x24           ;713
000074  78c1              LDRB     r1,[r0,#3]            ;713  ; iss
000076  1c49              ADDS     r1,r1,#1              ;713
000078  f01101ff          ANDS     r1,r1,#0xff           ;713
00007c  70c1              STRB     r1,[r0,#3]            ;713
00007e  d10e              BNE      |L10.158|
000080  7881              LDRB     r1,[r0,#2]            ;714  ; iss
000082  1c49              ADDS     r1,r1,#1              ;714
000084  f01101ff          ANDS     r1,r1,#0xff           ;714
000088  7081              STRB     r1,[r0,#2]            ;714
00008a  d108              BNE      |L10.158|
00008c  7841              LDRB     r1,[r0,#1]            ;715  ; iss
00008e  1c49              ADDS     r1,r1,#1              ;715
000090  f01101ff          ANDS     r1,r1,#0xff           ;715
000094  7041              STRB     r1,[r0,#1]            ;715
000096  d102              BNE      |L10.158|
000098  7801              LDRB     r1,[r0,#0]            ;716  ; iss
00009a  1c49              ADDS     r1,r1,#1              ;716
00009c  7001              STRB     r1,[r0,#0]            ;716
                  |L10.158|
00009e  80be              STRH     r6,[r7,#4]            ;722
0000a0  80fe              STRH     r6,[r7,#6]            ;723
0000a2  7e60              LDRB     r0,[r4,#0x19]         ;729
0000a4  2807              CMP      r0,#7                 ;729
0000a6  d00a              BEQ      |L10.190|
0000a8  2805              CMP      r0,#5                 ;730
0000aa  d008              BEQ      |L10.190|
0000ac  2800              CMP      r0,#0                 ;735
0000ae  d005              BEQ      |L10.188|
0000b0  8a21              LDRH     r1,[r4,#0x10]         ;739
0000b2  b371              CBZ      r1,|L10.274|
0000b4  7ea1              LDRB     r1,[r4,#0x1a]         ;740
0000b6  1e48              SUBS     r0,r1,#1              ;740
0000b8  76a0              STRB     r0,[r4,#0x1a]         ;740
0000ba  b141              CBZ      r1,|L10.206|
                  |L10.188|
0000bc  e043              B        |L10.326|
                  |L10.190|
0000be  7ea0              LDRB     r0,[r4,#0x1a]         ;731
0000c0  1c40              ADDS     r0,r0,#1              ;731
0000c2  b2c0              UXTB     r0,r0                 ;731
0000c4  76a0              STRB     r0,[r4,#0x1a]         ;731
0000c6  2878              CMP      r0,#0x78              ;732
0000c8  d1f8              BNE      |L10.188|
0000ca  7666              STRB     r6,[r4,#0x19]         ;733
0000cc  e03b              B        |L10.326|
                  |L10.206|
0000ce  7ee0              LDRB     r0,[r4,#0x1b]         ;741
0000d0  2808              CMP      r0,#8                 ;741
0000d2  d027              BEQ      |L10.292|
0000d4  7e61              LDRB     r1,[r4,#0x19]         ;742
0000d6  2902              CMP      r1,#2                 ;742
0000d8  d001              BEQ      |L10.222|
0000da  2901              CMP      r1,#1                 ;743
0000dc  d101              BNE      |L10.226|
                  |L10.222|
0000de  2805              CMP      r0,#5                 ;744
0000e0  d020              BEQ      |L10.292|
                  |L10.226|
0000e2  2204              MOVS     r2,#4                 ;760
0000e4  4611              MOV      r1,r2                 ;760
0000e6  2804              CMP      r0,#4                 ;760
0000e8  d800              BHI      |L10.236|
0000ea  4601              MOV      r1,r0                 ;761
                  |L10.236|
0000ec  2003              MOVS     r0,#3                 ;761
0000ee  4088              LSLS     r0,r0,r1              ;761
0000f0  76a0              STRB     r0,[r4,#0x1a]         ;761
0000f2  7ee0              LDRB     r0,[r4,#0x1b]         ;762
0000f4  1c40              ADDS     r0,r0,#1              ;762
0000f6  76e0              STRB     r0,[r4,#0x1b]         ;762
0000f8  f8bb1026          LDRH     r1,[r11,#0x26]        ;770  ; uip_stat
0000fc  1c49              ADDS     r1,r1,#1              ;770
0000fe  f8ab1026          STRH     r1,[r11,#0x26]        ;770
000102  7e60              LDRB     r0,[r4,#0x19]         ;771
000104  f000000f          AND      r0,r0,#0xf            ;771
000108  2809              CMP      r0,#9                 ;771
00010a  d2d7              BCS      |L10.188|
00010c  e003              B        |L10.278|
                  |L10.270|
00010e  e0d9              B        |L10.708|
                  |L10.272|
000110  e01a              B        |L10.328|
                  |L10.274|
000112  e014              B        |L10.318|
                  |L10.276|
000114  e024              B        |L10.352|
                  |L10.278|
000116  e8dff000          TBB      [pc,r0]               ;771
00011a  16fe              DCB      0x16,0xfe
00011c  0b0efd16          DCB      0x0b,0x0e,0xfd,0x16
000120  fd16fd00          DCB      0xfd,0x16,0xfd,0x00
                  |L10.292|
000124  7666              STRB     r6,[r4,#0x19]         ;745
000126  2080              MOVS     r0,#0x80              ;750
000128  7038              STRB     r0,[r7,#0]            ;750
00012a  f7fffffe          BL       hello_world_appcall
00012e  e3fe              B        |L10.2350|
000130  f885602f          STRB     r6,[r5,#0x2f]         ;780
000134  e2ac              B        |L10.1680|
000136  703a              STRB     r2,[r7,#0]            ;789
000138  f7fffffe          BL       hello_world_appcall
00013c  e3f8              B        |L10.2352|
                  |L10.318|
00013e  f000000f          AND      r0,r0,#0xf            ;801
000142  2803              CMP      r0,#3                 ;801
000144  d091              BEQ      |L10.106|
                  |L10.326|
000146  e13e              B        |L10.966|
                  |L10.328|
000148  6a38              LDR      r0,[r7,#0x20]         ;813  ; uip_udp_conn
00014a  8880              LDRH     r0,[r0,#4]            ;813
00014c  2800              CMP      r0,#0                 ;813
00014e  d0b5              BEQ      |L10.188|
000150  6179              STR      r1,[r7,#0x14]         ;815  ; uip_appdata
000152  e9c71606          STRD     r1,r6,[r7,#0x18]      ;815
000156  80fe              STRH     r6,[r7,#6]            ;816
000158  80be              STRH     r6,[r7,#4]            ;816
00015a  2008              MOVS     r0,#8                 ;817
00015c  7038              STRB     r0,[r7,#0]            ;817
00015e  e0af              B        |L10.704|
                  |L10.352|
000160  7c69              LDRB     r1,[r5,#0x11]         ;856  ; uip_buf
000162  7c2a              LDRB     r2,[r5,#0x10]         ;856  ; uip_buf
000164  eb012102          ADD      r1,r1,r2,LSL #8       ;856
000168  88ba              LDRH     r2,[r7,#4]            ;856  ; uip_len
00016a  4291              CMP      r1,r2                 ;856
00016c  d804              BHI      |L10.376|
00016e  80b9              STRH     r1,[r7,#4]            ;857
000170  7d29              LDRB     r1,[r5,#0x14]         ;876  ; uip_buf
000172  0689              LSLS     r1,r1,#26             ;876
000174  d104              BNE      |L10.384|
000176  e001              B        |L10.380|
                  |L10.376|
000178  a0ae              ADR      r0,|L10.1076|
00017a  e269              B        |L10.1616|
                  |L10.380|
00017c  7d69              LDRB     r1,[r5,#0x15]         ;877  ; uip_buf
00017e  b131              CBZ      r1,|L10.398|
                  |L10.384|
000180  8020              STRH     r0,[r4,#0]            ;884
000182  89a0              LDRH     r0,[r4,#0xc]          ;885  ; uip_stat
000184  1c40              ADDS     r0,r0,#1              ;885
000186  f8ab000c          STRH     r0,[r11,#0xc]         ;885
00018a  a0b6              ADR      r0,|L10.1124|
00018c  e260              B        |L10.1616|
                  |L10.398|
00018e  499c              LDR      r1,|L10.1024|
000190  310e              ADDS     r1,r1,#0xe            ;892
000192  880a              LDRH     r2,[r1,#0]            ;892  ; uip_hostaddr
000194  8849              LDRH     r1,[r1,#2]            ;892
000196  b902              CBNZ     r2,|L10.410|
000198  b141              CBZ      r1,|L10.428|
                  |L10.410|
00019a  8beb              LDRH     r3,[r5,#0x1e]         ;921  ; uip_buf
00019c  4293              CMP      r3,r2                 ;921
00019e  d102              BNE      |L10.422|
0001a0  8c2a              LDRH     r2,[r5,#0x20]         ;921  ; uip_buf
0001a2  428a              CMP      r2,r1                 ;921
0001a4  d002              BEQ      |L10.428|
                  |L10.422|
0001a6  f8ab0000          STRH     r0,[r11,#0]           ;922
0001aa  e10c              B        |L10.966|
                  |L10.428|
0001ac  f7fffffe          BL       uip_ipchksum
0001b0  f5a0417f          SUB      r1,r0,#0xff00         ;940
0001b4  39ff              SUBS     r1,r1,#0xff           ;940
0001b6  d007              BEQ      |L10.456|
0001b8  8820              LDRH     r0,[r4,#0]            ;942  ; uip_stat
0001ba  1c40              ADDS     r0,r0,#1              ;942
0001bc  8020              STRH     r0,[r4,#0]            ;942
0001be  89e0              LDRH     r0,[r4,#0xe]          ;943  ; uip_stat
0001c0  1c40              ADDS     r0,r0,#1              ;943
0001c2  81e0              STRH     r0,[r4,#0xe]          ;943
0001c4  a0ad              ADR      r0,|L10.1148|
0001c6  e243              B        |L10.1616|
                  |L10.456|
0001c8  7de8              LDRB     r0,[r5,#0x17]         ;950  ; uip_buf
0001ca  2806              CMP      r0,#6                 ;950
0001cc  d07e              BEQ      |L10.716|
0001ce  2811              CMP      r0,#0x11              ;957
0001d0  d031              BEQ      |L10.566|
0001d2  2801              CMP      r0,#1                 ;964
0001d4  d007              BEQ      |L10.486|
0001d6  8820              LDRH     r0,[r4,#0]            ;966  ; uip_stat
0001d8  1c40              ADDS     r0,r0,#1              ;966
0001da  8020              STRH     r0,[r4,#0]            ;966
0001dc  8a20              LDRH     r0,[r4,#0x10]         ;967  ; uip_stat
0001de  1c40              ADDS     r0,r0,#1              ;967
0001e0  8220              STRH     r0,[r4,#0x10]         ;967
0001e2  a0ab              ADR      r0,|L10.1168|
0001e4  e234              B        |L10.1616|
                  |L10.486|
0001e6  8aa0              LDRH     r0,[r4,#0x14]         ;975  ; uip_stat
0001e8  1c40              ADDS     r0,r0,#1              ;975
0001ea  82a0              STRH     r0,[r4,#0x14]         ;975
0001ec  f8950022          LDRB     r0,[r5,#0x22]         ;980  ; uip_buf
0001f0  2808              CMP      r0,#8                 ;980
0001f2  d007              BEQ      |L10.516|
0001f4  8a60              LDRH     r0,[r4,#0x12]         ;981  ; uip_stat
0001f6  1c40              ADDS     r0,r0,#1              ;981
0001f8  8260              STRH     r0,[r4,#0x12]         ;981
0001fa  8b20              LDRH     r0,[r4,#0x18]         ;982  ; uip_stat
0001fc  1c40              ADDS     r0,r0,#1              ;982
0001fe  8320              STRH     r0,[r4,#0x18]         ;982
000200  a0aa              ADR      r0,|L10.1196|
000202  e225              B        |L10.1616|
                  |L10.516|
000204  f8856022          STRB     r6,[r5,#0x22]         ;997
000208  8ca8              LDRH     r0,[r5,#0x24]         ;999  ; uip_buf
00020a  f64f71f7          MOV      r1,#0xfff7            ;999
00020e  4288              CMP      r0,r1                 ;999
000210  d301              BCC      |L10.534|
000212  3009              ADDS     r0,r0,#9              ;1000
000214  e000              B        |L10.536|
                  |L10.534|
000216  3008              ADDS     r0,r0,#8              ;1002
                  |L10.536|
000218  84a8              STRH     r0,[r5,#0x24]         ;1002
00021a  8b68              LDRH     r0,[r5,#0x1a]         ;1006  ; uip_buf
00021c  83e8              STRH     r0,[r5,#0x1e]         ;1006
00021e  4878              LDR      r0,|L10.1024|
000220  8ba9              LDRH     r1,[r5,#0x1c]         ;1006  ; uip_buf
000222  300e              ADDS     r0,r0,#0xe            ;1007
000224  8429              STRH     r1,[r5,#0x20]         ;1006
000226  8801              LDRH     r1,[r0,#0]            ;1007  ; uip_hostaddr
000228  8369              STRH     r1,[r5,#0x1a]         ;1007
00022a  8840              LDRH     r0,[r0,#2]            ;1007  ; uip_hostaddr
00022c  83a8              STRH     r0,[r5,#0x1c]         ;1007
00022e  8ae0              LDRH     r0,[r4,#0x16]         ;1009  ; uip_stat
000230  1c40              ADDS     r0,r0,#1              ;1009
000232  82e0              STRH     r0,[r4,#0x16]         ;1009
000234  e3f3              B        |L10.2590|
                  |L10.566|
000236  88b8              LDRH     r0,[r7,#4]            ;1090  ; uip_len
000238  381c              SUBS     r0,r0,#0x1c           ;1090
00023a  80b8              STRH     r0,[r7,#4]            ;1090
00023c  f8c78014          STR      r8,[r7,#0x14]         ;1092  ; uip_appdata
000240  8d28              LDRH     r0,[r5,#0x28]         ;1092  ; uip_buf
000242  b168              CBZ      r0,|L10.608|
000244  f7fffffe          BL       uip_udpchksum
000248  f5a0417f          SUB      r1,r0,#0xff00         ;1092
00024c  39ff              SUBS     r1,r1,#0xff           ;1092
00024e  d007              BEQ      |L10.608|
000250  8da0              LDRH     r0,[r4,#0x2c]         ;1093  ; uip_stat
000252  1c40              ADDS     r0,r0,#1              ;1093
000254  85a0              STRH     r0,[r4,#0x2c]         ;1093
000256  8e60              LDRH     r0,[r4,#0x32]         ;1094  ; uip_stat
000258  1c40              ADDS     r0,r0,#1              ;1094
00025a  8660              STRH     r0,[r4,#0x32]         ;1094
00025c  a099              ADR      r0,|L10.1220|
00025e  e1f7              B        |L10.1616|
                  |L10.608|
000260  4869              LDR      r0,|L10.1032|
000262  4969              LDR      r1,|L10.1032|
000264  38f0              SUBS     r0,r0,#0xf0           ;1103
000266  6238              STR      r0,[r7,#0x20]         ;1105  ; uip_udp_conn
000268  e01b              B        |L10.674|
                  |L10.618|
00026a  8882              LDRH     r2,[r0,#4]            ;1113
00026c  b1ba              CBZ      r2,|L10.670|
00026e  8cab              LDRH     r3,[r5,#0x24]         ;1114  ; uip_buf
000270  4293              CMP      r3,r2                 ;1114
000272  d114              BNE      |L10.670|
000274  88c2              LDRH     r2,[r0,#6]            ;1115
000276  b112              CBZ      r2,|L10.638|
000278  8c6b              LDRH     r3,[r5,#0x22]         ;1116  ; uip_buf
00027a  4293              CMP      r3,r2                 ;1116
00027c  d10f              BNE      |L10.670|
                  |L10.638|
00027e  8802              LDRH     r2,[r0,#0]            ;1117
000280  b19a              CBZ      r2,|L10.682|
000282  f64f73ff          MOV      r3,#0xffff            ;1118
000286  429a              CMP      r2,r3                 ;1118
000288  d102              BNE      |L10.656|
00028a  8844              LDRH     r4,[r0,#2]            ;1118
00028c  429c              CMP      r4,r3                 ;1118
00028e  d00f              BEQ      |L10.688|
                  |L10.656|
000290  8b6b              LDRH     r3,[r5,#0x1a]         ;1119  ; uip_buf
000292  4293              CMP      r3,r2                 ;1119
000294  d103              BNE      |L10.670|
000296  8baa              LDRH     r2,[r5,#0x1c]         ;1119  ; uip_buf
000298  8843              LDRH     r3,[r0,#2]            ;1119
00029a  429a              CMP      r2,r3                 ;1119
00029c  d008              BEQ      |L10.688|
                  |L10.670|
00029e  3018              ADDS     r0,r0,#0x18           ;1105
0002a0  6238              STR      r0,[r7,#0x20]         ;1105  ; uip_udp_conn
                  |L10.674|
0002a2  4288              CMP      r0,r1                 ;1104
0002a4  d3e1              BCC      |L10.618|
0002a6  a08c              ADR      r0,|L10.1240|
0002a8  e1d2              B        |L10.1616|
                  |L10.682|
0002aa  8843              LDRH     r3,[r0,#2]            ;1117
0002ac  2b00              CMP      r3,#0                 ;1117
0002ae  d1ef              BNE      |L10.656|
                  |L10.688|
0002b0  2002              MOVS     r0,#2                 ;1128
0002b2  61fe              STR      r6,[r7,#0x1c]         ;1128  ; uip_conn
0002b4  7038              STRB     r0,[r7,#0]            ;1128
0002b6  f8c78014          STR      r8,[r7,#0x14]         ;1129  ; uip_appdata
0002ba  f8c78018          STR      r8,[r7,#0x18]         ;1130  ; uip_sappdata
0002be  80fe              STRH     r6,[r7,#6]            ;1130
                  |L10.704|
0002c0  f7fffffe          BL       udp_demo_appcall
                  |L10.708|
0002c4  88f8              LDRH     r0,[r7,#6]            ;1133  ; uip_slen
0002c6  2800              CMP      r0,#0                 ;1133
0002c8  d07d              BEQ      |L10.966|
0002ca  e000              B        |L10.718|
                  |L10.716|
0002cc  e02f              B        |L10.814|
                  |L10.718|
0002ce  f100011c          ADD      r1,r0,#0x1c           ;1136
0002d2  80b9              STRH     r1,[r7,#4]            ;1136
0002d4  0a0a              LSRS     r2,r1,#8              ;1144
0002d6  742a              STRB     r2,[r5,#0x10]         ;1144
0002d8  7469              STRB     r1,[r5,#0x11]         ;1145
0002da  6a39              LDR      r1,[r7,#0x20]         ;1148  ; uip_udp_conn
0002dc  3008              ADDS     r0,r0,#8              ;1151
0002de  b280              UXTH     r0,r0                 ;1151
0002e0  7a0a              LDRB     r2,[r1,#8]            ;1148
0002e2  75aa              STRB     r2,[r5,#0x16]         ;1148
0002e4  2211              MOVS     r2,#0x11              ;1149
0002e6  75ea              STRB     r2,[r5,#0x17]         ;1149
0002e8  0202              LSLS     r2,r0,#8              ;1151
0002ea  ea422010          ORR      r0,r2,r0,LSR #8       ;1151
0002ee  84e8              STRH     r0,[r5,#0x26]         ;1151
0002f0  852e              STRH     r6,[r5,#0x28]         ;1152
0002f2  8888              LDRH     r0,[r1,#4]            ;1154
0002f4  8468              STRH     r0,[r5,#0x22]         ;1154
0002f6  88c8              LDRH     r0,[r1,#6]            ;1155
0002f8  84a8              STRH     r0,[r5,#0x24]         ;1155
0002fa  4841              LDR      r0,|L10.1024|
0002fc  300e              ADDS     r0,r0,#0xe            ;1157
0002fe  8802              LDRH     r2,[r0,#0]            ;1157  ; uip_hostaddr
000300  836a              STRH     r2,[r5,#0x1a]         ;1157
000302  8840              LDRH     r0,[r0,#2]            ;1157  ; uip_hostaddr
000304  83a8              STRH     r0,[r5,#0x1c]         ;1157
000306  8808              LDRH     r0,[r1,#0]            ;1158
000308  83e8              STRH     r0,[r5,#0x1e]         ;1158
00030a  8848              LDRH     r0,[r1,#2]            ;1158
00030c  8428              STRH     r0,[r5,#0x20]         ;1158
00030e  f8c79014          STR      r9,[r7,#0x14]         ;1164  ; uip_appdata
000312  e001              B        |L10.792|
000314  e2f3              B        |L10.2302|
000316  e1b9              B        |L10.1676|
                  |L10.792|
000318  f7fffffe          BL       uip_udpchksum
00031c  43c0              MVNS     r0,r0                 ;1164
00031e  0400              LSLS     r0,r0,#16             ;1164
000320  0c00              LSRS     r0,r0,#16             ;1164
000322  8528              STRH     r0,[r5,#0x28]         ;1164
000324  d102              BNE      |L10.812|
000326  f64f70ff          MOV      r0,#0xffff            ;1166
00032a  8528              STRH     r0,[r5,#0x28]         ;1166
                  |L10.812|
00032c  e3eb              B        |L10.2822|
                  |L10.814|
00032e  8ba1              LDRH     r1,[r4,#0x1c]         ;1175  ; uip_stat
000330  46a3              MOV      r11,r4                ;1175
000332  1c49              ADDS     r1,r1,#1              ;1175
000334  83a1              STRH     r1,[r4,#0x1c]         ;1175
000336  f7fffffe          BL       uip_tcpchksum
00033a  f5a0417f          SUB      r1,r0,#0xff00         ;1179
00033e  39ff              SUBS     r1,r1,#0xff           ;1179
000340  d00b              BEQ      |L10.858|
000342  f8bb101a          LDRH     r1,[r11,#0x1a]        ;1181  ; uip_stat
000346  a06d              ADR      r0,|L10.1276|
000348  1c49              ADDS     r1,r1,#1              ;1181
00034a  f8ab101a          STRH     r1,[r11,#0x1a]        ;1181
00034e  f8bb1020          LDRH     r1,[r11,#0x20]        ;1182  ; uip_stat
000352  1c49              ADDS     r1,r1,#1              ;1182
000354  f8ab1020          STRH     r1,[r11,#0x20]        ;1182
000358  e17a              B        |L10.1616|
                  |L10.858|
00035a  4c6d              LDR      r4,|L10.1296|
00035c  f8b5c022          LDRH     r12,[r5,#0x22]        ;1116
000360  8b6b              LDRH     r3,[r5,#0x1a]         ;1006
000362  8ba8              LDRH     r0,[r5,#0x1c]         ;1006
000364  f8df81ac          LDR      r8,|L10.1300|
000368  8ca9              LDRH     r1,[r5,#0x24]         ;999
00036a  e00e              B        |L10.906|
                  |L10.876|
00036c  7e62              LDRB     r2,[r4,#0x19]         ;1192
00036e  b15a              CBZ      r2,|L10.904|
000370  88a2              LDRH     r2,[r4,#4]            ;1193
000372  4291              CMP      r1,r2                 ;1193
000374  d108              BNE      |L10.904|
000376  88e2              LDRH     r2,[r4,#6]            ;1194
000378  4594              CMP      r12,r2                ;1194
00037a  d105              BNE      |L10.904|
00037c  8822              LDRH     r2,[r4,#0]            ;1195
00037e  4293              CMP      r3,r2                 ;1195
000380  d102              BNE      |L10.904|
000382  8862              LDRH     r2,[r4,#2]            ;1195
000384  4290              CMP      r0,r2                 ;1195
000386  d038              BEQ      |L10.1018|
                  |L10.904|
000388  3474              ADDS     r4,r4,#0x74           ;1191
                  |L10.906|
00038a  4544              CMP      r4,r8                 ;1190
00038c  d9ee              BLS      |L10.876|
00038e  f895002f          LDRB     r0,[r5,#0x2f]         ;1204  ; uip_buf
000392  f000003f          AND      r0,r0,#0x3f           ;1204
000396  2802              CMP      r0,#2                 ;1204
000398  d118              BNE      |L10.972|
00039a  4b5e              LDR      r3,|L10.1300|
00039c  81b9              STRH     r1,[r7,#0xc]          ;1208
00039e  707e              STRB     r6,[r7,#1]            ;1210
0003a0  3374              ADDS     r3,r3,#0x74           ;1211
0003a2  46b8              MOV      r8,r7                 ;684
                  |L10.932|
0003a4  f8982001          LDRB     r2,[r8,#1]            ;1211  ; c
0003a8  f8330012          LDRH     r0,[r3,r2,LSL #1]     ;1211
0003ac  4288              CMP      r0,r1                 ;1211
0003ae  d025              BEQ      |L10.1020|
0003b0  1c52              ADDS     r2,r2,#1              ;1210
0003b2  b2d0              UXTB     r0,r2                 ;1210
0003b4  f8880001          STRB     r0,[r8,#1]            ;1210
0003b8  2828              CMP      r0,#0x28              ;1210
0003ba  d3f3              BCC      |L10.932|
0003bc  f8bb102a          LDRH     r1,[r11,#0x2a]        ;1216  ; uip_stat
0003c0  f1010101          ADD      r1,r1,#1              ;1216
0003c4  e000              B        |L10.968|
                  |L10.966|
0003c6  e01a              B        |L10.1022|
                  |L10.968|
0003c8  f8ab102a          STRH     r1,[r11,#0x2a]        ;1216
                  |L10.972|
0003cc  f895002f          LDRB     r0,[r5,#0x2f]         ;1220  ; uip_buf
0003d0  0740              LSLS     r0,r0,#29             ;1220
0003d2  d414              BMI      |L10.1022|
0003d4  f8bb1024          LDRH     r1,[r11,#0x24]        ;1224  ; uip_stat
0003d8  f1050526          ADD      r5,r5,#0x26           ;1226
0003dc  1c49              ADDS     r1,r1,#1              ;1224
0003de  f8ab1024          STRH     r1,[r11,#0x24]        ;1224
0003e2  2014              MOVS     r0,#0x14              ;1226
0003e4  7268              STRB     r0,[r5,#9]            ;1226
0003e6  f04f0028          MOV      r0,#0x28              ;1227
0003ea  80b8              STRH     r0,[r7,#4]            ;1227
0003ec  f04f0050          MOV      r0,#0x50              ;1228
0003f0  7228              STRB     r0,[r5,#8]            ;1228
0003f2  78e9              LDRB     r1,[r5,#3]            ;1231  ; uip_buf
0003f4  79e8              LDRB     r0,[r5,#7]            ;1232  ; uip_buf
0003f6  70e8              STRB     r0,[r5,#3]            ;1232
0003f8  e08e              B        |L10.1304|
                  |L10.1018|
0003fa  e171              B        |L10.1760|
                  |L10.1020|
0003fc  e0bf              B        |L10.1406|
                  |L10.1022|
0003fe  e261              B        |L10.2244|
                  |L10.1024|
                          DCD      ||area_number.24||
                  |L10.1028|
                          DCD      ||.bss||
                  |L10.1032|
                          DCD      ||.bss||+0x2364
                  |L10.1036|
00040c  69703a20          DCB      "ip: invalid version or header length.",0
000410  696e7661
000414  6c696420
000418  76657273
00041c  696f6e20
000420  6f722068
000424  65616465
000428  72206c65
00042c  6e677468
000430  2e00    
000432  00                DCB      0
000433  00                DCB      0
                  |L10.1076|
000434  69703a20          DCB      "ip: packet shorter than reported in IP header.",0
000438  7061636b
00043c  65742073
000440  686f7274
000444  65722074
000448  68616e20
00044c  7265706f
000450  72746564
000454  20696e20
000458  49502068
00045c  65616465
000460  722e00  
000463  00                DCB      0
                  |L10.1124|
000464  69703a20          DCB      "ip: fragment dropped.",0
000468  66726167
00046c  6d656e74
000470  2064726f
000474  70706564
000478  2e00    
00047a  00                DCB      0
00047b  00                DCB      0
                  |L10.1148|
00047c  69703a20          DCB      "ip: bad checksum.",0
000480  62616420
000484  63686563
000488  6b73756d
00048c  2e00    
00048e  00                DCB      0
00048f  00                DCB      0
                  |L10.1168|
000490  69703a20          DCB      "ip: neither tcp nor icmp.",0
000494  6e656974
000498  68657220
00049c  74637020
0004a0  6e6f7220
0004a4  69636d70
0004a8  2e00    
0004aa  00                DCB      0
0004ab  00                DCB      0
                  |L10.1196|
0004ac  69636d70          DCB      "icmp: not icmp echo.",0
0004b0  3a206e6f
0004b4  74206963
0004b8  6d702065
0004bc  63686f2e
0004c0  00      
0004c1  00                DCB      0
0004c2  00                DCB      0
0004c3  00                DCB      0
                  |L10.1220|
0004c4  7564703a          DCB      "udp: bad checksum.",0
0004c8  20626164
0004cc  20636865
0004d0  636b7375
0004d4  6d2e00  
0004d7  00                DCB      0
                  |L10.1240|
0004d8  7564703a          DCB      "udp: no matching connection found",0
0004dc  206e6f20
0004e0  6d617463
0004e4  68696e67
0004e8  20636f6e
0004ec  6e656374
0004f0  696f6e20
0004f4  666f756e
0004f8  6400    
0004fa  00                DCB      0
0004fb  00                DCB      0
                  |L10.1276|
0004fc  7463703a          DCB      "tcp: bad checksum.",0
000500  20626164
000504  20636865
000508  636b7375
00050c  6d2e00  
00050f  00                DCB      0
                  |L10.1296|
                          DCD      ||.bss||+0x1004
                  |L10.1300|
                          DCD      ||.bss||+0x21b0
                  |L10.1304|
000518  78aa              LDRB     r2,[r5,#2]            ;1235  ; uip_buf
00051a  79a8              LDRB     r0,[r5,#6]            ;1236  ; uip_buf
00051c  70a8              STRB     r0,[r5,#2]            ;1236
00051e  71aa              STRB     r2,[r5,#6]            ;1237
000520  786c              LDRB     r4,[r5,#1]            ;1239  ; uip_buf
000522  7968              LDRB     r0,[r5,#5]            ;1240  ; uip_buf
000524  7068              STRB     r0,[r5,#1]            ;1240
000526  716c              STRB     r4,[r5,#5]            ;1241
000528  7828              LDRB     r0,[r5,#0]            ;1243  ; uip_buf
00052a  7078              STRB     r0,[r7,#1]            ;1243
00052c  792b              LDRB     r3,[r5,#4]            ;1244  ; uip_buf
00052e  702b              STRB     r3,[r5,#0]            ;1244
000530  f1010101          ADD      r1,r1,#1              ;1250
000534  7128              STRB     r0,[r5,#4]            ;1245
000536  f01101ff          ANDS     r1,r1,#0xff           ;1250
00053a  71e9              STRB     r1,[r5,#7]            ;1250
00053c  f1a50526          SUB      r5,r5,#0x26           ;1250
000540  d10e              BNE      |L10.1376|
000542  1c52              ADDS     r2,r2,#1              ;1251
000544  f01201ff          ANDS     r1,r2,#0xff           ;1251
000548  f885102c          STRB     r1,[r5,#0x2c]         ;1251
00054c  d108              BNE      |L10.1376|
00054e  1c64              ADDS     r4,r4,#1              ;1252
000550  f01401ff          ANDS     r1,r4,#0xff           ;1252
000554  f885102b          STRB     r1,[r5,#0x2b]         ;1252
000558  d102              BNE      |L10.1376|
00055a  1c40              ADDS     r0,r0,#1              ;1253
00055c  f885002a          STRB     r0,[r5,#0x2a]         ;1253
                  |L10.1376|
000560  8c68              LDRH     r0,[r5,#0x22]         ;1259  ; uip_buf
000562  81b8              STRH     r0,[r7,#0xc]          ;1259
000564  8ca9              LDRH     r1,[r5,#0x24]         ;1260  ; uip_buf
000566  8469              STRH     r1,[r5,#0x22]         ;1260
000568  84a8              STRH     r0,[r5,#0x24]         ;1261
00056a  8b68              LDRH     r0,[r5,#0x1a]         ;1264  ; uip_buf
00056c  83e8              STRH     r0,[r5,#0x1e]         ;1264
00056e  8ba9              LDRH     r1,[r5,#0x1c]         ;1264  ; uip_buf
000570  48ff              LDR      r0,|L10.2416|
000572  8429              STRH     r1,[r5,#0x20]         ;1264
000574  8801              LDRH     r1,[r0,#0]            ;1265  ; uip_hostaddr
000576  8369              STRH     r1,[r5,#0x1a]         ;1265
000578  8840              LDRH     r0,[r0,#2]            ;1265  ; uip_hostaddr
00057a  83a8              STRH     r0,[r5,#0x1c]         ;1265
00057c  e2d2              B        |L10.2852|
                  |L10.1406|
00057e  48fd              LDR      r0,|L10.2420|
000580  2400              MOVS     r4,#0                 ;1280
000582  f8886001          STRB     r6,[r8,#1]            ;1281
000586  bf00              NOP                            ;1282
                  |L10.1416|
000588  f8981001          LDRB     r1,[r8,#1]            ;1282  ; c
00058c  eb010241          ADD      r2,r1,r1,LSL #1       ;1282
000590  ebc21241          RSB      r2,r2,r1,LSL #5       ;1282
000594  eb000282          ADD      r2,r0,r2,LSL #2       ;1282
000598  7e53              LDRB     r3,[r2,#0x19]         ;1282
00059a  b113              CBZ      r3,|L10.1442|
00059c  2b07              CMP      r3,#7                 ;1286
00059e  d008              BEQ      |L10.1458|
0005a0  e00e              B        |L10.1472|
                  |L10.1442|
0005a2  b2c9              UXTB     r1,r1                 ;1283
0005a4  eb010241          ADD      r2,r1,r1,LSL #1       ;1283
0005a8  ebc21141          RSB      r1,r2,r1,LSL #5       ;1283
0005ac  eb000481          ADD      r4,r0,r1,LSL #2       ;1283
0005b0  e00c              B        |L10.1484|
                  |L10.1458|
0005b2  b124              CBZ      r4,|L10.1470|
0005b4  7e93              LDRB     r3,[r2,#0x1a]         ;1288
0005b6  f894c01a          LDRB     r12,[r4,#0x1a]        ;1288
0005ba  4563              CMP      r3,r12                ;1288
0005bc  d900              BLS      |L10.1472|
                  |L10.1470|
0005be  4614              MOV      r4,r2                 ;1289
                  |L10.1472|
0005c0  1c49              ADDS     r1,r1,#1              ;1281
0005c2  b2c9              UXTB     r1,r1                 ;1281
0005c4  f8881001          STRB     r1,[r8,#1]            ;1281
0005c8  2928              CMP      r1,#0x28              ;1281
0005ca  d3dd              BCC      |L10.1416|
                  |L10.1484|
0005cc  b3cc              CBZ      r4,|L10.1602|
0005ce  2003              MOVS     r0,#3                 ;1305
0005d0  f8c8401c          STR      r4,[r8,#0x1c]         ;1305  ; uip_conn
0005d4  76a0              STRB     r0,[r4,#0x1a]         ;1305
0005d6  7620              STRB     r0,[r4,#0x18]         ;1305
0005d8  75a6              STRB     r6,[r4,#0x16]         ;1306
0005da  2004              MOVS     r0,#4                 ;1307
0005dc  75e0              STRB     r0,[r4,#0x17]         ;1307
0005de  f105051a          ADD      r5,r5,#0x1a           ;1308
0005e2  76e6              STRB     r6,[r4,#0x1b]         ;1308
0005e4  8968              LDRH     r0,[r5,#0xa]          ;1309  ; uip_buf
0005e6  80a0              STRH     r0,[r4,#4]            ;1309
0005e8  8928              LDRH     r0,[r5,#8]            ;1310  ; uip_buf
0005ea  80e0              STRH     r0,[r4,#6]            ;1310
0005ec  8828              LDRH     r0,[r5,#0]            ;1311  ; uip_buf
0005ee  8020              STRH     r0,[r4,#0]            ;1311
0005f0  8868              LDRH     r0,[r5,#2]            ;1311  ; uip_buf
0005f2  8060              STRH     r0,[r4,#2]            ;1311
0005f4  48de              LDR      r0,|L10.2416|
0005f6  f04f0201          MOV      r2,#1                 ;1312
0005fa  f1000016          ADD      r0,r0,#0x16           ;1314
0005fe  7662              STRB     r2,[r4,#0x19]         ;1312
000600  7801              LDRB     r1,[r0,#0]            ;1314  ; iss
000602  7321              STRB     r1,[r4,#0xc]          ;1314
000604  7841              LDRB     r1,[r0,#1]            ;1315  ; iss
000606  7361              STRB     r1,[r4,#0xd]          ;1315
000608  7881              LDRB     r1,[r0,#2]            ;1316  ; iss
00060a  73a1              STRB     r1,[r4,#0xe]          ;1316
00060c  78c0              LDRB     r0,[r0,#3]            ;1317  ; iss
00060e  73e0              STRB     r0,[r4,#0xf]          ;1317
000610  8222              STRH     r2,[r4,#0x10]         ;1318
000612  7be8              LDRB     r0,[r5,#0xf]          ;1321  ; uip_buf
000614  72e0              STRB     r0,[r4,#0xb]          ;1321
000616  7ba8              LDRB     r0,[r5,#0xe]          ;1322  ; uip_buf
000618  72a0              STRB     r0,[r4,#0xa]          ;1322
00061a  7b68              LDRB     r0,[r5,#0xd]          ;1323  ; uip_buf
00061c  7260              STRB     r0,[r4,#9]            ;1323
00061e  7b28              LDRB     r0,[r5,#0xc]          ;1324  ; uip_buf
000620  7220              STRB     r0,[r4,#8]            ;1324
000622  4610              MOV      r0,r2                 ;1325
000624  f7fffffe          BL       uip_add_rcv_nxt
000628  7d28              LDRB     r0,[r5,#0x14]         ;1328  ; uip_buf
00062a  f1a5051a          SUB      r5,r5,#0x1a           ;1328
00062e  f00001f0          AND      r1,r0,#0xf0           ;1328
000632  2950              CMP      r1,#0x50              ;1328
000634  d92a              BLS      |L10.1676|
000636  0900              LSRS     r0,r0,#4              ;1329
000638  0081              LSLS     r1,r0,#2              ;1329
00063a  f8886001          STRB     r6,[r8,#1]            ;1329
00063e  3914              SUBS     r1,r1,#0x14           ;1329
000640  e020              B        |L10.1668|
                  |L10.1602|
000642  e7ff              B        |L10.1604|
                  |L10.1604|
000644  f8bb1028          LDRH     r1,[r11,#0x28]        ;1298  ; uip_stat
000648  a0cb              ADR      r0,|L10.2424|
00064a  1c49              ADDS     r1,r1,#1              ;1298
00064c  f8ab1028          STRH     r1,[r11,#0x28]        ;1298
                  |L10.1616|
000650  f7fffffe          BL       uip_log
000654  e25e              B        |L10.2836|
                  |L10.1622|
000656  182b              ADDS     r3,r5,r0              ;1330
000658  f8932036          LDRB     r2,[r3,#0x36]         ;1330
00065c  f8882002          STRB     r2,[r8,#2]            ;1330
000660  b1a2              CBZ      r2,|L10.1676|
000662  2a01              CMP      r2,#1                 ;1334
000664  d002              BEQ      |L10.1644|
000666  2a02              CMP      r2,#2                 ;1337
000668  d002              BEQ      |L10.1648|
00066a  e005              B        |L10.1656|
                  |L10.1644|
00066c  1c40              ADDS     r0,r0,#1              ;1335
00066e  e007              B        |L10.1664|
                  |L10.1648|
000670  f8932037          LDRB     r2,[r3,#0x37]         ;1338
000674  2a04              CMP      r2,#4                 ;1338
000676  d025              BEQ      |L10.1732|
                  |L10.1656|
000678  f8932037          LDRB     r2,[r3,#0x37]         ;1350
00067c  b132              CBZ      r2,|L10.1676|
00067e  4410              ADD      r0,r0,r2              ;1355
                  |L10.1664|
000680  f8880001          STRB     r0,[r8,#1]            ;1355
                  |L10.1668|
000684  f8980001          LDRB     r0,[r8,#1]            ;1329  ; c
000688  4281              CMP      r1,r0                 ;1329
00068a  dce4              BGT      |L10.1622|
                  |L10.1676|
00068c  f885a02f          STRB     r10,[r5,#0x2f]
                  |L10.1680|
000690  f105052e          ADD      r5,r5,#0x2e
;;;1364   
;;;1365    tcp_send_syn:
;;;1366     BUF->flags |= TCP_SYN;
;;;1367   #else /* UIP_ACTIVE_OPEN */
;;;1368    tcp_send_synack:
;;;1369     BUF->flags = TCP_SYN | TCP_ACK;
;;;1370   #endif /* UIP_ACTIVE_OPEN */
;;;1371   
;;;1372     /* We send out the TCP Maximum Segment Size option with our
;;;1373        SYNACK. */
;;;1374     BUF->optdata[0] = TCP_OPT_MSS;
000694  f04f0002          MOV      r0,#2
000698  7869              LDRB     r1,[r5,#1]            ;1366  ; uip_buf
00069a  f0410102          ORR      r1,r1,#2              ;1366
00069e  7069              STRB     r1,[r5,#1]            ;1366
0006a0  7228              STRB     r0,[r5,#8]
;;;1375     BUF->optdata[1] = TCP_OPT_MSS_LEN;
0006a2  f04f0004          MOV      r0,#4
0006a6  7268              STRB     r0,[r5,#9]
;;;1376     BUF->optdata[2] = (UIP_TCP_MSS) / 256;
0006a8  f04f000f          MOV      r0,#0xf
0006ac  72a8              STRB     r0,[r5,#0xa]
;;;1377     BUF->optdata[3] = (UIP_TCP_MSS) & 255;
0006ae  f04f00ca          MOV      r0,#0xca
0006b2  72e8              STRB     r0,[r5,#0xb]
;;;1378     uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
0006b4  f04f002c          MOV      r0,#0x2c
0006b8  80b8              STRH     r0,[r7,#4]
;;;1379     BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
0006ba  f04f0060          MOV      r0,#0x60
0006be  f805092e          STRB     r0,[r5],#-0x2e
;;;1380     goto tcp_send;
0006c2  e1f3              B        |L10.2732|
                  |L10.1732|
0006c4  b2c0              UXTB     r0,r0                 ;1340
0006c6  4428              ADD      r0,r0,r5              ;1340
0006c8  f64071ca          MOV      r1,#0xfca             ;1343
0006cc  8f00              LDRH     r0,[r0,#0x38]         ;1340
0006ce  ba40              REV16    r0,r0                 ;1340
0006d0  f8a8000c          STRH     r0,[r8,#0xc]          ;1340
0006d4  4288              CMP      r0,r1                 ;1343
0006d6  d800              BHI      |L10.1754|
0006d8  4601              MOV      r1,r0                 ;1343
                  |L10.1754|
0006da  8261              STRH     r1,[r4,#0x12]         ;1343
0006dc  82a1              STRH     r1,[r4,#0x14]         ;1343
0006de  e7d5              B        |L10.1676|
                  |L10.1760|
;;;1381   
;;;1382     /* This label will be jumped to if we found an active connection. */
;;;1383    found:
;;;1384     uip_conn = uip_connr;
;;;1385     uip_flags = 0;
0006e0  61fc              STR      r4,[r7,#0x1c]  ; uip_conn
0006e2  703e              STRB     r6,[r7,#0]
;;;1386     /* We do a very naive form of TCP reset processing; we just accept
;;;1387        any RST and kill our connection. We should in fact check if the
;;;1388        sequence number of this reset is wihtin our advertised window
;;;1389        before we accept the reset. */
;;;1390     if(BUF->flags & TCP_RST) {
0006e4  f895302f          LDRB     r3,[r5,#0x2f]  ; uip_buf
0006e8  0758              LSLS     r0,r3,#29
0006ea  d506              BPL      |L10.1786|
;;;1391       uip_connr->tcpstateflags = UIP_CLOSED;
0006ec  7666              STRB     r6,[r4,#0x19]
;;;1392       UIP_LOG("tcp: got reset, aborting connection.");
0006ee  a0ab              ADR      r0,|L10.2460|
0006f0  f7fffffe          BL       uip_log
;;;1393       uip_flags = UIP_ABORT;
0006f4  2020              MOVS     r0,#0x20
0006f6  7038              STRB     r0,[r7,#0]
;;;1394       UIP_APPCALL();
;;;1395       goto drop;
0006f8  e1a0              B        |L10.2620|
                  |L10.1786|
;;;1396     }
;;;1397     /* Calculated the length of the data, if the application has sent
;;;1398        any data to us. */
;;;1399     c = (BUF->tcpoffset >> 4) << 2;
0006fa  f895002e          LDRB     r0,[r5,#0x2e]  ; uip_buf
0006fe  46a9              MOV      r9,r5
000700  0900              LSRS     r0,r0,#4
000702  0080              LSLS     r0,r0,#2
000704  7078              STRB     r0,[r7,#1]
;;;1400     /* uip_len will contain the length of the actual TCP data. This is
;;;1401        calculated by subtracing the length of the TCP header (in
;;;1402        c) and the length of the IP header (20 bytes). */
;;;1403     uip_len = uip_len - c - UIP_IPH_LEN;
000706  88b9              LDRH     r1,[r7,#4]  ; uip_len
000708  1a08              SUBS     r0,r1,r0
00070a  3814              SUBS     r0,r0,#0x14
00070c  b280              UXTH     r0,r0
00070e  80b8              STRH     r0,[r7,#4]
;;;1404   
;;;1405     /* First, check if the sequence number of the incoming packet is
;;;1406        what we're expecting next. If not, we send out an ACK with the
;;;1407        correct numbers in. */
;;;1408     if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
000710  7e61              LDRB     r1,[r4,#0x19]
000712  f001010f          AND      r1,r1,#0xf
000716  2902              CMP      r1,#2
000718  d103              BNE      |L10.1826|
00071a  f003013f          AND      r1,r3,#0x3f
00071e  2912              CMP      r1,#0x12
000720  d017              BEQ      |L10.1874|
                  |L10.1826|
;;;1409          ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
;;;1410       if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
000722  b908              CBNZ     r0,|L10.1832|
000724  0798              LSLS     r0,r3,#30
000726  d014              BEQ      |L10.1874|
                  |L10.1832|
;;;1411          (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
000728  f8990026          LDRB     r0,[r9,#0x26]  ; uip_buf
00072c  7a21              LDRB     r1,[r4,#8]
00072e  464a              MOV      r2,r9
000730  4288              CMP      r0,r1
                  |L10.1842|
000732  d17e              BNE      |L10.2098|
;;;1412   	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
000734  f8920027          LDRB     r0,[r2,#0x27]  ; uip_buf
000738  7a61              LDRB     r1,[r4,#9]
00073a  4288              CMP      r0,r1
00073c  d1f9              BNE      |L10.1842|
;;;1413   	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
00073e  f8920028          LDRB     r0,[r2,#0x28]  ; uip_buf
000742  7aa1              LDRB     r1,[r4,#0xa]
000744  4288              CMP      r0,r1
000746  d1f4              BNE      |L10.1842|
;;;1414   	BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
000748  f8990029          LDRB     r0,[r9,#0x29]  ; uip_buf
00074c  7ae1              LDRB     r1,[r4,#0xb]
00074e  4288              CMP      r0,r1
000750  d1ef              BNE      |L10.1842|
                  |L10.1874|
;;;1415         goto tcp_send_ack;
;;;1416       }
;;;1417     }
;;;1418   
;;;1419     /* Next, check if the incoming segment acknowledges any outstanding
;;;1420        data. If so, we update the sequence number, reset the length of
;;;1421        the outstanding data, calculate RTT estimations, and reset the
;;;1422        retransmission timer. */
;;;1423     if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
000752  06d8              LSLS     r0,r3,#27
000754  d53f              BPL      |L10.2006|
000756  8a21              LDRH     r1,[r4,#0x10]
000758  b3e9              CBZ      r1,|L10.2006|
;;;1424       uip_add32(uip_connr->snd_nxt, uip_connr->len);
00075a  f104000c          ADD      r0,r4,#0xc
00075e  f7fffffe          BL       uip_add32
;;;1425   
;;;1426       if(BUF->ackno[0] == uip_acc32[0] &&
000762  4883              LDR      r0,|L10.2416|
000764  f899102a          LDRB     r1,[r9,#0x2a]  ; uip_buf
000768  301a              ADDS     r0,r0,#0x1a
00076a  46c8              MOV      r8,r9
00076c  7802              LDRB     r2,[r0,#0]  ; uip_acc32
00076e  4291              CMP      r1,r2
000770  d131              BNE      |L10.2006|
;;;1427          BUF->ackno[1] == uip_acc32[1] &&
000772  f898102b          LDRB     r1,[r8,#0x2b]  ; uip_buf
000776  7843              LDRB     r3,[r0,#1]  ; uip_acc32
000778  4299              CMP      r1,r3
00077a  d12c              BNE      |L10.2006|
;;;1428          BUF->ackno[2] == uip_acc32[2] &&
00077c  f898102c          LDRB     r1,[r8,#0x2c]  ; uip_buf
000780  f890c002          LDRB     r12,[r0,#2]  ; uip_acc32
000784  4561              CMP      r1,r12
000786  d126              BNE      |L10.2006|
;;;1429          BUF->ackno[3] == uip_acc32[3]) {
000788  f899102d          LDRB     r1,[r9,#0x2d]  ; uip_buf
00078c  78c0              LDRB     r0,[r0,#3]  ; uip_acc32
00078e  4281              CMP      r1,r0
000790  d121              BNE      |L10.2006|
;;;1430         /* Update sequence number. */
;;;1431         uip_connr->snd_nxt[0] = uip_acc32[0];
000792  7322              STRB     r2,[r4,#0xc]
;;;1432         uip_connr->snd_nxt[1] = uip_acc32[1];
000794  7363              STRB     r3,[r4,#0xd]
;;;1433         uip_connr->snd_nxt[2] = uip_acc32[2];
000796  f884c00e          STRB     r12,[r4,#0xe]
;;;1434         uip_connr->snd_nxt[3] = uip_acc32[3];
00079a  73e0              STRB     r0,[r4,#0xf]
;;;1435   
;;;1436   
;;;1437         /* Do RTT estimation, unless we have done retransmissions. */
;;;1438         if(uip_connr->nrtx == 0) {
00079c  7ee0              LDRB     r0,[r4,#0x1b]
00079e  b9a8              CBNZ     r0,|L10.1996|
;;;1439   	signed char m;
;;;1440   	m = uip_connr->rto - uip_connr->timer;
0007a0  7e20              LDRB     r0,[r4,#0x18]
0007a2  7ea2              LDRB     r2,[r4,#0x1a]
;;;1441   	/* This is taken directly from VJs original code in his paper */
;;;1442   	m = m - (uip_connr->sa >> 3);
0007a4  7da1              LDRB     r1,[r4,#0x16]
0007a6  1a80              SUBS     r0,r0,r2              ;1440
0007a8  eba000d1          SUB      r0,r0,r1,LSR #3
0007ac  b240              SXTB     r0,r0
;;;1443   	uip_connr->sa += m;
0007ae  4401              ADD      r1,r1,r0
0007b0  b2ca              UXTB     r2,r1
0007b2  75a2              STRB     r2,[r4,#0x16]
;;;1444   	if(m < 0) {
0007b4  2800              CMP      r0,#0
0007b6  da01              BGE      |L10.1980|
;;;1445   	  m = -m;
0007b8  4240              RSBS     r0,r0,#0
0007ba  b240              SXTB     r0,r0
                  |L10.1980|
;;;1446   	}
;;;1447   	m = m - (uip_connr->sv >> 2);
0007bc  7de1              LDRB     r1,[r4,#0x17]
0007be  eba00091          SUB      r0,r0,r1,LSR #2
;;;1448   	uip_connr->sv += m;
0007c2  4408              ADD      r0,r0,r1
0007c4  75e0              STRB     r0,[r4,#0x17]
;;;1449   	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
0007c6  eb0000d2          ADD      r0,r0,r2,LSR #3
0007ca  7620              STRB     r0,[r4,#0x18]
                  |L10.1996|
;;;1450   
;;;1451         }
;;;1452         /* Set the acknowledged flag. */
;;;1453         uip_flags = UIP_ACKDATA;
0007cc  2001              MOVS     r0,#1
0007ce  7038              STRB     r0,[r7,#0]
;;;1454         /* Reset the retransmission timer. */
;;;1455         uip_connr->timer = uip_connr->rto;
0007d0  7e20              LDRB     r0,[r4,#0x18]
0007d2  76a0              STRB     r0,[r4,#0x1a]
;;;1456   
;;;1457         /* Reset length of outstanding data. */
;;;1458         uip_connr->len = 0;
0007d4  8226              STRH     r6,[r4,#0x10]
                  |L10.2006|
;;;1459       }
;;;1460   
;;;1461     }
;;;1462   
;;;1463     /* Do different things depending on in what state the connection is. */
;;;1464     switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
0007d6  7e61              LDRB     r1,[r4,#0x19]
0007d8  f04f0807          MOV      r8,#7                 ;697
0007dc  f001000f          AND      r0,r1,#0xf
0007e0  2809              CMP      r0,#9
0007e2  d26f              BCS      |L10.2244|
0007e4  e8dff000          TBB      [pc,r0]
0007e8  6e05146f          DCB      0x6e,0x05,0x14,0x6f
0007ec  f1f0ef25          DCB      0xf1,0xf0,0xef,0x25
0007f0  ee00              DCB      0xee,0x00
;;;1465       /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
;;;1466   	implemented, since we force the application to close when the
;;;1467   	peer sends a FIN (hence the application goes directly from
;;;1468   	ESTABLISHED to LAST_ACK). */
;;;1469     case UIP_SYN_RCVD:
;;;1470       /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
;;;1471          we are waiting for an ACK that acknowledges the data we sent
;;;1472          out the last time. Therefore, we want to have the UIP_ACKDATA
;;;1473          flag set. If so, we enter the ESTABLISHED state. */
;;;1474       if(uip_flags & UIP_ACKDATA) {
0007f2  7838              LDRB     r0,[r7,#0]  ; uip_flags
0007f4  07c0              LSLS     r0,r0,#31
0007f6  d065              BEQ      |L10.2244|
;;;1475         uip_connr->tcpstateflags = UIP_ESTABLISHED;
0007f8  2003              MOVS     r0,#3
0007fa  7660              STRB     r0,[r4,#0x19]
;;;1476         uip_flags = UIP_CONNECTED;
0007fc  2040              MOVS     r0,#0x40
0007fe  7038              STRB     r0,[r7,#0]
;;;1477         uip_connr->len = 0;
000800  8226              STRH     r6,[r4,#0x10]
;;;1478         if(uip_len > 0) {
000802  88b8              LDRH     r0,[r7,#4]  ; uip_len
000804  b370              CBZ      r0,|L10.2148|
;;;1479           uip_flags |= UIP_NEWDATA;
000806  2142              MOVS     r1,#0x42
000808  7039              STRB     r1,[r7,#0]
;;;1480           uip_add_rcv_nxt(uip_len);
00080a  f7fffffe          BL       uip_add_rcv_nxt
00080e  e0a5              B        |L10.2396|
;;;1481         }
;;;1482         uip_slen = 0;
;;;1483         UIP_APPCALL();
;;;1484         goto appsend;
;;;1485       }
;;;1486       goto drop;
;;;1487   #if UIP_ACTIVE_OPEN
;;;1488     case UIP_SYN_SENT:
;;;1489       /* In SYN_SENT, we wait for a SYNACK that is sent in response to
;;;1490          our SYN. The rcv_nxt is set to sequence number in the SYNACK
;;;1491          plus one, and we send an ACK. We move into the ESTABLISHED
;;;1492          state. */
;;;1493       if((uip_flags & UIP_ACKDATA) &&
000810  7838              LDRB     r0,[r7,#0]  ; uip_flags
000812  07c0              LSLS     r0,r0,#31
000814  d006              BEQ      |L10.2084|
;;;1494          (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
000816  f899102f          LDRB     r1,[r9,#0x2f]  ; uip_buf
00081a  4648              MOV      r0,r9
00081c  f001013f          AND      r1,r1,#0x3f
000820  2912              CMP      r1,#0x12
000822  d007              BEQ      |L10.2100|
                  |L10.2084|
;;;1495   
;;;1496         /* Parse the TCP MSS option, if present. */
;;;1497         if((BUF->tcpoffset & 0xf0) > 0x50) {
;;;1498   	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
;;;1499   	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
;;;1500   	  if(opt == TCP_OPT_END) {
;;;1501   	    /* End of options. */
;;;1502   	    break;
;;;1503   	  } else if(opt == TCP_OPT_NOOP) {
;;;1504   	    ++c;
;;;1505   	    /* NOP option. */
;;;1506   	  } else if(opt == TCP_OPT_MSS &&
;;;1507   		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
;;;1508   	    /* An MSS option with the right option length. */
;;;1509   	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
;;;1510   	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
;;;1511   	    uip_connr->initialmss =
;;;1512   	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
;;;1513   
;;;1514   	    /* And we are done processing options. */
;;;1515   	    break;
;;;1516   	  } else {
;;;1517   	    /* All other options have a length field, so that we easily
;;;1518   	       can skip past them. */
;;;1519   	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
;;;1520   	      /* If the length field is zero, the options are malformed
;;;1521   		 and we don't process them further. */
;;;1522   	      break;
;;;1523   	    }
;;;1524   	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
;;;1525   	  }
;;;1526   	}
;;;1527         }
;;;1528         uip_connr->tcpstateflags = UIP_ESTABLISHED;
;;;1529         uip_connr->rcv_nxt[0] = BUF->seqno[0];
;;;1530         uip_connr->rcv_nxt[1] = BUF->seqno[1];
;;;1531         uip_connr->rcv_nxt[2] = BUF->seqno[2];
;;;1532         uip_connr->rcv_nxt[3] = BUF->seqno[3];
;;;1533         uip_add_rcv_nxt(1);
;;;1534         uip_flags = UIP_CONNECTED | UIP_NEWDATA;
;;;1535         uip_connr->len = 0;
;;;1536         uip_len = 0;
;;;1537         uip_slen = 0;
;;;1538         UIP_APPCALL();
;;;1539         goto appsend;
;;;1540       }
;;;1541       /* Inform the application that the connection failed */
;;;1542       uip_flags = UIP_ABORT;
000824  2020              MOVS     r0,#0x20
000826  7038              STRB     r0,[r7,#0]
;;;1543       UIP_APPCALL();
000828  f7fffffe          BL       hello_world_appcall
;;;1544       /* The connection is closed after we send the RST */
;;;1545       uip_conn->tcpstateflags = UIP_CLOSED;
00082c  69f8              LDR      r0,[r7,#0x1c]  ; uip_conn
00082e  7646              STRB     r6,[r0,#0x19]
;;;1546       goto reset;
000830  e5cc              B        |L10.972|
                  |L10.2098|
000832  e134              B        |L10.2718|
                  |L10.2100|
000834  f890102e          LDRB     r1,[r0,#0x2e]         ;1497  ; uip_buf
000838  f00102f0          AND      r2,r1,#0xf0           ;1497
00083c  2a50              CMP      r2,#0x50              ;1497
00083e  d920              BLS      |L10.2178|
000840  0909              LSRS     r1,r1,#4              ;1329
000842  008a              LSLS     r2,r1,#2              ;1329
000844  707e              STRB     r6,[r7,#1]            ;1498
000846  3a14              SUBS     r2,r2,#0x14           ;1329
000848  e018              B        |L10.2172|
00084a  bf00              NOP                            ;1499
                  |L10.2124|
00084c  eb000c01          ADD      r12,r0,r1             ;1499
000850  f89c3036          LDRB     r3,[r12,#0x36]        ;1499
000854  70bb              STRB     r3,[r7,#2]            ;1499
000856  b1a3              CBZ      r3,|L10.2178|
000858  2b01              CMP      r3,#1                 ;1503
00085a  d004              BEQ      |L10.2150|
00085c  2b02              CMP      r3,#2                 ;1506
00085e  d004              BEQ      |L10.2154|
000860  e007              B        |L10.2162|
                  |L10.2146|
000862  e07c              B        |L10.2398|
                  |L10.2148|
000864  e07a              B        |L10.2396|
                  |L10.2150|
000866  1c49              ADDS     r1,r1,#1              ;1504
000868  e007              B        |L10.2170|
                  |L10.2154|
00086a  f89c3037          LDRB     r3,[r12,#0x37]        ;1507
00086e  2b04              CMP      r3,#4                 ;1507
000870  d01b              BEQ      |L10.2218|
                  |L10.2162|
000872  f89c3037          LDRB     r3,[r12,#0x37]        ;1519
000876  b123              CBZ      r3,|L10.2178|
000878  4419              ADD      r1,r1,r3              ;1524
                  |L10.2170|
00087a  7079              STRB     r1,[r7,#1]            ;1524
                  |L10.2172|
00087c  7879              LDRB     r1,[r7,#1]            ;1498  ; c
00087e  428a              CMP      r2,r1                 ;1498
000880  dce4              BGT      |L10.2124|
                  |L10.2178|
000882  2103              MOVS     r1,#3                 ;1528
000884  7661              STRB     r1,[r4,#0x19]         ;1528
000886  f8101f26          LDRB     r1,[r0,#0x26]!        ;1529  ; uip_buf
00088a  7221              STRB     r1,[r4,#8]            ;1529
00088c  7841              LDRB     r1,[r0,#1]            ;1530  ; uip_buf
00088e  7261              STRB     r1,[r4,#9]            ;1530
000890  7881              LDRB     r1,[r0,#2]            ;1531  ; uip_buf
000892  72a1              STRB     r1,[r4,#0xa]          ;1531
000894  f8990029          LDRB     r0,[r9,#0x29]         ;1532  ; uip_buf
000898  72e0              STRB     r0,[r4,#0xb]          ;1532
00089a  2001              MOVS     r0,#1                 ;1533
00089c  f7fffffe          BL       uip_add_rcv_nxt
0008a0  2042              MOVS     r0,#0x42              ;1534
0008a2  7038              STRB     r0,[r7,#0]            ;1534
0008a4  8226              STRH     r6,[r4,#0x10]         ;1535
0008a6  80be              STRH     r6,[r7,#4]            ;1536
0008a8  e058              B        |L10.2396|
                  |L10.2218|
0008aa  b2c9              UXTB     r1,r1                 ;1509
0008ac  4401              ADD      r1,r1,r0              ;1509
0008ae  f64072ca          MOV      r2,#0xfca             ;1512
0008b2  8f09              LDRH     r1,[r1,#0x38]         ;1509
0008b4  ba49              REV16    r1,r1                 ;1509
0008b6  81b9              STRH     r1,[r7,#0xc]          ;1509
0008b8  4291              CMP      r1,r2                 ;1512
0008ba  d800              BHI      |L10.2238|
0008bc  460a              MOV      r2,r1                 ;1512
                  |L10.2238|
0008be  8262              STRH     r2,[r4,#0x12]         ;1512
0008c0  82a2              STRH     r2,[r4,#0x14]         ;1512
0008c2  e7de              B        |L10.2178|
                  |L10.2244|
0008c4  e035              B        |L10.2354|
;;;1547   #endif /* UIP_ACTIVE_OPEN */
;;;1548   
;;;1549     case UIP_ESTABLISHED:
;;;1550       /* In the ESTABLISHED state, we call upon the application to feed
;;;1551       data into the uip_buf. If the UIP_ACKDATA flag is set, the
;;;1552       application should put new data into the buffer, otherwise we are
;;;1553       retransmitting an old segment, and the application should put that
;;;1554       data into the buffer.
;;;1555   
;;;1556       If the incoming packet is a FIN, we should close the connection on
;;;1557       this side as well, and we send out a FIN and enter the LAST_ACK
;;;1558       state. We require that there is no outstanding data; otherwise the
;;;1559       sequence numbers will be screwed up. */
;;;1560   
;;;1561       if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
0008c6  f899002f          LDRB     r0,[r9,#0x2f]  ; uip_buf
0008ca  07c2              LSLS     r2,r0,#31
0008cc  d019              BEQ      |L10.2306|
0008ce  06ca              LSLS     r2,r1,#27
0008d0  d417              BMI      |L10.2306|
;;;1562         if(uip_outstanding(uip_connr)) {
0008d2  8a20              LDRH     r0,[r4,#0x10]
0008d4  bb68              CBNZ     r0,|L10.2354|
;;;1563   	goto drop;
;;;1564         }
;;;1565         uip_add_rcv_nxt(1 + uip_len);
0008d6  88b8              LDRH     r0,[r7,#4]  ; uip_len
0008d8  1c40              ADDS     r0,r0,#1
0008da  b280              UXTH     r0,r0
0008dc  f7fffffe          BL       uip_add_rcv_nxt
;;;1566         uip_flags |= UIP_CLOSE;
0008e0  7838              LDRB     r0,[r7,#0]  ; uip_flags
0008e2  f0400010          ORR      r0,r0,#0x10
0008e6  7038              STRB     r0,[r7,#0]
;;;1567         if(uip_len > 0) {
0008e8  88b9              LDRH     r1,[r7,#4]  ; uip_len
0008ea  b111              CBZ      r1,|L10.2290|
;;;1568   	uip_flags |= UIP_NEWDATA;
0008ec  f0400002          ORR      r0,r0,#2
0008f0  7038              STRB     r0,[r7,#0]
                  |L10.2290|
;;;1569         }
;;;1570         UIP_APPCALL();
0008f2  f7fffffe          BL       hello_world_appcall
;;;1571         uip_connr->len = 1;
0008f6  2001              MOVS     r0,#1
0008f8  8220              STRH     r0,[r4,#0x10]
;;;1572         uip_connr->tcpstateflags = UIP_LAST_ACK;
0008fa  2008              MOVS     r0,#8
;;;1573         uip_connr->nrtx = 0;
;;;1574       tcp_send_finack:
0008fc  e06f              B        |L10.2526|
                  |L10.2302|
;;;1575         BUF->flags = TCP_FIN | TCP_ACK;
0008fe  2011              MOVS     r0,#0x11
;;;1576         goto tcp_send_nodata;
000900  e035              B        |L10.2414|
                  |L10.2306|
;;;1577       }
;;;1578   
;;;1579       /* Check the URG flag. If this is set, the segment carries urgent
;;;1580          data that we must pass to the application. */
;;;1581       if((BUF->flags & TCP_URG) != 0) {
000902  0680              LSLS     r0,r0,#26
000904  d50a              BPL      |L10.2332|
;;;1582   #if UIP_URGDATA > 0
;;;1583         uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
;;;1584         if(uip_urglen > uip_len) {
;;;1585   	/* There is more urgent data in the next segment to come. */
;;;1586   	uip_urglen = uip_len;
;;;1587         }
;;;1588         uip_add_rcv_nxt(uip_urglen);
;;;1589         uip_len -= uip_urglen;
;;;1590         uip_urgdata = uip_appdata;
;;;1591         uip_appdata += uip_urglen;
;;;1592       } else {
;;;1593         uip_urglen = 0;
;;;1594   #else /* UIP_URGDATA > 0 */
;;;1595         uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
000906  f8b93034          LDRH     r3,[r9,#0x34]  ; uip_buf
00090a  697a              LDR      r2,[r7,#0x14]  ; uip_appdata
00090c  ba58              REV16    r0,r3
00090e  4410              ADD      r0,r0,r2
;;;1596         uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
000910  6178              STR      r0,[r7,#0x14]  ; uip_appdata
000912  88ba              LDRH     r2,[r7,#4]  ; uip_len
000914  ba58              REV16    r0,r3
000916  eba20000          SUB      r0,r2,r0
00091a  80b8              STRH     r0,[r7,#4]
                  |L10.2332|
;;;1597   #endif /* UIP_URGDATA > 0 */
;;;1598       }
;;;1599   
;;;1600       /* If uip_len > 0 we have TCP data in the packet, and we flag this
;;;1601          by setting the UIP_NEWDATA flag and update the sequence number
;;;1602          we acknowledge. If the application has stopped the dataflow
;;;1603          using uip_stop(), we must not accept any data packets from the
;;;1604          remote host. */
;;;1605       if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
00091c  88b8              LDRH     r0,[r7,#4]  ; uip_len
00091e  b158              CBZ      r0,|L10.2360|
000920  06c9              LSLS     r1,r1,#27
000922  d409              BMI      |L10.2360|
;;;1606         uip_flags |= UIP_NEWDATA;
000924  7839              LDRB     r1,[r7,#0]  ; uip_flags
000926  f0410102          ORR      r1,r1,#2
00092a  7039              STRB     r1,[r7,#0]
;;;1607         uip_add_rcv_nxt(uip_len);
00092c  e002              B        |L10.2356|
                  |L10.2350|
00092e  e01d              B        |L10.2412|
                  |L10.2352|
000930  e062              B        |L10.2552|
                  |L10.2354|
000932  e085              B        |L10.2624|
                  |L10.2356|
000934  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.2360|
;;;1608       }
;;;1609   
;;;1610       /* Check if the available buffer space advertised by the other end
;;;1611          is smaller than the initial MSS for this connection. If so, we
;;;1612          set the current MSS to the window size to ensure that the
;;;1613          application does not send more data than the other end can
;;;1614          handle.
;;;1615   
;;;1616          If the remote host advertises a zero window, we set the MSS to
;;;1617          the initial MSS so that the application will send an entire MSS
;;;1618          of data. This data will not be acknowledged by the receiver,
;;;1619          and the application will retransmit it. This is called the
;;;1620          "persistent timer" and uses the retransmission mechanim.
;;;1621       */
;;;1622       tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
000938  f8990031          LDRB     r0,[r9,#0x31]  ; uip_buf
00093c  f8991030          LDRB     r1,[r9,#0x30]  ; uip_buf
000940  eb002001          ADD      r0,r0,r1,LSL #8
000944  b280              UXTH     r0,r0
000946  81b8              STRH     r0,[r7,#0xc]
;;;1623       if(tmp16 > uip_connr->initialmss ||
000948  8aa1              LDRH     r1,[r4,#0x14]
00094a  4281              CMP      r1,r0
00094c  d300              BCC      |L10.2384|
;;;1624          tmp16 == 0) {
00094e  b900              CBNZ     r0,|L10.2386|
                  |L10.2384|
;;;1625         tmp16 = uip_connr->initialmss;
000950  81b9              STRH     r1,[r7,#0xc]
                  |L10.2386|
;;;1626       }
;;;1627       uip_connr->mss = tmp16;
000952  89b8              LDRH     r0,[r7,#0xc]  ; tmp16
000954  8260              STRH     r0,[r4,#0x12]
;;;1628   
;;;1629       /* If this packet constitutes an ACK for outstanding data (flagged
;;;1630          by the UIP_ACKDATA flag, we should call the application since it
;;;1631          might want to send more data. If the incoming packet had data
;;;1632          from the peer (as flagged by the UIP_NEWDATA flag), the
;;;1633          application must also be notified.
;;;1634   
;;;1635          When the application is called, the global variable uip_len
;;;1636          contains the length of the incoming data. The application can
;;;1637          access the incoming data through the global pointer
;;;1638          uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
;;;1639          bytes into the uip_buf array.
;;;1640   
;;;1641          If the application wishes to send any data, this data should be
;;;1642          put into the uip_appdata and the length of the data should be
;;;1643          put into uip_len. If the application don't have any data to
;;;1644          send, uip_len must be set to 0. */
;;;1645       if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
000956  7838              LDRB     r0,[r7,#0]  ; uip_flags
000958  0780              LSLS     r0,r0,#30
00095a  d071              BEQ      |L10.2624|
                  |L10.2396|
;;;1646         uip_slen = 0;
00095c  80fe              STRH     r6,[r7,#6]
                  |L10.2398|
;;;1647         UIP_APPCALL();
00095e  f7fffffe          BL       hello_world_appcall
;;;1648   
;;;1649       appsend:
;;;1650   
;;;1651         if(uip_flags & UIP_ABORT) {
000962  7839              LDRB     r1,[r7,#0]  ; uip_flags
000964  0688              LSLS     r0,r1,#26
000966  d534              BPL      |L10.2514|
;;;1652   	uip_slen = 0;
000968  80fe              STRH     r6,[r7,#6]
;;;1653   	uip_connr->tcpstateflags = UIP_CLOSED;
00096a  7666              STRB     r6,[r4,#0x19]
                  |L10.2412|
00096c  2014              MOVS     r0,#0x14              ;754
                  |L10.2414|
;;;1654   	BUF->flags = TCP_RST | TCP_ACK;
;;;1655   	goto tcp_send_nodata;
;;;1656         }
;;;1657   
;;;1658         if(uip_flags & UIP_CLOSE) {
;;;1659   	uip_slen = 0;
;;;1660   	uip_connr->len = 1;
;;;1661   	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
;;;1662   	uip_connr->nrtx = 0;
;;;1663   	BUF->flags = TCP_FIN | TCP_ACK;
00096e  e02d              B        |L10.2508|
                  |L10.2416|
                          DCD      ||area_number.24||+0xe
                  |L10.2420|
                          DCD      ||.bss||+0x1004
                  |L10.2424|
000978  7463703a          DCB      "tcp: found no unused connections.",0
00097c  20666f75
000980  6e64206e
000984  6f20756e
000988  75736564
00098c  20636f6e
000990  6e656374
000994  696f6e73
000998  2e00    
00099a  00                DCB      0
00099b  00                DCB      0
                  |L10.2460|
00099c  7463703a          DCB      "tcp: got reset, aborting connection.",0
0009a0  20676f74
0009a4  20726573
0009a8  65742c20
0009ac  61626f72
0009b0  74696e67
0009b4  20636f6e
0009b8  6e656374
0009bc  696f6e2e
0009c0  00      
0009c1  00                DCB      0
0009c2  00                DCB      0
0009c3  00                DCB      0
0009c4  e034              B        |L10.2608|
0009c6  e09f              B        |L10.2824|
0009c8  e05b              B        |L10.2690|
0009ca  e03a              B        |L10.2626|
                  |L10.2508|
0009cc  f885002f          STRB     r0,[r5,#0x2f]
0009d0  e067              B        |L10.2722|
                  |L10.2514|
0009d2  06c8              LSLS     r0,r1,#27             ;1658
0009d4  d506              BPL      |L10.2532|
0009d6  80fe              STRH     r6,[r7,#6]            ;1659
0009d8  2001              MOVS     r0,#1                 ;1660
0009da  8220              STRH     r0,[r4,#0x10]         ;1660
0009dc  2004              MOVS     r0,#4                 ;1661
                  |L10.2526|
0009de  7660              STRB     r0,[r4,#0x19]         ;1661
0009e0  76e6              STRB     r6,[r4,#0x1b]         ;1662
0009e2  e78c              B        |L10.2302|
                  |L10.2532|
;;;1664   	goto tcp_send_nodata;
;;;1665         }
;;;1666   
;;;1667         /* If uip_slen > 0, the application has data to be sent. */
;;;1668         if(uip_slen > 0) {
0009e4  88f8              LDRH     r0,[r7,#6]  ; uip_slen
0009e6  b130              CBZ      r0,|L10.2550|
;;;1669   
;;;1670   	/* If the connection has acknowledged data, the contents of
;;;1671   	   the ->len variable should be discarded. */
;;;1672   	if((uip_flags & UIP_ACKDATA) != 0) {
0009e8  07c9              LSLS     r1,r1,#31
0009ea  d001              BEQ      |L10.2544|
;;;1673   	  uip_connr->len = 0;
0009ec  8226              STRH     r6,[r4,#0x10]
0009ee  e00f              B        |L10.2576|
                  |L10.2544|
;;;1674   	}
;;;1675   
;;;1676   	/* If the ->len variable is non-zero the connection has
;;;1677   	   already data in transit and cannot send anymore right
;;;1678   	   now. */
;;;1679   	if(uip_connr->len == 0) {
0009f0  8a21              LDRH     r1,[r4,#0x10]
0009f2  b169              CBZ      r1,|L10.2576|
;;;1680   
;;;1681   	  /* The application cannot send more than what is allowed by
;;;1682   	     the mss (the minumum of the MSS and the available
;;;1683   	     window). */
;;;1684   	  if(uip_slen > uip_connr->mss) {
;;;1685   	    uip_slen = uip_connr->mss;
;;;1686   	  }
;;;1687   
;;;1688   	  /* Remember how much data we send out now so that we know
;;;1689   	     when everything has been acknowledged. */
;;;1690   	  uip_connr->len = uip_slen;
;;;1691   	} else {
;;;1692   
;;;1693   	  /* If the application already had unacknowledged data, we
;;;1694   	     make sure that the application does not send (i.e.,
;;;1695   	     retransmit) out more than it previously sent out. */
;;;1696   	  uip_slen = uip_connr->len;
0009f4  80f9              STRH     r1,[r7,#6]
                  |L10.2550|
;;;1697   	}
;;;1698         }
;;;1699         uip_connr->nrtx = 0;
0009f6  76e6              STRB     r6,[r4,#0x1b]
                  |L10.2552|
;;;1700       apprexmit:
;;;1701         uip_appdata = uip_sappdata;
0009f8  69b8              LDR      r0,[r7,#0x18]  ; uip_sappdata
;;;1702   
;;;1703         /* If the application has data to be sent, or if the incoming
;;;1704            packet had new data in it, we must send out a packet. */
;;;1705         if(uip_slen > 0 && uip_connr->len > 0) {
0009fa  6178              STR      r0,[r7,#0x14]  ; uip_appdata
0009fc  88f8              LDRH     r0,[r7,#6]  ; uip_slen
0009fe  b178              CBZ      r0,|L10.2592|
000a00  8a20              LDRH     r0,[r4,#0x10]
000a02  b168              CBZ      r0,|L10.2592|
;;;1706   	/* Add the length of the IP and TCP headers. */
;;;1707   	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
000a04  3028              ADDS     r0,r0,#0x28
000a06  80b8              STRH     r0,[r7,#4]
;;;1708   	/* We always set the ACK flag in response packets. */
;;;1709   	BUF->flags = TCP_ACK | TCP_PSH;
000a08  2018              MOVS     r0,#0x18
000a0a  f885002f          STRB     r0,[r5,#0x2f]
;;;1710   	/* Send the packet. */
;;;1711   	goto tcp_send_noopts;
000a0e  e04a              B        |L10.2726|
                  |L10.2576|
000a10  8a61              LDRH     r1,[r4,#0x12]         ;1684
000a12  4281              CMP      r1,r0                 ;1684
000a14  d200              BCS      |L10.2584|
000a16  80f9              STRH     r1,[r7,#6]            ;1685
                  |L10.2584|
000a18  88f8              LDRH     r0,[r7,#6]            ;1690  ; uip_slen
000a1a  8220              STRH     r0,[r4,#0x10]         ;1690
000a1c  e7eb              B        |L10.2550|
                  |L10.2590|
000a1e  e0a5              B        |L10.2924|
                  |L10.2592|
;;;1712         }
;;;1713         /* If there is no data to send, just send out a pure ACK if
;;;1714   	 there is newdata. */
;;;1715         if(uip_flags & UIP_NEWDATA) {
000a20  7838              LDRB     r0,[r7,#0]  ; uip_flags
000a22  0780              LSLS     r0,r0,#30
000a24  d576              BPL      |L10.2836|
;;;1716   	uip_len = UIP_TCPIP_HLEN;
000a26  2028              MOVS     r0,#0x28
000a28  80b8              STRH     r0,[r7,#4]
;;;1717   	BUF->flags = TCP_ACK;
000a2a  f885a02f          STRB     r10,[r5,#0x2f]
;;;1718   	goto tcp_send_noopts;
000a2e  e03a              B        |L10.2726|
                  |L10.2608|
;;;1719         }
;;;1720       }
;;;1721       goto drop;
;;;1722     case UIP_LAST_ACK:
;;;1723       /* We can close this connection if the peer has acknowledged our
;;;1724          FIN. This is indicated by the UIP_ACKDATA flag. */
;;;1725       if(uip_flags & UIP_ACKDATA) {
000a30  7838              LDRB     r0,[r7,#0]  ; uip_flags
000a32  07c0              LSLS     r0,r0,#31
000a34  d06e              BEQ      |L10.2836|
;;;1726         uip_connr->tcpstateflags = UIP_CLOSED;
000a36  7666              STRB     r6,[r4,#0x19]
;;;1727         uip_flags = UIP_CLOSE;
000a38  f887a000          STRB     r10,[r7,#0]
                  |L10.2620|
;;;1728         UIP_APPCALL();
000a3c  f7fffffe          BL       hello_world_appcall
                  |L10.2624|
000a40  e068              B        |L10.2836|
                  |L10.2626|
;;;1729       }
;;;1730       break;
;;;1731   
;;;1732     case UIP_FIN_WAIT_1:
;;;1733       /* The application has closed the connection, but the remote host
;;;1734          hasn't closed its end yet. Thus we do nothing but wait for a
;;;1735          FIN from the other side. */
;;;1736       if(uip_len > 0) {
000a42  88b8              LDRH     r0,[r7,#4]  ; uip_len
000a44  b108              CBZ      r0,|L10.2634|
;;;1737         uip_add_rcv_nxt(uip_len);
000a46  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.2634|
;;;1738       }
;;;1739       if(BUF->flags & TCP_FIN) {
000a4a  f899002f          LDRB     r0,[r9,#0x2f]  ; uip_buf
000a4e  07c0              LSLS     r0,r0,#31
;;;1740         if(uip_flags & UIP_ACKDATA) {
;;;1741   	uip_connr->tcpstateflags = UIP_TIME_WAIT;
;;;1742   	uip_connr->timer = 0;
;;;1743   	uip_connr->len = 0;
;;;1744         } else {
;;;1745   	uip_connr->tcpstateflags = UIP_CLOSING;
;;;1746         }
;;;1747         uip_add_rcv_nxt(1);
;;;1748         uip_flags = UIP_CLOSE;
;;;1749         UIP_APPCALL();
;;;1750         goto tcp_send_ack;
;;;1751       } else if(uip_flags & UIP_ACKDATA) {
000a50  7838              LDRB     r0,[r7,#0]  ; uip_flags
000a52  ea4f70c0          LSL      r0,r0,#31
000a56  d00f              BEQ      |L10.2680|
000a58  b120              CBZ      r0,|L10.2660|
000a5a  f8848019          STRB     r8,[r4,#0x19]         ;1741
000a5e  76a6              STRB     r6,[r4,#0x1a]         ;1742
000a60  8226              STRH     r6,[r4,#0x10]         ;1743
000a62  e001              B        |L10.2664|
                  |L10.2660|
000a64  2006              MOVS     r0,#6                 ;1745
000a66  7660              STRB     r0,[r4,#0x19]         ;1745
                  |L10.2664|
000a68  2001              MOVS     r0,#1                 ;1747
000a6a  f7fffffe          BL       uip_add_rcv_nxt
000a6e  f887a000          STRB     r10,[r7,#0]           ;1748
000a72  f7fffffe          BL       hello_world_appcall
000a76  e012              B        |L10.2718|
                  |L10.2680|
000a78  b178              CBZ      r0,|L10.2714|
;;;1752         uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
000a7a  2005              MOVS     r0,#5
000a7c  7660              STRB     r0,[r4,#0x19]
;;;1753         uip_connr->len = 0;
000a7e  8226              STRH     r6,[r4,#0x10]
;;;1754         goto drop;
000a80  e048              B        |L10.2836|
                  |L10.2690|
;;;1755       }
;;;1756       if(uip_len > 0) {
;;;1757         goto tcp_send_ack;
;;;1758       }
;;;1759       goto drop;
;;;1760   
;;;1761     case UIP_FIN_WAIT_2:
;;;1762       if(uip_len > 0) {
000a82  88b8              LDRH     r0,[r7,#4]  ; uip_len
000a84  b108              CBZ      r0,|L10.2698|
;;;1763         uip_add_rcv_nxt(uip_len);
000a86  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.2698|
;;;1764       }
;;;1765       if(BUF->flags & TCP_FIN) {
000a8a  f899002f          LDRB     r0,[r9,#0x2f]  ; uip_buf
000a8e  07c0              LSLS     r0,r0,#31
000a90  d003              BEQ      |L10.2714|
;;;1766         uip_connr->tcpstateflags = UIP_TIME_WAIT;
000a92  f8848019          STRB     r8,[r4,#0x19]
;;;1767         uip_connr->timer = 0;
000a96  76a6              STRB     r6,[r4,#0x1a]
;;;1768         uip_add_rcv_nxt(1);
;;;1769         uip_flags = UIP_CLOSE;
;;;1770         UIP_APPCALL();
;;;1771         goto tcp_send_ack;
000a98  e7e6              B        |L10.2664|
                  |L10.2714|
;;;1772       }
;;;1773       if(uip_len > 0) {
000a9a  88b8              LDRH     r0,[r7,#4]  ; uip_len
000a9c  b390              CBZ      r0,|L10.2820|
                  |L10.2718|
;;;1774         goto tcp_send_ack;
;;;1775       }
;;;1776       goto drop;
;;;1777   
;;;1778     case UIP_TIME_WAIT:
;;;1779       goto tcp_send_ack;
;;;1780   
;;;1781     case UIP_CLOSING:
;;;1782       if(uip_flags & UIP_ACKDATA) {
;;;1783         uip_connr->tcpstateflags = UIP_TIME_WAIT;
;;;1784         uip_connr->timer = 0;
;;;1785       }
;;;1786     }
;;;1787     goto drop;
;;;1788   
;;;1789   
;;;1790     /* We jump here when we are ready to send the packet, and just want
;;;1791        to set the appropriate TCP sequence numbers in the TCP header. */
;;;1792    tcp_send_ack:
;;;1793     BUF->flags = TCP_ACK;
000a9e  f889a02f          STRB     r10,[r9,#0x2f]
                  |L10.2722|
;;;1794    tcp_send_nodata:
;;;1795     uip_len = UIP_IPTCPH_LEN;
000aa2  2028              MOVS     r0,#0x28
000aa4  80b8              STRH     r0,[r7,#4]
                  |L10.2726|
;;;1796    tcp_send_noopts:
;;;1797     BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
000aa6  2050              MOVS     r0,#0x50
000aa8  f885002e          STRB     r0,[r5,#0x2e]
                  |L10.2732|
;;;1798    tcp_send:
;;;1799     /* We're done with the input processing. We are now ready to send a
;;;1800        reply. Our job is to fill in all the fields of the TCP and IP
;;;1801        headers before calculating the checksum and finally send the
;;;1802        packet. */
;;;1803     BUF->ackno[0] = uip_connr->rcv_nxt[0];
000aac  f1050516          ADD      r5,r5,#0x16
000ab0  7a20              LDRB     r0,[r4,#8]
000ab2  7528              STRB     r0,[r5,#0x14]
;;;1804     BUF->ackno[1] = uip_connr->rcv_nxt[1];
000ab4  7a60              LDRB     r0,[r4,#9]
000ab6  7568              STRB     r0,[r5,#0x15]
;;;1805     BUF->ackno[2] = uip_connr->rcv_nxt[2];
000ab8  7aa0              LDRB     r0,[r4,#0xa]
000aba  75a8              STRB     r0,[r5,#0x16]
;;;1806     BUF->ackno[3] = uip_connr->rcv_nxt[3];
000abc  7ae0              LDRB     r0,[r4,#0xb]
000abe  75e8              STRB     r0,[r5,#0x17]
;;;1807   
;;;1808     BUF->seqno[0] = uip_connr->snd_nxt[0];
000ac0  7b20              LDRB     r0,[r4,#0xc]
000ac2  7428              STRB     r0,[r5,#0x10]
;;;1809     BUF->seqno[1] = uip_connr->snd_nxt[1];
000ac4  7b60              LDRB     r0,[r4,#0xd]
000ac6  7468              STRB     r0,[r5,#0x11]
;;;1810     BUF->seqno[2] = uip_connr->snd_nxt[2];
000ac8  7ba2              LDRB     r2,[r4,#0xe]
000aca  74aa              STRB     r2,[r5,#0x12]
;;;1811     BUF->seqno[3] = uip_connr->snd_nxt[3];
000acc  7be2              LDRB     r2,[r4,#0xf]
;;;1812   
;;;1813     BUF->proto = UIP_PROTO_TCP;
000ace  f04f0106          MOV      r1,#6
000ad2  74ea              STRB     r2,[r5,#0x13]         ;1811
000ad4  7069              STRB     r1,[r5,#1]
;;;1814   
;;;1815     BUF->srcport  = uip_connr->lport;
000ad6  88a1              LDRH     r1,[r4,#4]
;;;1816     BUF->destport = uip_connr->rport;
;;;1817   
;;;1818     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
000ad8  4828              LDR      r0,|L10.2940|
000ada  81a9              STRH     r1,[r5,#0xc]          ;1815
000adc  88e1              LDRH     r1,[r4,#6]            ;1816
000ade  81e9              STRH     r1,[r5,#0xe]          ;1816
000ae0  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
000ae2  80a9              STRH     r1,[r5,#4]
000ae4  8840              LDRH     r0,[r0,#2]  ; uip_hostaddr
000ae6  80e8              STRH     r0,[r5,#6]
;;;1819     uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
000ae8  8820              LDRH     r0,[r4,#0]
000aea  8128              STRH     r0,[r5,#8]
000aec  8860              LDRH     r0,[r4,#2]
000aee  8168              STRH     r0,[r5,#0xa]
;;;1820   
;;;1821     if(uip_connr->tcpstateflags & UIP_STOPPED) {
000af0  7e60              LDRB     r0,[r4,#0x19]
000af2  f1a50516          SUB      r5,r5,#0x16           ;1819
000af6  06c0              LSLS     r0,r0,#27
000af8  d50e              BPL      |L10.2840|
;;;1822       /* If the connection has issued uip_stop(), we advertise a zero
;;;1823          window so that the remote host will stop sending data. */
;;;1824       BUF->wnd[0] = BUF->wnd[1] = 0;
000afa  f8856031          STRB     r6,[r5,#0x31]
000afe  f8856030          STRB     r6,[r5,#0x30]
000b02  e00f              B        |L10.2852|
                  |L10.2820|
000b04  e006              B        |L10.2836|
                  |L10.2822|
000b06  e01c              B        |L10.2882|
                  |L10.2824|
000b08  7838              LDRB     r0,[r7,#0]            ;1782  ; uip_flags
000b0a  07c0              LSLS     r0,r0,#31             ;1782
000b0c  d002              BEQ      |L10.2836|
000b0e  f8848019          STRB     r8,[r4,#0x19]         ;1783
000b12  76a6              STRB     r6,[r4,#0x1a]         ;1784
                  |L10.2836|
;;;1825     } else {
;;;1826       BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
;;;1827       BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
;;;1828     }
;;;1829   
;;;1830    tcp_send_noconn:
;;;1831     BUF->ttl = UIP_TTL;
;;;1832   #if UIP_CONF_IPV6
;;;1833     /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1834        length. */
;;;1835     BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1836     BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1837   #else /* UIP_CONF_IPV6 */
;;;1838     BUF->len[0] = (uip_len >> 8);
;;;1839     BUF->len[1] = (uip_len & 0xff);
;;;1840   #endif /* UIP_CONF_IPV6 */
;;;1841   
;;;1842     BUF->urgp[0] = BUF->urgp[1] = 0;
;;;1843   
;;;1844     /* Calculate TCP checksum. */
;;;1845     BUF->tcpchksum = 0;
;;;1846     BUF->tcpchksum = ~(uip_tcpchksum());
;;;1847   
;;;1848    ip_send_nolen:
;;;1849   
;;;1850   #if UIP_CONF_IPV6
;;;1851     BUF->vtc = 0x60;
;;;1852     BUF->tcflow = 0x00;
;;;1853     BUF->flow = 0x00;
;;;1854   #else /* UIP_CONF_IPV6 */
;;;1855     BUF->vhl = 0x45;
;;;1856     BUF->tos = 0;
;;;1857     BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
;;;1858     ++ipid;
;;;1859     BUF->ipid[0] = ipid >> 8;
;;;1860     BUF->ipid[1] = ipid & 0xff;
;;;1861     /* Calculate IP checksum. */
;;;1862     BUF->ipchksum = 0;
;;;1863     BUF->ipchksum = ~(uip_ipchksum());
;;;1864     DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
;;;1865   #endif /* UIP_CONF_IPV6 */
;;;1866   
;;;1867     UIP_STAT(++uip_stat.tcp.sent);
;;;1868    send:
;;;1869     DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
;;;1870   	       (BUF->len[0] << 8) | BUF->len[1]);
;;;1871   
;;;1872     UIP_STAT(++uip_stat.ip.sent);
;;;1873     /* Return and let the caller do the actual transmission. */
;;;1874     uip_flags = 0;
;;;1875     return;
;;;1876    drop:
;;;1877     uip_len = 0;
000b14  80be              STRH     r6,[r7,#4]
;;;1878     uip_flags = 0;
;;;1879     return;
000b16  e02e              B        |L10.2934|
                  |L10.2840|
000b18  200f              MOVS     r0,#0xf               ;1826
000b1a  f8850030          STRB     r0,[r5,#0x30]         ;1826
000b1e  20ca              MOVS     r0,#0xca              ;1827
000b20  f8850031          STRB     r0,[r5,#0x31]         ;1827
                  |L10.2852|
000b24  2040              MOVS     r0,#0x40              ;1831
000b26  75a8              STRB     r0,[r5,#0x16]         ;1831
000b28  88b8              LDRH     r0,[r7,#4]            ;1838  ; uip_len
000b2a  0a01              LSRS     r1,r0,#8              ;1838
000b2c  7429              STRB     r1,[r5,#0x10]         ;1838
000b2e  7468              STRB     r0,[r5,#0x11]         ;1839
000b30  f8856035          STRB     r6,[r5,#0x35]         ;1842
000b34  f8856034          STRB     r6,[r5,#0x34]         ;1842
000b38  866e              STRH     r6,[r5,#0x32]         ;1845
000b3a  f7fffffe          BL       uip_tcpchksum
000b3e  43c0              MVNS     r0,r0                 ;1846
000b40  8668              STRH     r0,[r5,#0x32]         ;1846
                  |L10.2882|
000b42  2045              MOVS     r0,#0x45              ;1855
000b44  73a8              STRB     r0,[r5,#0xe]          ;1855
000b46  73ee              STRB     r6,[r5,#0xf]          ;1856
000b48  756e              STRB     r6,[r5,#0x15]         ;1857
000b4a  752e              STRB     r6,[r5,#0x14]         ;1857
000b4c  8938              LDRH     r0,[r7,#8]            ;1858  ; ipid
000b4e  1c40              ADDS     r0,r0,#1              ;1858
000b50  8138              STRH     r0,[r7,#8]            ;1858
000b52  0a01              LSRS     r1,r0,#8              ;1859
000b54  74a9              STRB     r1,[r5,#0x12]         ;1859
000b56  74e8              STRB     r0,[r5,#0x13]         ;1860
000b58  832e              STRH     r6,[r5,#0x18]         ;1862
000b5a  f7fffffe          BL       uip_ipchksum
000b5e  43c0              MVNS     r0,r0                 ;1863
000b60  8328              STRH     r0,[r5,#0x18]         ;1863
000b62  f8bb101e          LDRH     r1,[r11,#0x1e]        ;1867  ; uip_stat
000b66  1c49              ADDS     r1,r1,#1              ;1867
000b68  f8ab101e          STRH     r1,[r11,#0x1e]        ;1867
                  |L10.2924|
000b6c  f8bb1004          LDRH     r1,[r11,#4]           ;1872  ; uip_stat
000b70  1c49              ADDS     r1,r1,#1              ;1872
000b72  f8ab1004          STRH     r1,[r11,#4]           ;1872
                  |L10.2934|
000b76  703e              STRB     r6,[r7,#0]            ;1878
;;;1880   }
000b78  e8bd9ff0          POP      {r4-r12,pc}
;;;1881   /*---------------------------------------------------------------------------*/
                          ENDP

                  |L10.2940|
                          DCD      ||area_number.24||+0xe

                          AREA ||i.uip_send||, CODE, READONLY, ALIGN=2

                  uip_send PROC
;;;1888   void
;;;1889   uip_send(const void *data, int len)
000000  2900              CMP      r1,#0
;;;1890   {
;;;1891     if(len > 0) {
000002  dd09              BLE      |L11.24|
;;;1892       uip_slen = len;
000004  b28a              UXTH     r2,r1
000006  4905              LDR      r1,|L11.28|
000008  80ca              STRH     r2,[r1,#6]
;;;1893       if(data != uip_sappdata) {
00000a  698b              LDR      r3,[r1,#0x18]  ; uip_sappdata
00000c  4298              CMP      r0,r3
00000e  d003              BEQ      |L11.24|
;;;1894         memcpy(uip_sappdata, (data), uip_slen);
000010  4601              MOV      r1,r0
000012  4618              MOV      r0,r3
000014  f7ffbffe          B.W      __aeabi_memcpy
                  |L11.24|
;;;1895       }
;;;1896     }
;;;1897   }
000018  4770              BX       lr
;;;1898   /** @} */
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      ||area_number.24||

                          AREA ||i.uip_setipid||, CODE, READONLY, ALIGN=2

                  uip_setipid PROC
;;;180    
;;;181    void uip_setipid(u16_t id) { ipid = id; }
000000  4901              LDR      r1,|L12.8|
000002  8108              STRH     r0,[r1,#8]
000004  4770              BX       lr
;;;182    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||area_number.24||

                          AREA ||i.uip_tcpchksum||, CODE, READONLY, ALIGN=1

                  uip_tcpchksum PROC
;;;363    u16_t
;;;364    uip_tcpchksum(void)
000000  2006              MOVS     r0,#6
;;;365    {
;;;366      return upper_layer_chksum(UIP_PROTO_TCP);
000002  f7ffbffe          B.W      upper_layer_chksum
;;;367    }
;;;368    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_udp_new||, CODE, READONLY, ALIGN=2

                  uip_udp_new PROC
;;;472    struct uip_udp_conn *
;;;473    uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;474    {
000004  4689              MOV      r9,r1
;;;475      register struct uip_udp_conn *conn;
;;;476    
;;;477      /* Find an unused local port. */
;;;478     again:
;;;479      ++lastport;
;;;480    
;;;481      if(lastport >= 32000) {
;;;482        lastport = 4096;
;;;483      }
;;;484    
;;;485      for(c = 0; c < UIP_UDP_CONNS; ++c) {
;;;486        if(uip_udp_conns[c].lport == htons(lastport)) {
000006  4a25              LDR      r2,|L14.156|
000008  4925              LDR      r1,|L14.160|
00000a  f44f4cfa          MOV      r12,#0x7d00           ;481
00000e  f44f5880          MOV      r8,#0x1000            ;482
000012  2700              MOVS     r7,#0                 ;485
                  |L14.20|
000014  894b              LDRH     r3,[r1,#0xa]          ;479  ; lastport
000016  1c5b              ADDS     r3,r3,#1              ;479
000018  b29b              UXTH     r3,r3                 ;479
00001a  814b              STRH     r3,[r1,#0xa]          ;479
00001c  4563              CMP      r3,r12                ;481
00001e  d301              BCC      |L14.36|
000020  f8a1800a          STRH     r8,[r1,#0xa]          ;482
                  |L14.36|
000024  704f              STRB     r7,[r1,#1]            ;485
000026  894c              LDRH     r4,[r1,#0xa]          ;479
000028  0223              LSLS     r3,r4,#8
00002a  ea432314          ORR      r3,r3,r4,LSR #8
00002e  b29d              UXTH     r5,r3
                  |L14.48|
000030  784b              LDRB     r3,[r1,#1]  ; c
000032  eb030643          ADD      r6,r3,r3,LSL #1
000036  eb0206c6          ADD      r6,r2,r6,LSL #3
00003a  88b6              LDRH     r6,[r6,#4]
00003c  42b5              CMP      r5,r6
00003e  d0e9              BEQ      |L14.20|
000040  1c5b              ADDS     r3,r3,#1              ;485
000042  b2db              UXTB     r3,r3                 ;485
000044  704b              STRB     r3,[r1,#1]            ;485
000046  2b0a              CMP      r3,#0xa               ;485
000048  d3f2              BCC      |L14.48|
;;;487          goto again;
;;;488        }
;;;489      }
;;;490    
;;;491    
;;;492      conn = 0;
;;;493      for(c = 0; c < UIP_UDP_CONNS; ++c) {
00004a  704f              STRB     r7,[r1,#1]
                  |L14.76|
;;;494        if(uip_udp_conns[c].lport == 0) {
00004c  784b              LDRB     r3,[r1,#1]  ; c
00004e  eb030543          ADD      r5,r3,r3,LSL #1
000052  eb0205c5          ADD      r5,r2,r5,LSL #3
000056  88ad              LDRH     r5,[r5,#4]
000058  b13d              CBZ      r5,|L14.106|
00005a  1c5b              ADDS     r3,r3,#1              ;493
00005c  b2db              UXTB     r3,r3                 ;493
00005e  704b              STRB     r3,[r1,#1]            ;493
000060  2b0a              CMP      r3,#0xa               ;493
000062  d3f3              BCC      |L14.76|
                  |L14.100|
;;;495          conn = &uip_udp_conns[c];
;;;496          break;
;;;497        }
;;;498      }
;;;499    
;;;500      if(conn == 0) {
;;;501        return 0;
000064  2000              MOVS     r0,#0
                  |L14.102|
;;;502      }
;;;503    
;;;504      conn->lport = HTONS(lastport);
;;;505      conn->rport = rport;
;;;506      if(ripaddr == NULL) {
;;;507        memset(conn->ripaddr, 0, sizeof(uip_ipaddr_t));
;;;508      } else {
;;;509        uip_ipaddr_copy(&conn->ripaddr, ripaddr);
;;;510      }
;;;511      conn->ttl = UIP_TTL;
;;;512    
;;;513      return conn;
;;;514    }
000066  e8bd83f0          POP      {r4-r9,pc}
                  |L14.106|
00006a  b2db              UXTB     r3,r3                 ;495
00006c  eb030343          ADD      r3,r3,r3,LSL #1       ;495
000070  eb1202c3          ADDS     r2,r2,r3,LSL #3       ;495
000074  d0f6              BEQ      |L14.100|
000076  0421              LSLS     r1,r4,#16             ;504
000078  0a09              LSRS     r1,r1,#8              ;504
00007a  ea412114          ORR      r1,r1,r4,LSR #8       ;504
00007e  8091              STRH     r1,[r2,#4]            ;504
000080  f8a29006          STRH     r9,[r2,#6]            ;505
000084  b138              CBZ      r0,|L14.150|
000086  8801              LDRH     r1,[r0,#0]            ;509
000088  8011              STRH     r1,[r2,#0]            ;509
00008a  8840              LDRH     r0,[r0,#2]            ;509
00008c  8050              STRH     r0,[r2,#2]            ;509
                  |L14.142|
00008e  2040              MOVS     r0,#0x40              ;511
000090  7210              STRB     r0,[r2,#8]            ;511
000092  4610              MOV      r0,r2                 ;513
000094  e7e7              B        |L14.102|
                  |L14.150|
000096  6017              STR      r7,[r2,#0]            ;507
000098  e7f9              B        |L14.142|
;;;515    #endif /* UIP_UDP */
                          ENDP

00009a  0000              DCW      0x0000
                  |L14.156|
                          DCD      ||.bss||+0x2274
                  |L14.160|
                          DCD      ||area_number.24||

                          AREA ||i.uip_udpchksum||, CODE, READONLY, ALIGN=1

                  uip_udpchksum PROC
;;;370    u16_t
;;;371    uip_udpchksum(void)
000000  2011              MOVS     r0,#0x11
;;;372    {
;;;373      return upper_layer_chksum(UIP_PROTO_UDP);
000002  f7ffbffe          B.W      upper_layer_chksum
;;;374    }
;;;375    #endif /* UIP_UDP_CHECKSUMS */
                          ENDP


                          AREA ||i.uip_unlisten||, CODE, READONLY, ALIGN=2

                  uip_unlisten PROC
;;;517    void
;;;518    uip_unlisten(u16_t port)
000000  b530              PUSH     {r4,r5,lr}
;;;519    {
;;;520      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4909              LDR      r1,|L16.40|
000004  2400              MOVS     r4,#0
;;;521        if(uip_listenports[c] == port) {
000006  4b09              LDR      r3,|L16.44|
000008  704c              STRB     r4,[r1,#1]            ;520
                  |L16.10|
00000a  784a              LDRB     r2,[r1,#1]  ; c
00000c  f8335012          LDRH     r5,[r3,r2,LSL #1]
000010  4285              CMP      r5,r0
000012  d103              BNE      |L16.28|
;;;522          uip_listenports[c] = 0;
000014  b2d0              UXTB     r0,r2
000016  f8234010          STRH     r4,[r3,r0,LSL #1]
;;;523          return;
;;;524        }
;;;525      }
;;;526    }
00001a  bd30              POP      {r4,r5,pc}
                  |L16.28|
00001c  1c52              ADDS     r2,r2,#1              ;520
00001e  b2d2              UXTB     r2,r2                 ;520
000020  704a              STRB     r2,[r1,#1]            ;520
000022  2a28              CMP      r2,#0x28              ;520
000024  d3f1              BCC      |L16.10|
000026  bd30              POP      {r4,r5,pc}
;;;527    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L16.40|
                          DCD      ||area_number.24||
                  |L16.44|
                          DCD      ||.bss||+0x2224

                          AREA ||i.upper_layer_chksum||, CODE, READONLY, ALIGN=2

                  upper_layer_chksum PROC
;;;328    static u16_t
;;;329    upper_layer_chksum(u8_t proto)
000000  490f              LDR      r1,|L17.64|
;;;330    {
000002  b510              PUSH     {r4,lr}
;;;331      u16_t upper_layer_len;
;;;332      u16_t sum;
;;;333    
;;;334    #if UIP_CONF_IPV6
;;;335      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
;;;336    #else /* UIP_CONF_IPV6 */
;;;337      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
000004  7c4a              LDRB     r2,[r1,#0x11]  ; uip_buf
000006  7c09              LDRB     r1,[r1,#0x10]  ; uip_buf
000008  f06f0313          MVN      r3,#0x13
00000c  eb032101          ADD      r1,r3,r1,LSL #8
000010  4411              ADD      r1,r1,r2
000012  b28c              UXTH     r4,r1
;;;338    #endif /* UIP_CONF_IPV6 */
;;;339    
;;;340      /* First sum pseudoheader. */
;;;341    
;;;342      /* IP protocol and length fields. This addition cannot carry. */
;;;343      sum = upper_layer_len + proto;
;;;344      /* Sum IP source and destination addresses. */
;;;345      sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
000014  490a              LDR      r1,|L17.64|
000016  4420              ADD      r0,r0,r4              ;343
000018  b280              UXTH     r0,r0                 ;343
00001a  2208              MOVS     r2,#8
00001c  311a              ADDS     r1,r1,#0x1a
00001e  f7fffffe          BL       chksum
;;;346    
;;;347      /* Sum TCP header and data. */
;;;348      sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
000022  4907              LDR      r1,|L17.64|
000024  4622              MOV      r2,r4
000026  3122              ADDS     r1,r1,#0x22
000028  f7fffffe          BL       chksum
;;;349    	       upper_layer_len);
;;;350    
;;;351      return (sum == 0) ? 0xffff : htons(sum);
00002c  f64f71ff          MOV      r1,#0xffff
000030  b118              CBZ      r0,|L17.58|
000032  0201              LSLS     r1,r0,#8
000034  ea412010          ORR      r0,r1,r0,LSR #8
000038  b281              UXTH     r1,r0
                  |L17.58|
00003a  4608              MOV      r0,r1
;;;352    }
00003c  bd10              POP      {r4,pc}
;;;353    /*---------------------------------------------------------------------------*/
                          ENDP

00003e  0000              DCW      0x0000
                  |L17.64|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uip_buf
                          %        4100
                  uip_conns
                          %        4640
                  uip_listenports
                          %        80
                  uip_udp_conns
                          %        240
                  uip_stat
                          %        52

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  all_ones_addr
000000  ffffffff          DCW      0xffff,0xffff

                          AREA ||area_number.22||, DATA, READONLY, ALIGN=1

                          EXPORTAS ||area_number.22||, ||.constdata||
                  all_zeroes_addr
000000  00000000          DCW      0x0000,0x0000

                          AREA ||.data||, DATA, ALIGN=0

                  uip_ethaddr
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  0000              DCB      0x00,0x00

                          AREA ||area_number.24||, DATA, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.data||
                  uip_flags
000000  00                DCB      0x00
                  c
000001  00                DCB      0x00
                  opt
000002  0000              DCB      0x00,0x00
                  uip_len
000004  0000              DCB      0x00,0x00
                  uip_slen
000006  0000              DCB      0x00,0x00
                  ipid
000008  0000              DCB      0x00,0x00
                  lastport
00000a  0000              DCB      0x00,0x00
                  tmp16
00000c  0000              DCB      0x00,0x00
                  uip_hostaddr
00000e  0000              DCB      0x00,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  uip_appdata
                          DCD      0x00000000
                  uip_sappdata
                          DCD      0x00000000
                  uip_conn
                          DCD      0x00000000
                  uip_udp_conn
                          DCD      0x00000000
                  iss
                          DCD      0x00000000
                  uip_acc32
                          DCD      0x00000000

                          AREA ||area_number.25||, DATA, ALIGN=1

                          EXPORTAS ||area_number.25||, ||.data||
                  uip_draddr
                          DCDU     0x00000000

                          AREA ||area_number.26||, DATA, ALIGN=1

                          EXPORTAS ||area_number.26||, ||.data||
                  uip_netmask
                          DCDU     0x00000000
