; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\dm9k_uip.o --depend=.\Obj\dm9k_uip.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Source\src\uIP_DM9000\dm9k_uip.c]
                          THUMB

                          AREA ||i.DM9K_CtrlLinesConfig||, CODE, READONLY, ALIGN=2

                  DM9K_CtrlLinesConfig PROC
;;;700    */
;;;701    static void DM9K_CtrlLinesConfig(void)
000000  b508              PUSH     {r3,lr}
;;;702    {
;;;703    	GPIO_InitTypeDef GPIO_InitStructure;
;;;704    
;;;705    	/* 使能 FSMC, GPIOD, GPIOE, GPIOF, GPIOG 和 AFIO 时钟 */
;;;706    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0208              LSLS     r0,r1,#8
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;707    
;;;708    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE |
00000a  2101              MOVS     r1,#1
00000c  f24010e1          MOV      r0,#0x1e1
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;709    	                     RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG |
;;;710    	                     RCC_APB2Periph_AFIO, ENABLE);
;;;711    
;;;712    	/* 设置 PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
;;;713    	 PD.10(D15), PD.14(D0), PD.15(D1) 为复用推挽输出 */
;;;714    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
000014  f24c7033          MOV      r0,#0xc733
000018  f8ad0000          STRH     r0,[sp,#0]
;;;715    	                            GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |
;;;716    	                            GPIO_Pin_15; // | GPIO_Pin_7;
;;;717    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0002          STRB     r0,[sp,#2]
;;;718    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000022  2018              MOVS     r0,#0x18
000024  f88d0003          STRB     r0,[sp,#3]
;;;719    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000028  4669              MOV      r1,sp
00002a  480d              LDR      r0,|L1.96|
00002c  f7fffffe          BL       GPIO_Init
;;;720    
;;;721    	/* 设置 PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;722    	 PE.14(D11), PE.15(D12) 为复用推挽输出 */
;;;723    	/* PE3,PE4 用于A19, A20, STM32F103ZE-EK(REV 2.0)必须使能 */
;;;724    	/* PE5,PE6 用于A21, A22, STM32F103ZE-EK(REV 1.0)必须使能 */
;;;725    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
000030  f64f70f8          MOV      r0,#0xfff8
000034  f8ad0000          STRH     r0,[sp,#0]
;;;726    	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;727    	                            GPIO_Pin_15 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6;
;;;728    	GPIO_Init(GPIOE, &GPIO_InitStructure);
000038  4669              MOV      r1,sp
00003a  480a              LDR      r0,|L1.100|
00003c  f7fffffe          BL       GPIO_Init
;;;729    
;;;730    	/* 设置 PF2(A2))  为复用推挽输出 */
;;;731    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000040  2004              MOVS     r0,#4
000042  f8ad0000          STRH     r0,[sp,#0]
;;;732    	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_12;
;;;733    	GPIO_Init(GPIOF, &GPIO_InitStructure);
000046  4669              MOV      r1,sp
000048  4807              LDR      r0,|L1.104|
00004a  f7fffffe          BL       GPIO_Init
;;;734    
;;;735    	/* 设置 PG.12(NE4 ) 为复用推挽输出  */
;;;736    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
00004e  f44f5080          MOV      r0,#0x1000
000052  f8ad0000          STRH     r0,[sp,#0]
;;;737    	GPIO_Init(GPIOG, &GPIO_InitStructure);
000056  4669              MOV      r1,sp
000058  4804              LDR      r0,|L1.108|
00005a  f7fffffe          BL       GPIO_Init
;;;738    }
00005e  bd08              POP      {r3,pc}
;;;739    
                          ENDP

                  |L1.96|
                          DCD      0x40011400
                  |L1.100|
                          DCD      0x40011800
                  |L1.104|
                          DCD      0x40011c00
                  |L1.108|
                          DCD      0x40012000

                          AREA ||i.DM9K_FSMCConfig||, CODE, READONLY, ALIGN=1

                  DM9K_FSMCConfig PROC
;;;745    */
;;;746    static void DM9K_FSMCConfig(void)
000000  b500              PUSH     {lr}
;;;747    {
000002  b095              SUB      sp,sp,#0x54
;;;748    	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;749    	FSMC_NORSRAMTimingInitTypeDef  FSMC_NORSRAMTimingInitStructure;
;;;750    
;;;751    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;752    	/*----------------------- SRAM Bank 4 ----------------------------------------*/
;;;753    	/* FSMC_Bank1_NORSRAM4 configuration */
;;;754    	FSMC_NORSRAMTimingInitStructure.FSMC_AddressSetupTime = 0;
000004  2000              MOVS     r0,#0
;;;755    	FSMC_NORSRAMTimingInitStructure.FSMC_AddressHoldTime = 0;
;;;756    	FSMC_NORSRAMTimingInitStructure.FSMC_DataSetupTime = 4;
000006  2104              MOVS     r1,#4
000008  900e              STR      r0,[sp,#0x38]
00000a  e9cd010f          STRD     r0,r1,[sp,#0x3c]
;;;757    	FSMC_NORSRAMTimingInitStructure.FSMC_BusTurnAroundDuration = 0;
;;;758    	FSMC_NORSRAMTimingInitStructure.FSMC_CLKDivision = 0;
;;;759    	FSMC_NORSRAMTimingInitStructure.FSMC_DataLatency = 0;
;;;760    	FSMC_NORSRAMTimingInitStructure.FSMC_AccessMode = FSMC_AccessMode_A;
;;;761    
;;;762    	/* Color LCD configuration ------------------------------------
;;;763    	 LCD configured as follow:
;;;764    	    - Data/Address MUX = Disable
;;;765    	    - Memory Type = SRAM
;;;766    	    - Data Width = 16bit
;;;767    	    - Write Operation = Enable
;;;768    	    - Extended Mode = Enable
;;;769    	    - Asynchronous Wait = Disable */
;;;770    	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM4;
00000e  2106              MOVS     r1,#6
000010  9014              STR      r0,[sp,#0x50]
000012  e9cd1000          STRD     r1,r0,[sp,#0]
000016  9011              STR      r0,[sp,#0x44]         ;758
000018  9012              STR      r0,[sp,#0x48]         ;759
;;;771    	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;772    	FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;773    	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
00001a  2110              MOVS     r1,#0x10
00001c  9013              STR      r0,[sp,#0x4c]         ;760
00001e  e9cd0102          STRD     r0,r1,[sp,#8]
;;;774    	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;775    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000022  9004              STR      r0,[sp,#0x10]
;;;776    	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
000024  9005              STR      r0,[sp,#0x14]
;;;777    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;778    	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000026  0209              LSLS     r1,r1,#8
000028  9006              STR      r0,[sp,#0x18]
00002a  e9cd0107          STRD     r0,r1,[sp,#0x1c]
;;;779    	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;780    	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
00002e  9009              STR      r0,[sp,#0x24]
;;;781    	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000030  900a              STR      r0,[sp,#0x28]
;;;782    	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;
000032  900b              STR      r0,[sp,#0x2c]
000034  a80e              ADD      r0,sp,#0x38
;;;783    	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &FSMC_NORSRAMTimingInitStructure;
000036  900c              STR      r0,[sp,#0x30]
;;;784    
;;;785    	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
000038  900d              STR      r0,[sp,#0x34]
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       FSMC_NORSRAMInit
;;;786    
;;;787    	/* - BANK 4 (of NOR/SRAM Bank 0~3) is enabled */
;;;788    	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);
000040  2101              MOVS     r1,#1
000042  2006              MOVS     r0,#6
000044  f7fffffe          BL       FSMC_NORSRAMCmd
;;;789    }
000048  b015              ADD      sp,sp,#0x54
00004a  bd00              POP      {pc}
                          ENDP


                          AREA ||i.dm9k_ReadID||, CODE, READONLY, ALIGN=2

                  dm9k_ReadID PROC
;;;675    */
;;;676    uint32_t dm9k_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;677    {
;;;678    	uint8_t vid1,vid2,pid1,pid2;
;;;679    
;;;680    	if (s_FSMC_Init_Ok == 0)
000002  4c10              LDR      r4,|L3.68|
000004  7860              LDRB     r0,[r4,#1]  ; s_FSMC_Init_Ok
000006  b928              CBNZ     r0,|L3.20|
;;;681    	{
;;;682    		DM9K_CtrlLinesConfig();
000008  f7fffffe          BL       DM9K_CtrlLinesConfig
;;;683    		DM9K_FSMCConfig();
00000c  f7fffffe          BL       DM9K_FSMCConfig
;;;684    
;;;685    		s_FSMC_Init_Ok = 1;
000010  2001              MOVS     r0,#1
000012  7060              STRB     r0,[r4,#1]
                  |L3.20|
;;;686    	}
;;;687    	vid1 = ior(DM9000_REG_VID_L) & 0xFF;
000014  2028              MOVS     r0,#0x28
000016  f7fffffe          BL       ior
00001a  4602              MOV      r2,r0
;;;688    	vid2 = ior(DM9000_REG_VID_H) & 0xFF;
00001c  2029              MOVS     r0,#0x29
00001e  f7fffffe          BL       ior
000022  4604              MOV      r4,r0
;;;689    	pid1 = ior(DM9000_REG_PID_L) & 0xFF;
000024  202a              MOVS     r0,#0x2a
000026  f7fffffe          BL       ior
00002a  4603              MOV      r3,r0
;;;690    	pid2 = ior(DM9000_REG_PID_H) & 0xFF;
00002c  202b              MOVS     r0,#0x2b
00002e  f7fffffe          BL       ior
000032  4601              MOV      r1,r0
;;;691    
;;;692    	return (vid2 << 24) | (vid1 << 16) | (pid2 << 8) | pid1;
000034  0620              LSLS     r0,r4,#24
000036  ea404002          ORR      r0,r0,r2,LSL #16
00003a  ea402001          ORR      r0,r0,r1,LSL #8
00003e  4318              ORRS     r0,r0,r3
;;;693    }
000040  bd10              POP      {r4,pc}
;;;694    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      ||.data||

                          AREA ||i.dm9k_debug_test||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dm9k_debug_test PROC
;;;439    */
;;;440    void dm9k_debug_test(void)
000000  2700              MOVS     r7,#0
000002  4c8e              LDR      r4,|L4.572|
;;;441    {
;;;442    	uint32_t check_device;
;;;443    	uint8_t  check_iomode;
;;;444    	uint8_t  check_reg_fail = 0;
;;;445    	uint8_t  check_fifo_fail = 0;
000004  463d              MOV      r5,r7
000006  46b9              MOV      r9,r7
000008  463b              MOV      r3,r7
00000a  8027              STRH     r7,[r4,#0]
00000c  f04f0803          MOV      r8,#3
000010  4646              MOV      r6,r8
000012  f8a48008          STRH     r8,[r4,#8]
;;;446    	uint16_t i;
;;;447    	uint16_t j;
;;;448    
;;;449    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
;;;450    	dm9k_udelay(10);								/* delay 10us */
000016  200a              MOVS     r0,#0xa
000018  f7fffffe          BL       dm9k_udelay
00001c  8023              STRH     r3,[r4,#0]
00001e  8126              STRH     r6,[r4,#8]
;;;451    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
;;;452    	dm9k_udelay(10);								/* delay 10us */
000020  200a              MOVS     r0,#0xa
000022  f7fffffe          BL       dm9k_udelay
;;;453    
;;;454    	check_device  = ior(DM9000_REG_VID_L);
000026  2028              MOVS     r0,#0x28
000028  f7fffffe          BL       ior
00002c  4602              MOV      r2,r0
;;;455    	check_device |= ior(DM9000_REG_VID_H) << 8;
00002e  2029              MOVS     r0,#0x29
000030  f7fffffe          BL       ior
000034  ea422200          ORR      r2,r2,r0,LSL #8
;;;456    	check_device |= ior(DM9000_REG_PID_L) << 16;
000038  202a              MOVS     r0,#0x2a
00003a  f7fffffe          BL       ior
00003e  ea424200          ORR      r2,r2,r0,LSL #16
;;;457    	check_device |= ior(DM9000_REG_PID_H) << 24;
000042  202b              MOVS     r0,#0x2b
000044  f7fffffe          BL       ior
;;;458    
;;;459    	if(check_device != 0x90000A46)
000048  497d              LDR      r1,|L4.576|
00004a  ea426000          ORR      r0,r2,r0,LSL #24      ;457
00004e  4288              CMP      r0,r1
000050  d003              BEQ      |L4.90|
;;;460    	{
;;;461    		printk("DM9K_DEBUG ==> DEIVCE NOT FOUND, SYSTEM HOLD !!\n");
000052  a07c              ADR      r0,|L4.580|
000054  f7fffffe          BL       __2printf
                  |L4.88|
;;;462    		while(1);
000058  e7fe              B        |L4.88|
                  |L4.90|
;;;463    	}
;;;464    	else
;;;465    	{
;;;466    		printk("DM9K_DEBUG ==> DEIVCE FOUND !!\n");
00005a  a087              ADR      r0,|L4.632|
00005c  f7fffffe          BL       __2printf
;;;467    	}
;;;468    
;;;469    	check_iomode = ior(DM9000_REG_ISR) >> 6;
000060  20fe              MOVS     r0,#0xfe
000062  f7fffffe          BL       ior
000066  0980              LSRS     r0,r0,#6
;;;470    	if(check_iomode != DM9000_WORD_MODE)
000068  d003              BEQ      |L4.114|
;;;471    	{
;;;472    		printk("DM9K_DEBUG ==> DEIVCE NOT WORD MODE, SYSTEM HOLD !!\n");
00006a  a08b              ADR      r0,|L4.664|
00006c  f7fffffe          BL       __2printf
                  |L4.112|
;;;473    		while(1);
000070  e7fe              B        |L4.112|
                  |L4.114|
;;;474    	}
;;;475    	else
;;;476    	{
;;;477    		printk("DM9K_DEBUG ==> DEIVCE IS WORD MODE !!\n");
000072  a097              ADR      r0,|L4.720|
000074  f7fffffe          BL       __2printf
;;;478    	}
;;;479    
;;;480    	printk("DM9K_DEBUG ==> REGISTER R/W TEST !!\n");
000078  a09f              ADR      r0,|L4.760|
00007a  f7fffffe          BL       __2printf
;;;481    	NET_REG_ADDR = DM9000_REG_MAR;
00007e  2016              MOVS     r0,#0x16
000080  8020              STRH     r0,[r4,#0]
;;;482    	for(i = 0; i < 0x0100; i++)
000082  2600              MOVS     r6,#0
                  |L4.132|
;;;483    	{
;;;484    		NET_REG_DATA = i;
000084  8126              STRH     r6,[r4,#8]
;;;485    		if(i != (NET_REG_DATA & 0xff))
000086  8920              LDRH     r0,[r4,#8]
000088  b2c0              UXTB     r0,r0
00008a  42b0              CMP      r0,r6
00008c  d005              BEQ      |L4.154|
;;;486    		{
;;;487    			printk("             > error W %02x , R %02x \n", i , NET_REG_DATA);
00008e  8922              LDRH     r2,[r4,#8]
000090  4631              MOV      r1,r6
000092  a0a3              ADR      r0,|L4.800|
000094  f7fffffe          BL       __2printf
;;;488    			check_reg_fail = 1;
000098  2701              MOVS     r7,#1
                  |L4.154|
00009a  1c76              ADDS     r6,r6,#1              ;482
00009c  b2b6              UXTH     r6,r6                 ;482
00009e  2eff              CMP      r6,#0xff              ;482
0000a0  d9f0              BLS      |L4.132|
;;;489    		}
;;;490    	}
;;;491    
;;;492    	if(check_reg_fail)
0000a2  b11f              CBZ      r7,|L4.172|
;;;493    	{
;;;494    		printk("DM9K_DEBUG ==> REGISTER R/W FAIL, SYSTEM HOLD !!\n");
0000a4  a0a8              ADR      r0,|L4.840|
0000a6  f7fffffe          BL       __2printf
                  |L4.170|
;;;495    		while(1);
0000aa  e7fe              B        |L4.170|
                  |L4.172|
;;;496    	}
;;;497    
;;;498    	printk("DM9K_DEBUG ==> FIFO R/W TEST !!\n");
0000ac  a0b3              ADR      r0,|L4.892|
0000ae  f7fffffe          BL       __2printf
;;;499    	printk("DM9K_DEBUG ==> FIFO WRITE START POINT 0x%02x%02x \n",
0000b2  20fa              MOVS     r0,#0xfa
0000b4  f7fffffe          BL       ior
0000b8  4602              MOV      r2,r0
0000ba  20fb              MOVS     r0,#0xfb
0000bc  f7fffffe          BL       ior
0000c0  4601              MOV      r1,r0
0000c2  a0b7              ADR      r0,|L4.928|
0000c4  f7fffffe          BL       __2printf
;;;500    			ior(DM9000_REG_MWRH), ior(DM9000_REG_MWRL));
;;;501    
;;;502    	NET_REG_ADDR = DM9000_REG_MWCMD;
0000c8  26f8              MOVS     r6,#0xf8
0000ca  8026              STRH     r6,[r4,#0]
;;;503    	for(i = 0; i < 0x1000; i++)
0000cc  2000              MOVS     r0,#0
0000ce  f44f5780          MOV      r7,#0x1000
                  |L4.210|
;;;504    		NET_REG_DATA = ((i & 0xff) * 0x0101);
0000d2  b2c1              UXTB     r1,r0
0000d4  eb012101          ADD      r1,r1,r1,LSL #8
0000d8  8121              STRH     r1,[r4,#8]
0000da  1c40              ADDS     r0,r0,#1              ;503
0000dc  b280              UXTH     r0,r0                 ;503
0000de  42b8              CMP      r0,r7                 ;503
0000e0  d3f7              BCC      |L4.210|
;;;505    
;;;506    	printk("DM9K_DEBUG ==> FIFO WRITE END POINT 0x%02x%02x \n",
0000e2  20fa              MOVS     r0,#0xfa
0000e4  f7fffffe          BL       ior
0000e8  4602              MOV      r2,r0
0000ea  20fb              MOVS     r0,#0xfb
0000ec  f7fffffe          BL       ior
0000f0  4601              MOV      r1,r0
0000f2  a0b8              ADR      r0,|L4.980|
0000f4  f7fffffe          BL       __2printf
;;;507    			ior(DM9000_REG_MWRH), ior(DM9000_REG_MWRL));
;;;508    
;;;509    	if((ior(DM9000_REG_MWRH) != 0x20) || (ior(DM9000_REG_MWRL) != 0x00))
0000f8  20fb              MOVS     r0,#0xfb
0000fa  f7fffffe          BL       ior
0000fe  2820              CMP      r0,#0x20
000100  d103              BNE      |L4.266|
000102  20fa              MOVS     r0,#0xfa
000104  f7fffffe          BL       ior
000108  b118              CBZ      r0,|L4.274|
                  |L4.266|
;;;510    	{
;;;511    		printk("DM9K_DEBUG ==> FIFO WRITE FAIL, SYSTEM HOLD !!\n");
00010a  a0bf              ADR      r0,|L4.1032|
00010c  f7fffffe          BL       __2printf
                  |L4.272|
;;;512    		while(1);
000110  e7fe              B        |L4.272|
                  |L4.274|
;;;513    	}
;;;514    
;;;515    	ior(DM9000_REG_MRCMDX);
000112  20f0              MOVS     r0,#0xf0
000114  f7fffffe          BL       ior
;;;516    	printk("DM9K_DEBUG ==> FIFO READ START POINT 0x%02x%02x \n",
000118  20f4              MOVS     r0,#0xf4
00011a  f7fffffe          BL       ior
00011e  4602              MOV      r2,r0
000120  20f5              MOVS     r0,#0xf5
000122  f7fffffe          BL       ior
000126  4601              MOV      r1,r0
000128  a0c3              ADR      r0,|L4.1080|
00012a  f7fffffe          BL       __2printf
;;;517    			ior(DM9000_REG_MRRH), ior(DM9000_REG_MRRL));
;;;518    	ior(DM9000_REG_MRCMDX);
00012e  20f0              MOVS     r0,#0xf0
000130  f7fffffe          BL       ior
;;;519    
;;;520    	NET_REG_ADDR = DM9000_REG_MRCMD;
000134  20f2              MOVS     r0,#0xf2
000136  8020              STRH     r0,[r4,#0]
;;;521    	for(i = 0; i < 0x1000; i++)
000138  2000              MOVS     r0,#0
                  |L4.314|
;;;522    	{
;;;523    		j = NET_REG_DATA;
00013a  8921              LDRH     r1,[r4,#8]
;;;524    
;;;525    		if(((i & 0xff) * 0x0101) != j)
00013c  b2c2              UXTB     r2,r0
00013e  eb022202          ADD      r2,r2,r2,LSL #8
000142  428a              CMP      r2,r1
000144  d000              BEQ      |L4.328|
;;;526    		{
;;;527    			//printk("             > error W %04x , R %04x \n",
;;;528    			//		((i & 0xff) * 0x0101) , j);
;;;529    			check_fifo_fail = 1;
000146  2501              MOVS     r5,#1
                  |L4.328|
000148  1c40              ADDS     r0,r0,#1              ;521
00014a  b280              UXTH     r0,r0                 ;521
00014c  42b8              CMP      r0,r7                 ;521
00014e  d3f4              BCC      |L4.314|
;;;530    		}
;;;531    	}
;;;532    
;;;533    	printk("DM9K_DEBUG ==> FIFO READ END POINT 0x%02x%02x \n",
000150  20f4              MOVS     r0,#0xf4
000152  f7fffffe          BL       ior
000156  4602              MOV      r2,r0
000158  20f5              MOVS     r0,#0xf5
00015a  f7fffffe          BL       ior
00015e  4601              MOV      r1,r0
000160  a0c2              ADR      r0,|L4.1132|
000162  f7fffffe          BL       __2printf
;;;534    			ior(DM9000_REG_MRRH), ior(DM9000_REG_MRRL));
;;;535    
;;;536    	if((ior(DM9000_REG_MRRH) != 0x20) || (ior(DM9000_REG_MRRL) != 0x00))
000166  20f5              MOVS     r0,#0xf5
000168  f7fffffe          BL       ior
00016c  2820              CMP      r0,#0x20
00016e  d103              BNE      |L4.376|
000170  20f4              MOVS     r0,#0xf4
000172  f7fffffe          BL       ior
000176  b118              CBZ      r0,|L4.384|
                  |L4.376|
;;;537    	{
;;;538    		printk("DM9K_DEBUG ==> FIFO WRITE FAIL, SYSTEM HOLD !!\n");
000178  a0a3              ADR      r0,|L4.1032|
00017a  f7fffffe          BL       __2printf
                  |L4.382|
;;;539    		while(1);
00017e  e7fe              B        |L4.382|
                  |L4.384|
;;;540    	}
;;;541    
;;;542    		if(check_fifo_fail)
000180  b11d              CBZ      r5,|L4.394|
;;;543    	{
;;;544    		printk("DM9K_DEBUG ==> FIFO R/W DATA FAIL, SYSTEM HOLD !!\n");
000182  a0c6              ADR      r0,|L4.1180|
000184  f7fffffe          BL       __2printf
                  |L4.392|
;;;545    		while(1);
000188  e7fe              B        |L4.392|
                  |L4.394|
;;;546    	}
;;;547    
;;;548    	printk("DM9K_DEBUG ==> PACKET SEND & INT TEST !! \n");
00018a  a0d1              ADR      r0,|L4.1232|
00018c  f7fffffe          BL       __2printf
000190  464b              MOV      r3,r9
000192  f8a49000          STRH     r9,[r4,#0]
000196  4645              MOV      r5,r8
000198  f8a48008          STRH     r8,[r4,#8]
;;;549    	iow(DM9000_REG_NCR, DM9000_REG_RESET);
;;;550    	dm9k_udelay(10);
00019c  200a              MOVS     r0,#0xa
00019e  f7fffffe          BL       dm9k_udelay
0001a2  8023              STRH     r3,[r4,#0]
0001a4  8125              STRH     r5,[r4,#8]
;;;551    	iow(DM9000_REG_NCR, DM9000_REG_RESET);
;;;552    	dm9k_udelay(10);
0001a6  200a              MOVS     r0,#0xa
0001a8  f7fffffe          BL       dm9k_udelay
0001ac  20ff              MOVS     r0,#0xff
0001ae  8020              STRH     r0,[r4,#0]
0001b0  2082              MOVS     r0,#0x82
0001b2  8120              STRH     r0,[r4,#8]
0001b4  20fd              MOVS     r0,#0xfd
0001b6  8020              STRH     r0,[r4,#0]
0001b8  2701              MOVS     r7,#1
0001ba  8127              STRH     r7,[r4,#8]
0001bc  20fc              MOVS     r0,#0xfc
0001be  8020              STRH     r0,[r4,#0]
0001c0  8123              STRH     r3,[r4,#8]
0001c2  f04f09fe          MOV      r9,#0xfe              ;469
;;;553    
;;;554    	iow(DM9000_REG_IMR, DM9000_IMR_OFF | DM9000_TX_INTR);
;;;555    
;;;556    	iow(DM9000_REG_TXPLH, 0x01);
;;;557    	iow(DM9000_REG_TXPLL, 0x00);
;;;558    
;;;559    	do
;;;560    	{
;;;561    		iow(DM9000_REG_ISR, DM9000_TX_INTR);
;;;562    		printk("DM9K_DEBUG ==> INT PIN IS OFF\n");
;;;563    
;;;564    		NET_REG_ADDR = DM9000_REG_MWCMD;
;;;565    		for(i = 0; i < (0x0100 / 2); i++)
;;;566    		{
;;;567    			if(i < 3)
;;;568    				NET_REG_DATA = 0xffff;
0001c6  f64f78ff          MOV      r8,#0xffff
0001ca  2502              MOVS     r5,#2
                  |L4.460|
0001cc  f8a49000          STRH     r9,[r4,#0]
0001d0  8125              STRH     r5,[r4,#8]
0001d2  a0ca              ADR      r0,|L4.1276|
0001d4  f7fffffe          BL       __2printf
0001d8  8026              STRH     r6,[r4,#0]            ;564
0001da  2000              MOVS     r0,#0                 ;565
0001dc  4641              MOV      r1,r8
0001de  e001              B        |L4.484|
                  |L4.480|
0001e0  2803              CMP      r0,#3                 ;567
0001e2  d201              BCS      |L4.488|
                  |L4.484|
0001e4  8121              STRH     r1,[r4,#8]
0001e6  e002              B        |L4.494|
                  |L4.488|
;;;569    			else
;;;570    				NET_REG_DATA = i * 0x0101;
0001e8  eb002200          ADD      r2,r0,r0,LSL #8
0001ec  8122              STRH     r2,[r4,#8]
                  |L4.494|
0001ee  1c40              ADDS     r0,r0,#1              ;565
0001f0  b280              UXTH     r0,r0                 ;565
0001f2  2880              CMP      r0,#0x80              ;565
0001f4  d3f4              BCC      |L4.480|
;;;571    		}
;;;572    
;;;573    		printk("DM9K_DEBUG ==> PACKET IS SEND \n");
0001f6  a0c9              ADR      r0,|L4.1308|
0001f8  f7fffffe          BL       __2printf
0001fc  8025              STRH     r5,[r4,#0]
0001fe  8127              STRH     r7,[r4,#8]
;;;574    		iow(DM9000_REG_TCR, DM9000_TCR_SET);
;;;575    
;;;576    		while(ior(DM9000_REG_TCR) & DM9000_TCR_SET) dm9k_udelay (5);
000200  e002              B        |L4.520|
                  |L4.514|
000202  2005              MOVS     r0,#5
000204  f7fffffe          BL       dm9k_udelay
                  |L4.520|
000208  2002              MOVS     r0,#2
00020a  f7fffffe          BL       ior
00020e  07c0              LSLS     r0,r0,#31
000210  d1f7              BNE      |L4.514|
;;;577    		if(ior(DM9000_REG_ISR) & DM9000_TX_INTR)
000212  20fe              MOVS     r0,#0xfe
000214  f7fffffe          BL       ior
000218  0780              LSLS     r0,r0,#30
00021a  d501              BPL      |L4.544|
;;;578    			printk("DM9K_DEBUG ==> INT PIN IS ACTIVE \n");
00021c  a0c7              ADR      r0,|L4.1340|
00021e  e000              B        |L4.546|
                  |L4.544|
;;;579    		else
;;;580    			printk("DM9K_DEBUG ==> INT PIN IS NOT ACTIVE \n");
000220  a0cf              ADR      r0,|L4.1376|
                  |L4.546|
000222  f7fffffe          BL       __2printf
;;;581    
;;;582    		for(i = 0; i < 10; i++)
000226  2300              MOVS     r3,#0
;;;583    			dm9k_udelay(1000);
000228  f44f7a7a          MOV      r10,#0x3e8
                  |L4.556|
00022c  4650              MOV      r0,r10
00022e  f7fffffe          BL       dm9k_udelay
000232  1c5b              ADDS     r3,r3,#1              ;582
000234  b29b              UXTH     r3,r3                 ;582
000236  2b0a              CMP      r3,#0xa               ;582
000238  d3f8              BCC      |L4.556|
00023a  e7c7              B        |L4.460|
;;;584    
;;;585    	}while(1);
;;;586    }
;;;587    
                          ENDP

                  |L4.572|
                          DCD      0x6c100000
                  |L4.576|
                          DCD      0x90000a46
                  |L4.580|
000244  444d394b          DCB      "DM9K_DEBUG ==> DEIVCE NOT FOUND, SYSTEM HOLD !!\n",0
000248  5f444542
00024c  5547203d
000250  3d3e2044
000254  45495643
000258  45204e4f
00025c  5420464f
000260  554e442c
000264  20535953
000268  54454d20
00026c  484f4c44
000270  2021210a
000274  00      
000275  00                DCB      0
000276  00                DCB      0
000277  00                DCB      0
                  |L4.632|
000278  444d394b          DCB      "DM9K_DEBUG ==> DEIVCE FOUND !!\n",0
00027c  5f444542
000280  5547203d
000284  3d3e2044
000288  45495643
00028c  4520464f
000290  554e4420
000294  21210a00
                  |L4.664|
000298  444d394b          DCB      "DM9K_DEBUG ==> DEIVCE NOT WORD MODE, SYSTEM HOLD !!\n",0
00029c  5f444542
0002a0  5547203d
0002a4  3d3e2044
0002a8  45495643
0002ac  45204e4f
0002b0  5420574f
0002b4  5244204d
0002b8  4f44452c
0002bc  20535953
0002c0  54454d20
0002c4  484f4c44
0002c8  2021210a
0002cc  00      
0002cd  00                DCB      0
0002ce  00                DCB      0
0002cf  00                DCB      0
                  |L4.720|
0002d0  444d394b          DCB      "DM9K_DEBUG ==> DEIVCE IS WORD MODE !!\n",0
0002d4  5f444542
0002d8  5547203d
0002dc  3d3e2044
0002e0  45495643
0002e4  45204953
0002e8  20574f52
0002ec  44204d4f
0002f0  44452021
0002f4  210a00  
0002f7  00                DCB      0
                  |L4.760|
0002f8  444d394b          DCB      "DM9K_DEBUG ==> REGISTER R/W TEST !!\n",0
0002fc  5f444542
000300  5547203d
000304  3d3e2052
000308  45474953
00030c  54455220
000310  522f5720
000314  54455354
000318  2021210a
00031c  00      
00031d  00                DCB      0
00031e  00                DCB      0
00031f  00                DCB      0
                  |L4.800|
000320  20202020          DCB      "             > error W %02x , R %02x \n",0
000324  20202020
000328  20202020
00032c  203e2065
000330  72726f72
000334  20572025
000338  30327820
00033c  2c205220
000340  25303278
000344  200a00  
000347  00                DCB      0
                  |L4.840|
000348  444d394b          DCB      "DM9K_DEBUG ==> REGISTER R/W FAIL, SYSTEM HOLD !!\n",0
00034c  5f444542
000350  5547203d
000354  3d3e2052
000358  45474953
00035c  54455220
000360  522f5720
000364  4641494c
000368  2c205359
00036c  5354454d
000370  20484f4c
000374  44202121
000378  0a00    
00037a  00                DCB      0
00037b  00                DCB      0
                  |L4.892|
00037c  444d394b          DCB      "DM9K_DEBUG ==> FIFO R/W TEST !!\n",0
000380  5f444542
000384  5547203d
000388  3d3e2046
00038c  49464f20
000390  522f5720
000394  54455354
000398  2021210a
00039c  00      
00039d  00                DCB      0
00039e  00                DCB      0
00039f  00                DCB      0
                  |L4.928|
0003a0  444d394b          DCB      "DM9K_DEBUG ==> FIFO WRITE START POINT 0x%02x%02x \n",0
0003a4  5f444542
0003a8  5547203d
0003ac  3d3e2046
0003b0  49464f20
0003b4  57524954
0003b8  45205354
0003bc  41525420
0003c0  504f494e
0003c4  54203078
0003c8  25303278
0003cc  25303278
0003d0  200a00  
0003d3  00                DCB      0
                  |L4.980|
0003d4  444d394b          DCB      "DM9K_DEBUG ==> FIFO WRITE END POINT 0x%02x%02x \n",0
0003d8  5f444542
0003dc  5547203d
0003e0  3d3e2046
0003e4  49464f20
0003e8  57524954
0003ec  4520454e
0003f0  4420504f
0003f4  494e5420
0003f8  30782530
0003fc  32782530
000400  3278200a
000404  00      
000405  00                DCB      0
000406  00                DCB      0
000407  00                DCB      0
                  |L4.1032|
000408  444d394b          DCB      "DM9K_DEBUG ==> FIFO WRITE FAIL, SYSTEM HOLD !!\n",0
00040c  5f444542
000410  5547203d
000414  3d3e2046
000418  49464f20
00041c  57524954
000420  45204641
000424  494c2c20
000428  53595354
00042c  454d2048
000430  4f4c4420
000434  21210a00
                  |L4.1080|
000438  444d394b          DCB      "DM9K_DEBUG ==> FIFO READ START POINT 0x%02x%02x \n",0
00043c  5f444542
000440  5547203d
000444  3d3e2046
000448  49464f20
00044c  52454144
000450  20535441
000454  52542050
000458  4f494e54
00045c  20307825
000460  30327825
000464  30327820
000468  0a00    
00046a  00                DCB      0
00046b  00                DCB      0
                  |L4.1132|
00046c  444d394b          DCB      "DM9K_DEBUG ==> FIFO READ END POINT 0x%02x%02x \n",0
000470  5f444542
000474  5547203d
000478  3d3e2046
00047c  49464f20
000480  52454144
000484  20454e44
000488  20504f49
00048c  4e542030
000490  78253032
000494  78253032
000498  78200a00
                  |L4.1180|
00049c  444d394b          DCB      "DM9K_DEBUG ==> FIFO R/W DATA FAIL, SYSTEM HOLD !!\n",0
0004a0  5f444542
0004a4  5547203d
0004a8  3d3e2046
0004ac  49464f20
0004b0  522f5720
0004b4  44415441
0004b8  20464149
0004bc  4c2c2053
0004c0  59535445
0004c4  4d20484f
0004c8  4c442021
0004cc  210a00  
0004cf  00                DCB      0
                  |L4.1232|
0004d0  444d394b          DCB      "DM9K_DEBUG ==> PACKET SEND & INT TEST !! \n",0
0004d4  5f444542
0004d8  5547203d
0004dc  3d3e2050
0004e0  41434b45
0004e4  54205345
0004e8  4e442026
0004ec  20494e54
0004f0  20544553
0004f4  54202121
0004f8  200a00  
0004fb  00                DCB      0
                  |L4.1276|
0004fc  444d394b          DCB      "DM9K_DEBUG ==> INT PIN IS OFF\n",0
000500  5f444542
000504  5547203d
000508  3d3e2049
00050c  4e542050
000510  494e2049
000514  53204f46
000518  460a00  
00051b  00                DCB      0
                  |L4.1308|
00051c  444d394b          DCB      "DM9K_DEBUG ==> PACKET IS SEND \n",0
000520  5f444542
000524  5547203d
000528  3d3e2050
00052c  41434b45
000530  54204953
000534  2053454e
000538  44200a00
                  |L4.1340|
00053c  444d394b          DCB      "DM9K_DEBUG ==> INT PIN IS ACTIVE \n",0
000540  5f444542
000544  5547203d
000548  3d3e2049
00054c  4e542050
000550  494e2049
000554  53204143
000558  54495645
00055c  200a00  
00055f  00                DCB      0
                  |L4.1376|
000560  444d394b          DCB      "DM9K_DEBUG ==> INT PIN IS NOT ACTIVE \n",0
000564  5f444542
000568  5547203d
00056c  3d3e2049
000570  4e542050
000574  494e2049
000578  53204e4f
00057c  54204143
000580  54495645
000584  200a00  
000587  00                DCB      0

                          AREA ||i.dm9k_hash_table||, CODE, READONLY, ALIGN=2

                  dm9k_hash_table PROC
;;;119    */
;;;120    void dm9k_hash_table(void)
000000  b510              PUSH     {r4,lr}
;;;121    {
;;;122    	uint8_t i;
;;;123    
;;;124    	/* 将MAC地址告诉uip */
;;;125    	for (i = 0; i < 6; i++)
;;;126    	{
;;;127    		uip_ethaddr.addr[i] = DEF_MAC_ADDR[i];
000002  4912              LDR      r1,|L5.76|
000004  4c12              LDR      r4,|L5.80|
000006  2000              MOVS     r0,#0                 ;125
                  |L5.8|
000008  5c22              LDRB     r2,[r4,r0]
00000a  540a              STRB     r2,[r1,r0]
00000c  1c40              ADDS     r0,r0,#1              ;125
00000e  b2c0              UXTB     r0,r0                 ;125
000010  2806              CMP      r0,#6                 ;125
000012  d3f9              BCC      |L5.8|
;;;128    	}
;;;129    
;;;130    	/* 设置 网卡 MAC 位置，来自於 MyHardware */
;;;131    	for(i = 0; i < 6; i++)
000014  2300              MOVS     r3,#0
                  |L5.22|
;;;132    		iow(DM9000_REG_PAR + i, DEF_MAC_ADDR[i]);
000016  f1030010          ADD      r0,r3,#0x10
00001a  5ce1              LDRB     r1,[r4,r3]
00001c  b2c0              UXTB     r0,r0
00001e  f7fffffe          BL       iow
000022  1c5b              ADDS     r3,r3,#1              ;131
000024  b2db              UXTB     r3,r3                 ;131
000026  2b06              CMP      r3,#6                 ;131
000028  d3f5              BCC      |L5.22|
;;;133    
;;;134    	for(i = 0; i < 8; i++) 								/* 清除 网卡多播设置 */
00002a  2000              MOVS     r0,#0
00002c  4909              LDR      r1,|L5.84|
00002e  4603              MOV      r3,r0                 ;125
                  |L5.48|
;;;135    		iow(DM9000_REG_MAR + i, 0x00);
000030  f1000216          ADD      r2,r0,#0x16
000034  b2d2              UXTB     r2,r2
000036  800a              STRH     r2,[r1,#0]
000038  810b              STRH     r3,[r1,#8]
00003a  1c40              ADDS     r0,r0,#1              ;134
00003c  b2c0              UXTB     r0,r0                 ;134
00003e  2808              CMP      r0,#8                 ;134
000040  d3f6              BCC      |L5.48|
000042  201d              MOVS     r0,#0x1d              ;134
000044  8008              STRH     r0,[r1,#0]            ;134
000046  2080              MOVS     r0,#0x80              ;134
000048  8108              STRH     r0,[r1,#8]            ;134
;;;136    	iow(DM9000_REG_MAR + 7, 0x80);  					/* 速设置 广播包 设置 */
;;;137    }
00004a  bd10              POP      {r4,pc}
;;;138    
                          ENDP

                  |L5.76|
                          DCD      uip_ethaddr
                  |L5.80|
                          DCD      ||.data||+0x2
                  |L5.84|
                          DCD      0x6c100000

                          AREA ||i.dm9k_initnic||, CODE, READONLY, ALIGN=2

                  dm9k_initnic PROC
;;;209    */
;;;210    void dm9k_initnic(void)
000000  b570              PUSH     {r4-r6,lr}
000002  4c10              LDR      r4,|L6.68|
000004  2500              MOVS     r5,#0
000006  8025              STRH     r5,[r4,#0]
000008  2003              MOVS     r0,#3
00000a  8120              STRH     r0,[r4,#8]
;;;211    {
;;;212    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
;;;213    	dm9k_udelay(10);								/* delay 10us */
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       dm9k_udelay
;;;214    
;;;215    	dm9k_hash_table();								/* 设置 DM9000A MAC 及 多播*/
000012  f7fffffe          BL       dm9k_hash_table
;;;216    
;;;217    	dm9k_reset();									/* 进行 DM9000A 软件设置 */
000016  f7fffffe          BL       dm9k_reset
00001a  261f              MOVS     r6,#0x1f
00001c  8026              STRH     r6,[r4,#0]
00001e  2001              MOVS     r0,#1
000020  8120              STRH     r0,[r4,#8]
;;;218    
;;;219    	iow(DM9000_REG_GPR, DM9000_PHY_OFF);			/* 关闭 PHY ，进行 PHY 设置*/
;;;220    	dm9k_phy_write(0x00, 0x8000);					/* 重置 PHY 的寄存器 */
000022  03c1              LSLS     r1,r0,#15
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       dm9k_phy_write
;;;221    #ifdef DM9000A_FLOW_CONTROL
;;;222    	dm9k_phy_write(0x04, 0x01e1 | 0x0400);			/* 设置 自适应模式相容表 */
;;;223    #else
;;;224    	dm9k_phy_write(0x04, 0x01e1);					/* 设置 自适应模式相容表 */
00002a  f24011e1          MOV      r1,#0x1e1
00002e  2004              MOVS     r0,#4
000030  f7fffffe          BL       dm9k_phy_write
;;;225    #endif
;;;226    	//dm9k_phy_write(0x00, 0x1000);					/* 设置 基本连接模式 */
;;;227    	/* 连接模式设置
;;;228    	  0x0000 : 固定10M半双工
;;;229    	  0x0100 : 固定10M全双工
;;;230    	  0x2000 : 固定100M半双工
;;;231    	  0x2100 : 固定100M全双工
;;;232    	  0x1000 : 自适应模式
;;;233    	*/
;;;234    	dm9k_phy_write(0x00, 0x1000);				/* 设置 基本连接模式 */
000034  f44f5180          MOV      r1,#0x1000
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       dm9k_phy_write
00003e  8026              STRH     r6,[r4,#0]
000040  8125              STRH     r5,[r4,#8]
;;;235    
;;;236    	iow(DM9000_REG_GPR, DM9000_PHY_ON);				/* 结束 PHY 设置, 开启 PHY */
;;;237    
;;;238    	//dm9k_debug_test();
;;;239    }
000042  bd70              POP      {r4-r6,pc}
;;;240    
                          ENDP

                  |L6.68|
                          DCD      0x6c100000

                          AREA ||i.dm9k_interrupt||, CODE, READONLY, ALIGN=2

                  dm9k_interrupt PROC
;;;411    */
;;;412    void  dm9k_interrupt(void)
000000  4a07              LDR      r2,|L7.32|
;;;413    {
000002  b510              PUSH     {r4,lr}
;;;414    	uint8_t  save_reg;
;;;415    	uint8_t  isr_status;
;;;416    
;;;417    	save_reg = NET_REG_ADDR;							/* 暂存所使用的位置 */
000004  8810              LDRH     r0,[r2,#0]
000006  24ff              MOVS     r4,#0xff
000008  b2c3              UXTB     r3,r0
00000a  8014              STRH     r4,[r2,#0]
00000c  2080              MOVS     r0,#0x80
00000e  8110              STRH     r0,[r2,#8]
;;;418    
;;;419    	iow(DM9000_REG_IMR , DM9000_IMR_OFF);				/* 关闭 DM9000A 中断 */
;;;420    	isr_status = ior(DM9000_REG_ISR);					/* 取得中断产生值 */
000010  20fe              MOVS     r0,#0xfe
000012  f7fffffe          BL       ior
000016  8014              STRH     r4,[r2,#0]
000018  2081              MOVS     r0,#0x81
00001a  8110              STRH     r0,[r2,#8]
;;;421    
;;;422    #if 1  /* armfly */
;;;423    
;;;424    #else
;;;425    	if(isr_status & DM9000_RX_INTR) 					/* 检查是否为接收中断 */
;;;426    		dm9k_receive_packet();							/* 执行接收处理程序 */
;;;427    #endif
;;;428    
;;;429    	iow(DM9000_REG_IMR , DM9000_IMR_SET);				/* 开启 DM9000A 中断 */
;;;430    	NET_REG_ADDR = save_reg;							/* 回复所使用的位置 */
00001c  8013              STRH     r3,[r2,#0]
;;;431    
;;;432    }
00001e  bd10              POP      {r4,pc}
;;;433    
                          ENDP

                  |L7.32|
                          DCD      0x6c100000

                          AREA ||i.dm9k_phy_write||, CODE, READONLY, ALIGN=2

                  dm9k_phy_write PROC
;;;189    */
;;;190    void dm9k_phy_write(uint8_t phy_reg, uint16_t writedata)
000000  4a0d              LDR      r2,|L8.56|
;;;191    {
000002  b500              PUSH     {lr}
000004  230c              MOVS     r3,#0xc
;;;192    	/* 设置写入 PHY 寄存器的位置 */
;;;193    	iow(DM9000_REG_EPAR, phy_reg | DM9000_PHY);
000006  f0400040          ORR      r0,r0,#0x40
00000a  8013              STRH     r3,[r2,#0]
00000c  8110              STRH     r0,[r2,#8]
;;;194    
;;;195    	/* 设置写入 PHY 寄存器的值 */
;;;196    	iow(DM9000_REG_EPDRH, ( writedata >> 8 ) & 0xff);
00000e  0a08              LSRS     r0,r1,#8
000010  230e              MOVS     r3,#0xe
000012  8013              STRH     r3,[r2,#0]
000014  8110              STRH     r0,[r2,#8]
;;;197    	iow(DM9000_REG_EPDRL, writedata & 0xff);
000016  b2c8              UXTB     r0,r1
000018  210d              MOVS     r1,#0xd
00001a  8011              STRH     r1,[r2,#0]
00001c  8110              STRH     r0,[r2,#8]
00001e  230b              MOVS     r3,#0xb
000020  8013              STRH     r3,[r2,#0]
000022  200a              MOVS     r0,#0xa
000024  8110              STRH     r0,[r2,#8]
                  |L8.38|
;;;198    
;;;199    	iow(DM9000_REG_EPCR, 0x0a); 						/* 将资料写入 PHY 寄存器 */
;;;200    	while(ior(DM9000_REG_EPCR) & 0x01);					/* 查寻是否执行结束 */
000026  200b              MOVS     r0,#0xb
000028  f7fffffe          BL       ior
00002c  07c0              LSLS     r0,r0,#31
00002e  d1fa              BNE      |L8.38|
000030  8013              STRH     r3,[r2,#0]
000032  2008              MOVS     r0,#8
000034  8110              STRH     r0,[r2,#8]
;;;201    	iow(DM9000_REG_EPCR, 0x08); 						/* 清除写入命令 */
;;;202    }
000036  bd00              POP      {pc}
;;;203    
                          ENDP

                  |L8.56|
                          DCD      0x6c100000

                          AREA ||i.dm9k_receive_packet||, CODE, READONLY, ALIGN=2

                  dm9k_receive_packet PROC
;;;246    */
;;;247    uint16_t dm9k_receive_packet(uint8_t *_uip_buf)
000000  b570              PUSH     {r4-r6,lr}
;;;248    {
;;;249    	uint16_t ReceiveLength;
;;;250    	uint16_t *ReceiveData;
;;;251    	uint8_t  rx_int_count = 0;
;;;252    	uint8_t  rx_checkbyte;
;;;253    	uint16_t rx_status, rx_length;
;;;254    	uint8_t  jump_packet;
;;;255    	uint16_t i;
;;;256    	uint16_t calc_len;
;;;257    	uint16_t calc_MRR;
;;;258    
;;;259    	do
;;;260    	{
;;;261    		ReceiveLength = 0;								/* 清除接收的长度 */
;;;262    		ReceiveData = (uint16_t *)_uip_buf;
;;;263    		jump_packet = 0;								/* 清除跳包动作 */
;;;264    		ior(DM9000_REG_MRCMDX);							/* 读取内存数据，地址不增加 */
;;;265    		/* 计算内存数据位置 */
;;;266    		calc_MRR = (ior(DM9000_REG_MRRH) << 8) + ior(DM9000_REG_MRRL);
;;;267    		rx_checkbyte = ior(DM9000_REG_MRCMDX);			/*  */
;;;268    
;;;269    		if(rx_checkbyte == DM9000_PKT_RDY)				/* 取 */
;;;270    		{
;;;271    			/* 读取封包相关资讯 及 长度 */
;;;272    			NET_REG_ADDR = DM9000_REG_MRCMD;
000002  4a2a              LDR      r2,|L9.172|
000004  4604              MOV      r4,r0                 ;248
                  |L9.6|
000006  2300              MOVS     r3,#0                 ;263
000008  20f0              MOVS     r0,#0xf0              ;264
00000a  f7fffffe          BL       ior
00000e  20f4              MOVS     r0,#0xf4              ;266
000010  f7fffffe          BL       ior
000014  4605              MOV      r5,r0                 ;266
000016  20f5              MOVS     r0,#0xf5              ;266
000018  f7fffffe          BL       ior
00001c  eb052000          ADD      r0,r5,r0,LSL #8       ;266
000020  b285              UXTH     r5,r0                 ;266
000022  20f0              MOVS     r0,#0xf0              ;267
000024  f7fffffe          BL       ior
000028  2801              CMP      r0,#1                 ;269
00002a  d004              BEQ      |L9.54|
;;;273    			rx_status = NET_REG_DATA;
;;;274    			rx_length = NET_REG_DATA;
;;;275    
;;;276    			/* 若收到超过系统可承受的封包，此包跳过 */
;;;277    			if(rx_length > Max_Ethernet_Lenth)
;;;278    				jump_packet = 1;
;;;279    
;;;280    #ifdef Broadcast_Jump
;;;281    			/* 若收到的广播或多播包超过特定长度，此包跳过 */
;;;282    			if(rx_status & 0x4000)
;;;283    			{
;;;284    				if(rx_length > Max_Broadcast_Lenth)
;;;285    					jump_packet = 1;
;;;286    			}
;;;287    #endif
;;;288    			/* 计算下一个包的指针位 , 若接收长度为奇数，需加一对齐偶字节。*/
;;;289    			/* 若是超过 0x3fff ，则需回归绕到 0x0c00 起始位置 */
;;;290    			calc_MRR += (rx_length + 4);
;;;291    			if(rx_length & 0x01) calc_MRR++;
;;;292    			if(calc_MRR > 0x3fff) calc_MRR -= 0x3400;
;;;293    
;;;294    			if(jump_packet == 0x01)
;;;295    			{
;;;296    				/* 将指针移到下一个包的包头位置 */
;;;297    				iow (DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;298    				iow (DM9000_REG_MRRL, calc_MRR & 0xff );
;;;299    				continue;
;;;300    			}
;;;301    
;;;302    			/* 开始将内存的资料搬到到系统中，每次移动一个 word */
;;;303    			calc_len = (rx_length + 1) >> 1;
;;;304    			for(i = 0 ; i < calc_len ; i++)
;;;305    				ReceiveData[i] = NET_REG_DATA;
;;;306    
;;;307    			/* 将包长回报给 TCP/IP 上层，并减去最後 4 BYTE 的 CRC-32 检核码 */
;;;308    			ReceiveLength = rx_length - 4;
;;;309    
;;;310    			rx_int_count++;								/* 累计收包次数 */
;;;311    
;;;312    #ifdef FifoPointCheck
;;;313    			if(calc_MRR != ((ior(DM9000_REG_MRRH) << 8) + ior(DM9000_REG_MRRL)))
;;;314    			{
;;;315    #ifdef Point_Error_Reset
;;;316    				dm9k_reset();								/* 若是指针出错，重置 */
;;;317    				return ReceiveLength;
;;;318    #endif
;;;319    				/*若是指针出错，将指针移到下一个包的包头位置  */
;;;320    				iow(DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;321    				iow(DM9000_REG_MRRL, calc_MRR & 0xff);
;;;322    			}
;;;323    #endif
;;;324    			return ReceiveLength;
;;;325    		}
;;;326    		else
;;;327    		{
;;;328    			if(rx_checkbyte == DM9000_PKT_NORDY)		/* 未收到包 */
00002c  b3c0              CBZ      r0,|L9.160|
;;;329    			{
;;;330    				iow(DM9000_REG_ISR, 0x3f);				/*  */
;;;331    			}
;;;332    			else
;;;333    			{
;;;334    				dm9k_reset();								/* 接收指针出错，重置 */
00002e  f7fffffe          BL       dm9k_reset
                  |L9.50|
;;;335    			}
;;;336    			return (0);
000032  2000              MOVS     r0,#0
;;;337    		}
;;;338    	}while(rx_int_count < Max_Int_Count);				/* 是否超过最多接收封包计数 */
;;;339    	return 0;
;;;340    }
000034  bd70              POP      {r4-r6,pc}
                  |L9.54|
000036  20f2              MOVS     r0,#0xf2              ;272
000038  8010              STRH     r0,[r2,#0]            ;272
00003a  8911              LDRH     r1,[r2,#8]            ;273
00003c  8910              LDRH     r0,[r2,#8]            ;274
00003e  f5b06fc0          CMP      r0,#0x600             ;277
000042  d900              BLS      |L9.70|
000044  2301              MOVS     r3,#1                 ;278
                  |L9.70|
000046  0449              LSLS     r1,r1,#17             ;282
000048  d503              BPL      |L9.82|
00004a  f5b07ffa          CMP      r0,#0x1f4             ;284
00004e  d900              BLS      |L9.82|
000050  2301              MOVS     r3,#1                 ;285
                  |L9.82|
000052  1829              ADDS     r1,r5,r0              ;290
000054  1d09              ADDS     r1,r1,#4              ;290
000056  b289              UXTH     r1,r1                 ;290
000058  07c5              LSLS     r5,r0,#31             ;291
00005a  d001              BEQ      |L9.96|
00005c  1c49              ADDS     r1,r1,#1              ;291
00005e  b289              UXTH     r1,r1                 ;291
                  |L9.96|
000060  f5b14f80          CMP      r1,#0x4000            ;292
000064  d302              BCC      |L9.108|
000066  f5a15150          SUB      r1,r1,#0x3400         ;292
00006a  b289              UXTH     r1,r1                 ;292
                  |L9.108|
00006c  2b01              CMP      r3,#1                 ;294
00006e  d003              BEQ      |L9.120|
000070  1c41              ADDS     r1,r0,#1              ;303
000072  084b              LSRS     r3,r1,#1              ;303
000074  2100              MOVS     r1,#0                 ;304
000076  e00e              B        |L9.150|
                  |L9.120|
000078  0a08              LSRS     r0,r1,#8              ;297
00007a  23f5              MOVS     r3,#0xf5              ;297
00007c  8013              STRH     r3,[r2,#0]            ;297
00007e  8110              STRH     r0,[r2,#8]            ;297
000080  b2c8              UXTB     r0,r1                 ;298
000082  21f4              MOVS     r1,#0xf4              ;298
000084  8011              STRH     r1,[r2,#0]            ;298
000086  8110              STRH     r0,[r2,#8]            ;298
000088  e7bd              B        |L9.6|
                  |L9.138|
00008a  8915              LDRH     r5,[r2,#8]            ;305
00008c  1c4e              ADDS     r6,r1,#1              ;304
00008e  b2b6              UXTH     r6,r6                 ;304
000090  f8245011          STRH     r5,[r4,r1,LSL #1]     ;305
000094  4631              MOV      r1,r6                 ;304
                  |L9.150|
000096  4299              CMP      r1,r3                 ;304
000098  d3f7              BCC      |L9.138|
00009a  1f00              SUBS     r0,r0,#4              ;308
00009c  b280              UXTH     r0,r0                 ;308
00009e  bd70              POP      {r4-r6,pc}
                  |L9.160|
0000a0  e7ff              B        |L9.162|
                  |L9.162|
0000a2  20fe              MOVS     r0,#0xfe
0000a4  8010              STRH     r0,[r2,#0]
0000a6  203f              MOVS     r0,#0x3f
0000a8  8110              STRH     r0,[r2,#8]
0000aa  e7c2              B        |L9.50|
;;;341    
                          ENDP

                  |L9.172|
                          DCD      0x6c100000

                          AREA ||i.dm9k_reset||, CODE, READONLY, ALIGN=2

                  dm9k_reset PROC
;;;144    */
;;;145    void dm9k_reset(void)
000000  b530              PUSH     {r4,r5,lr}
000002  4b14              LDR      r3,|L10.84|
000004  2400              MOVS     r4,#0
000006  801c              STRH     r4,[r3,#0]
000008  2503              MOVS     r5,#3
00000a  811d              STRH     r5,[r3,#8]
;;;146    {
;;;147    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
;;;148    	dm9k_udelay(10);								/* delay 10us */
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       dm9k_udelay
000012  801c              STRH     r4,[r3,#0]
000014  811d              STRH     r5,[r3,#8]
;;;149    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
;;;150    	dm9k_udelay(10);								/* delay 10us */
000016  200a              MOVS     r0,#0xa
000018  f7fffffe          BL       dm9k_udelay
00001c  21ff              MOVS     r1,#0xff
00001e  8019              STRH     r1,[r3,#0]
000020  2080              MOVS     r0,#0x80
000022  8118              STRH     r0,[r3,#8]
000024  222d              MOVS     r2,#0x2d
000026  801a              STRH     r2,[r3,#0]
000028  8118              STRH     r0,[r3,#8]
00002a  2201              MOVS     r2,#1
00002c  801a              STRH     r2,[r3,#0]
00002e  222c              MOVS     r2,#0x2c
000030  811a              STRH     r2,[r3,#8]
000032  2202              MOVS     r2,#2
000034  801a              STRH     r2,[r3,#0]
000036  811c              STRH     r4,[r3,#8]
000038  22fe              MOVS     r2,#0xfe
00003a  801a              STRH     r2,[r3,#0]
00003c  223f              MOVS     r2,#0x3f
00003e  811a              STRH     r2,[r3,#8]
000040  8019              STRH     r1,[r3,#0]
000042  8118              STRH     r0,[r3,#8]
000044  2005              MOVS     r0,#5
000046  8018              STRH     r0,[r3,#0]
000048  2031              MOVS     r0,#0x31
00004a  8118              STRH     r0,[r3,#8]
;;;151    
;;;152    	/* 基本记存器相关设置 */
;;;153    	iow(DM9000_REG_IMR, DM9000_IMR_OFF); 			/* 开启内存自环模式 */
;;;154    	iow(DM9000_REG_TCR2, DM9000_TCR2_SET);			/* 设置 LED 显示模式1:全双工亮，半双工灭 */
;;;155    
;;;156    	/* 清除多余资讯 */
;;;157    	iow(DM9000_REG_NSR, 0x2c);
;;;158    	iow(DM9000_REG_TCR, 0x00);
;;;159    	iow(DM9000_REG_ISR, 0x3f);
;;;160    
;;;161    #ifdef DM9000A_FLOW_CONTROL
;;;162    	iow(DM9000_REG_BPTR, DM9000_BPTR_SET);			/* 半双工流控设置 */
;;;163    	iow(DM9000_REG_FCTR, DM9000_FCTR_SET);			/* 全双工流控设置 */
;;;164    	iow(DM9000_REG_FCR, DM9000_FCR_SET);			/* 开启流控设置 */
;;;165    #endif
;;;166    
;;;167    #ifdef DM9000A_UPTO_100M
;;;168    	/* DM9000A无此寄存器 */
;;;169    	iow(DM9000_REG_OTCR, DM9000_OTCR_SET);			/* 工作频率到 100Mhz 设置 */
;;;170    #endif
;;;171    
;;;172    #ifdef  Rx_Int_enable
;;;173    	iow(DM9000_REG_IMR, DM9000_IMR_SET);			/* 开启 中断模式 */
;;;174    #else
;;;175    	iow(DM9000_REG_IMR, DM9000_IMR_OFF);			/* 关闭 中断模式 */
;;;176    #endif
;;;177    
;;;178    	iow(DM9000_REG_RCR, DM9000_RCR_SET);			/* 开启 接收工能 */
;;;179    
;;;180    	SendPackOk = 0;
00004c  4802              LDR      r0,|L10.88|
00004e  7004              STRB     r4,[r0,#0]
;;;181    }
000050  bd30              POP      {r4,r5,pc}
;;;182    
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      0x6c100000
                  |L10.88|
                          DCD      ||.data||

                          AREA ||i.dm9k_send_packet||, CODE, READONLY, ALIGN=2

                  dm9k_send_packet PROC
;;;348    */
;;;349    void dm9k_send_packet(uint8_t *p_char, uint16_t length)
000000  b530              PUSH     {r4,r5,lr}
;;;350    {
;;;351    	uint16_t SendLength = length;
;;;352    	uint16_t *SendData = (uint16_t *) p_char;
;;;353    	uint16_t i;
;;;354    	uint16_t calc_len;
;;;355    	__IO uint16_t calc_MWR;
;;;356    
;;;357    	/* 检查 DM9000A 是否还在传送中！若是等待直到传送结束 */
;;;358    	if(SendPackOk == Max_Send_Pack)
000002  4d17              LDR      r5,|L11.96|
000004  4604              MOV      r4,r0                 ;352
000006  460b              MOV      r3,r1                 ;351
000008  7828              LDRB     r0,[r5,#0]  ; SendPackOk
00000a  2802              CMP      r0,#2
00000c  d003              BEQ      |L11.22|
00000e  e008              B        |L11.34|
                  |L11.16|
;;;359    	{
;;;360    		while(ior(DM9000_REG_TCR) & DM9000_TCR_SET)
;;;361    		{
;;;362    			dm9k_udelay (5);
000010  2005              MOVS     r0,#5
000012  f7fffffe          BL       dm9k_udelay
                  |L11.22|
000016  2002              MOVS     r0,#2                 ;360
000018  f7fffffe          BL       ior
00001c  07c0              LSLS     r0,r0,#31             ;360
00001e  d1f7              BNE      |L11.16|
;;;363    		}
;;;364    		SendPackOk = 0;
000020  7028              STRB     r0,[r5,#0]
                  |L11.34|
;;;365    	}
;;;366    
;;;367    	SendPackOk++;										/* 设置传送计数 */
000022  b2c0              UXTB     r0,r0
000024  1c40              ADDS     r0,r0,#1
000026  7028              STRB     r0,[r5,#0]
000028  4a0e              LDR      r2,|L11.100|
;;;368    
;;;369    #ifdef FifoPointCheck
;;;370    	/* 计算下一个传送的指针位 , 若接收长度为奇数，需加一对齐偶字节。*/
;;;371    	/* 若是超过 0x0bff ，则需回归绕到 0x0000 起始位置 */
;;;372    	calc_MWR = (ior(DM9000_REG_MWRH) << 8) + ior(DM9000_REG_MWRL);
;;;373    	calc_MWR += SendLength;
;;;374    	if(SendLength & 0x01) calc_MWR++;
;;;375    	if(calc_MWR > 0x0bff) calc_MWR -= 0x0c00;
;;;376    #endif
;;;377    
;;;378    	iow(DM9000_REG_TXPLH, (SendLength >> 8) & 0xff);	/* 设置传送封包的长度 */
00002a  0a18              LSRS     r0,r3,#8
00002c  21fd              MOVS     r1,#0xfd
00002e  8011              STRH     r1,[r2,#0]
000030  8110              STRH     r0,[r2,#8]
000032  21fc              MOVS     r1,#0xfc
;;;379    	iow(DM9000_REG_TXPLL, SendLength & 0xff);
000034  b2d8              UXTB     r0,r3
000036  8011              STRH     r1,[r2,#0]
000038  8110              STRH     r0,[r2,#8]
;;;380    
;;;381    	/* 开始将系统的资料搬到到内存中，每次移动一个 word */
;;;382    	NET_REG_ADDR = DM9000_REG_MWCMD;
00003a  20f8              MOVS     r0,#0xf8
00003c  8010              STRH     r0,[r2,#0]
;;;383    	calc_len = (SendLength + 1) >> 1;
00003e  1c5b              ADDS     r3,r3,#1
000040  0858              LSRS     r0,r3,#1
;;;384    	for(i = 0; i < calc_len; i++)
000042  2100              MOVS     r1,#0
000044  e005              B        |L11.82|
;;;385    		NET_REG_DATA = SendData[i];
000046  bf00              NOP      
                  |L11.72|
000048  f8343011          LDRH     r3,[r4,r1,LSL #1]
00004c  8113              STRH     r3,[r2,#8]
00004e  1c49              ADDS     r1,r1,#1              ;384
000050  b289              UXTH     r1,r1                 ;384
                  |L11.82|
000052  4281              CMP      r1,r0                 ;384
000054  d3f8              BCC      |L11.72|
000056  2002              MOVS     r0,#2                 ;384
000058  8010              STRH     r0,[r2,#0]            ;384
00005a  2001              MOVS     r0,#1                 ;384
00005c  8110              STRH     r0,[r2,#8]            ;384
;;;386    
;;;387    	iow(DM9000_REG_TCR, DM9000_TCR_SET);				/* 进行传送 */
;;;388    
;;;389    #ifdef FifoPointCheck
;;;390    	if(calc_MWR != ((ior(DM9000_REG_MWRH) << 8) + ior(DM9000_REG_MWRL)))
;;;391    	{
;;;392    #ifdef Point_Error_Reset
;;;393    		/* 若是指针出错，等待此一封包送完 , 之後进行重置 */
;;;394    		while(ior(DM9000_REG_TCR) & DM9000_TCR_SET) dm9k_udelay (5);
;;;395    		dm9k_reset();
;;;396    		return;
;;;397    #endif
;;;398    		/*若是指针出错，将指针移到下一个传送包的包头位置  */
;;;399    		iow(DM9000_REG_MWRH, (calc_MWR >> 8) & 0xff);
;;;400    		iow(DM9000_REG_MWRL, calc_MWR & 0xff);
;;;401    	}
;;;402    #endif
;;;403    	return;
;;;404    }
00005e  bd30              POP      {r4,r5,pc}
;;;405    
                          ENDP

                  |L11.96|
                          DCD      ||.data||
                  |L11.100|
                          DCD      0x6c100000

                          AREA ||i.dm9k_udelay||, CODE, READONLY, ALIGN=1

                  dm9k_udelay PROC
;;;77     */
;;;78     void dm9k_udelay(uint16_t time)
000000  2200              MOVS     r2,#0
;;;79     {
;;;80         uint16_t i,k;
;;;81     
;;;82     	for (i = 0; i < time; i++)
000002  e006              B        |L12.18|
                  |L12.4|
;;;83     	{
;;;84     		for (k = 0; k < 80; k++);
000004  2100              MOVS     r1,#0
                  |L12.6|
000006  1c49              ADDS     r1,r1,#1
000008  b289              UXTH     r1,r1
00000a  2950              CMP      r1,#0x50
00000c  d3fb              BCC      |L12.6|
00000e  1c52              ADDS     r2,r2,#1              ;82
000010  b292              UXTH     r2,r2                 ;82
                  |L12.18|
000012  4282              CMP      r2,r0                 ;82
000014  d3f6              BCC      |L12.4|
                  |L12.22|
;;;85     	}
;;;86     	while(time--);
000016  0001              MOVS     r1,r0
000018  f1a00001          SUB      r0,r0,#1
00001c  b280              UXTH     r0,r0
00001e  d1fa              BNE      |L12.22|
;;;87     }
000020  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.etherdev_chkmedia||, CODE, READONLY, ALIGN=1

                  etherdev_chkmedia PROC
;;;627    */
;;;628    void etherdev_chkmedia(void)
000000  b500              PUSH     {lr}
;;;629    {
;;;630    //	uint8_t status;
;;;631    
;;;632    	while(!(ior(DM9000_REG_NSR) & DM9000_PHY))
;;;633    	{
;;;634    		dm9k_udelay(2000);
000002  f44f63fa          MOV      r3,#0x7d0
000006  e002              B        |L13.14|
                  |L13.8|
000008  4618              MOV      r0,r3
00000a  f7fffffe          BL       dm9k_udelay
                  |L13.14|
00000e  2001              MOVS     r0,#1                 ;632
000010  f7fffffe          BL       ior
000014  0640              LSLS     r0,r0,#25             ;632
000016  d5f7              BPL      |L13.8|
;;;635    	}
;;;636    }
000018  bd00              POP      {pc}
;;;637    
                          ENDP


                          AREA ||i.etherdev_init||, CODE, READONLY, ALIGN=2

                  etherdev_init PROC
;;;593    */
;;;594    void etherdev_init(void)
000000  b510              PUSH     {r4,lr}
;;;595    {
;;;596    	DM9K_CtrlLinesConfig();
000002  f7fffffe          BL       DM9K_CtrlLinesConfig
;;;597    	DM9K_FSMCConfig();
000006  f7fffffe          BL       DM9K_FSMCConfig
;;;598    
;;;599    	s_FSMC_Init_Ok = 1;
00000a  4903              LDR      r1,|L14.24|
00000c  2001              MOVS     r0,#1
00000e  7048              STRB     r0,[r1,#1]
;;;600    
;;;601    	dm9k_initnic();
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      dm9k_initnic
;;;602    }
;;;603    
                          ENDP

                  |L14.24|
                          DCD      ||.data||

                          AREA ||i.etherdev_poll||, CODE, READONLY, ALIGN=1

                  etherdev_poll PROC
;;;652    */
;;;653    uint16_t etherdev_poll(void)
000000  2000              MOVS     r0,#0
;;;654    {
;;;655    	uint16_t bytes_read = 0;
;;;656    #if 0
;;;657    
;;;658    	/* tick_count threshold should be 12 for 0.5 sec bail-out
;;;659    		One second (24) worked better for me, but socket recycling
;;;660    		is then slower. I set UIP_TIME_WAIT_TIMEOUT 60 in uipopt.h
;;;661    		to counter this. Retransmission timing etc. is affected also. */
;;;662    	while ((!(bytes_read = etherdev_read())) && (timer0_tick() < 12)) continue;
;;;663    
;;;664    	timer0_reset();
;;;665    
;;;666    #endif
;;;667    	return bytes_read;
;;;668    }
000002  4770              BX       lr
;;;669    
                          ENDP


                          AREA ||i.etherdev_read||, CODE, READONLY, ALIGN=1

                  etherdev_read PROC
;;;615    
;;;616    uint16_t etherdev_read(uint8_t *p_char)
000000  f7ffbffe          B.W      dm9k_receive_packet
;;;617    {
;;;618    	return dm9k_receive_packet(p_char);
;;;619    }
;;;620    
                          ENDP


                          AREA ||i.etherdev_send||, CODE, READONLY, ALIGN=1

                  etherdev_send PROC
;;;610    */
;;;611    void etherdev_send(uint8_t *p_char, uint16_t length)
000000  f7ffbffe          B.W      dm9k_send_packet
;;;612    {
;;;613    	dm9k_send_packet(p_char, length);
;;;614    }
;;;615    
                          ENDP


                          AREA ||i.ior||, CODE, READONLY, ALIGN=2

                  ior PROC
;;;94     */
;;;95     uint8_t ior(uint8_t reg)
000000  4902              LDR      r1,|L18.12|
;;;96     {
;;;97     	NET_REG_ADDR = reg;
000002  8008              STRH     r0,[r1,#0]
;;;98     	return (NET_REG_DATA);
000004  8908              LDRH     r0,[r1,#8]
000006  b2c0              UXTB     r0,r0
;;;99     }
000008  4770              BX       lr
;;;100    
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      0x6c100000

                          AREA ||i.iow||, CODE, READONLY, ALIGN=2

                  iow PROC
;;;107    */
;;;108    void iow(uint8_t reg, uint8_t writedata)
000000  4a01              LDR      r2,|L19.8|
;;;109    {
;;;110    	NET_REG_ADDR = reg;
000002  8010              STRH     r0,[r2,#0]
;;;111    	NET_REG_DATA = writedata;
000004  8111              STRH     r1,[r2,#8]
;;;112    }
000006  4770              BX       lr
;;;113    
                          ENDP

                  |L19.8|
                          DCD      0x6c100000

                          AREA ||.data||, DATA, ALIGN=0

                  SendPackOk
000000  00                DCB      0x00
                  s_FSMC_Init_Ok
000001  00                DCB      0x00
                  DEF_MAC_ADDR
000002  0060              DCB      0x00,0x60
000004  6e9000ae          DCB      0x6e,0x90,0x00,0xae
