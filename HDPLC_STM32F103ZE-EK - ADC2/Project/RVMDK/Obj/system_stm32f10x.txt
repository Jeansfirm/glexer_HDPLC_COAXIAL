; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\system_stm32f10x.o --depend=.\Obj\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Libraries\CMSIS\Core\CM3\system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClockTo72||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;817      */
;;;818    static void SetSysClockTo72(void)
000000  4822              LDR      r0,|L1.140|
;;;819    {
;;;820      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2100              MOVS     r1,#0
;;;821      
;;;822      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;823      /* Enable HSE */    
;;;824      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000004  6802              LDR      r2,[r0,#0]
000006  f4423280          ORR      r2,r2,#0x10000
00000a  6002              STR      r2,[r0,#0]
;;;825     
;;;826      /* Wait till HSE is ready and if Time out is reached exit */
;;;827      do
;;;828      {
;;;829        HSEStatus = RCC->CR & RCC_CR_HSERDY;
;;;830        StartUpCounter++;  
;;;831      } while((HSEStatus == 0) && (StartUpCounter != HSEStartUp_TimeOut));
00000c  f44f63a0          MOV      r3,#0x500
                  |L1.16|
000010  6802              LDR      r2,[r0,#0]            ;829
000012  1c49              ADDS     r1,r1,#1              ;830
000014  f4123f00          TST      r2,#0x20000           ;829
000018  d101              BNE      |L1.30|
00001a  4299              CMP      r1,r3
00001c  d1f8              BNE      |L1.16|
                  |L1.30|
;;;832    
;;;833      if ((RCC->CR & RCC_CR_HSERDY) != RESET)
00001e  6801              LDR      r1,[r0,#0]
000020  0389              LSLS     r1,r1,#14
000022  d531              BPL      |L1.136|
;;;834      {
;;;835        HSEStatus = (uint32_t)0x01;
;;;836      }
;;;837      else
;;;838      {
;;;839        HSEStatus = (uint32_t)0x00;
;;;840      }  
;;;841    
;;;842      if (HSEStatus == (uint32_t)0x01)
;;;843      {
;;;844        /* Enable Prefetch Buffer */
;;;845        FLASH->ACR |= FLASH_ACR_PRFTBE;
000024  491a              LDR      r1,|L1.144|
000026  680a              LDR      r2,[r1,#0]
000028  f0420210          ORR      r2,r2,#0x10
00002c  600a              STR      r2,[r1,#0]
;;;846    
;;;847        /* Flash 2 wait state */
;;;848        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
00002e  680a              LDR      r2,[r1,#0]
000030  f0220203          BIC      r2,r2,#3
000034  600a              STR      r2,[r1,#0]
;;;849        FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000036  680a              LDR      r2,[r1,#0]
000038  f0420202          ORR      r2,r2,#2
00003c  600a              STR      r2,[r1,#0]
;;;850    
;;;851     
;;;852        /* HCLK = SYSCLK */
;;;853        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
00003e  6841              LDR      r1,[r0,#4]
000040  6041              STR      r1,[r0,#4]
;;;854          
;;;855        /* PCLK2 = HCLK */
;;;856        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000042  6841              LDR      r1,[r0,#4]
000044  6041              STR      r1,[r0,#4]
;;;857        
;;;858        /* PCLK1 = HCLK/2 */
;;;859        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
000046  6841              LDR      r1,[r0,#4]
000048  f4416180          ORR      r1,r1,#0x400
00004c  6041              STR      r1,[r0,#4]
;;;860    
;;;861    #ifdef STM32F10X_CL
;;;862        /* Configure PLLs ------------------------------------------------------*/
;;;863        /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;864        /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;865            
;;;866        RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;867                                  RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;868        RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;869                                 RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;870      
;;;871        /* Enable PLL2 */
;;;872        RCC->CR |= RCC_CR_PLL2ON;
;;;873        /* Wait till PLL2 is ready */
;;;874        while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;875        {
;;;876        }
;;;877        
;;;878       
;;;879        /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;880        RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;881        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;882                                RCC_CFGR_PLLMULL9); 
;;;883    #else    
;;;884        /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;885        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
00004e  6841              LDR      r1,[r0,#4]
000050  f421117c          BIC      r1,r1,#0x3f0000
000054  6041              STR      r1,[r0,#4]
;;;886                                            RCC_CFGR_PLLMULL));
;;;887        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
000056  6841              LDR      r1,[r0,#4]
000058  f44111e8          ORR      r1,r1,#0x1d0000
00005c  6041              STR      r1,[r0,#4]
;;;888    #endif /* STM32F10X_CL */
;;;889    
;;;890        /* Enable PLL */
;;;891        RCC->CR |= RCC_CR_PLLON;
00005e  6801              LDR      r1,[r0,#0]
000060  f0417180          ORR      r1,r1,#0x1000000
000064  6001              STR      r1,[r0,#0]
                  |L1.102|
;;;892    
;;;893        /* Wait till PLL is ready */
;;;894        while((RCC->CR & RCC_CR_PLLRDY) == 0)
000066  6801              LDR      r1,[r0,#0]
000068  0189              LSLS     r1,r1,#6
00006a  d5fc              BPL      |L1.102|
;;;895        {
;;;896        }
;;;897        
;;;898        /* Select PLL as system clock source */
;;;899        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
00006c  6841              LDR      r1,[r0,#4]
00006e  f0210103          BIC      r1,r1,#3
000072  6041              STR      r1,[r0,#4]
;;;900        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
000074  6841              LDR      r1,[r0,#4]
000076  f0410102          ORR      r1,r1,#2
00007a  6041              STR      r1,[r0,#4]
                  |L1.124|
;;;901    
;;;902        /* Wait till PLL is used as system clock source */
;;;903        while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
00007c  6841              LDR      r1,[r0,#4]
00007e  f3c10181          UBFX     r1,r1,#2,#2
000082  2902              CMP      r1,#2
000084  d1fa              BNE      |L1.124|
;;;904        {
;;;905        }
;;;906      }
;;;907      else
;;;908      { /* If HSE fails to start-up, the application will have wrong clock 
;;;909             configuration. User can add here some code to deal with this error */    
;;;910    
;;;911        /* Go to infinite loop */
;;;912        while (1)
;;;913        {
;;;914        }
;;;915      }
;;;916    }
000086  4770              BX       lr
                  |L1.136|
000088  e7fe              B        |L1.136|
;;;917    #endif
                          ENDP

00008a  0000              DCW      0x0000
                  |L1.140|
                          DCD      0x40021000
                  |L1.144|
                          DCD      0x40022000

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;186      */
;;;187    void SystemInit (void)
000000  480c              LDR      r0,|L2.52|
;;;188    {
;;;189      /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;190      /* Set HSION bit */
;;;191      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;192    
;;;193      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;194    #ifndef STM32F10X_CL
;;;195      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0a              LDR      r2,|L2.56|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;196    #else
;;;197      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;198    #endif /* STM32F10X_CL */   
;;;199      
;;;200      /* Reset HSEON, CSSON and PLLON bits */
;;;201      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  4a09              LDR      r2,|L2.60|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;202    
;;;203      /* Reset HSEBYP bit */
;;;204      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4212180          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;205    
;;;206      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;207      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000022  6841              LDR      r1,[r0,#4]
000024  f42101fe          BIC      r1,r1,#0x7f0000
000028  6041              STR      r1,[r0,#4]
;;;208    
;;;209    #ifndef STM32F10X_CL
;;;210      /* Disable all interrupts and clear pending bits  */
;;;211      RCC->CIR = 0x009F0000;
00002a  f44f011f          MOV      r1,#0x9f0000
00002e  6081              STR      r1,[r0,#8]
000030  f7ffbffe          B.W      SetSysClockTo72
;;;212    #else
;;;213      /* Reset PLL2ON and PLL3ON bits */
;;;214      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;215    
;;;216      /* Disable all interrupts and clear pending bits  */
;;;217      RCC->CIR = 0x00FF0000;
;;;218    
;;;219      /* Reset CFGR2 register */
;;;220      RCC->CFGR2 = 0x00000000;
;;;221    #endif /* STM32F10X_CL */
;;;222        
;;;223      /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;224      /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;225      SetSysClock();
;;;226    
;;;227    }
;;;228    
                          ENDP

                  |L2.52|
                          DCD      0x40021000
                  |L2.56|
                          DCD      0xf8ff0000
                  |L2.60|
                          DCD      0xfef6ffff

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  SystemFrequency
                          DCD      0x044aa200

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.constdata||
                  SystemFrequency_SysClk
                          DCD      0x044aa200

                          AREA ||area_number.7||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.constdata||
                  SystemFrequency_AHBClk
                          DCD      0x044aa200

                          AREA ||area_number.8||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.constdata||
                  SystemFrequency_APB1Clk
                          DCD      0x02255100

                          AREA ||area_number.9||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.constdata||
                  SystemFrequency_APB2Clk
                          DCD      0x044aa200
