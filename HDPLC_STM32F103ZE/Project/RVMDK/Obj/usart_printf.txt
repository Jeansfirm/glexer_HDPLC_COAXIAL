; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\usart_printf.o --depend=.\Obj\usart_printf.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Source\src\usart_printf.c]
                          THUMB

                          AREA ||i.PrintfLogo||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  PrintfLogo PROC
;;;25     */
;;;26     void PrintfLogo(char *strName, char *strDate)
000000  b570              PUSH     {r4-r6,lr}
;;;27     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;28     	printf("*************************************************************\n\r");
000006  a00e              ADR      r0,|L1.64|
000008  f7fffffe          BL       __2printf
;;;29     	printf("* Program Name : %s\r\n", strName);
00000c  4629              MOV      r1,r5
00000e  a01c              ADR      r0,|L1.128|
000010  f7fffffe          BL       __2printf
;;;30     	printf("* Update Date  : %s\r\n", strDate);
000014  4621              MOV      r1,r4
000016  a020              ADR      r0,|L1.152|
000018  f7fffffe          BL       __2printf
;;;31     	printf("* StdPeriph_Lib Version : V3.1.2\n\r");
00001c  a024              ADR      r0,|L1.176|
00001e  f7fffffe          BL       __2printf
;;;32     	printf("* \n\r");
000022  a02c              ADR      r0,|L1.212|
000024  f7fffffe          BL       __2printf
;;;33     	printf("* Copyright:  GLEXER \r\n");
000028  a02c              ADR      r0,|L1.220|
00002a  f7fffffe          BL       __2printf
;;;34     	printf("* Email : pengjunfeng@glexer.com \r\n");
00002e  a031              ADR      r0,|L1.244|
000030  f7fffffe          BL       __2printf
;;;35     	printf("*************************************************************\n\r");
000034  e8bd4070          POP      {r4-r6,lr}
000038  a001              ADR      r0,|L1.64|
00003a  f7ffbffe          B.W      __2printf
;;;36     }
;;;37     
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
000040  2a2a2a2a          DCB      "*******************************************************"
000044  2a2a2a2a
000048  2a2a2a2a
00004c  2a2a2a2a
000050  2a2a2a2a
000054  2a2a2a2a
000058  2a2a2a2a
00005c  2a2a2a2a
000060  2a2a2a2a
000064  2a2a2a2a
000068  2a2a2a2a
00006c  2a2a2a2a
000070  2a2a2a2a
000074  2a2a2a  
000077  2a2a2a2a          DCB      "******\n\r",0
00007b  2a2a0a0d
00007f  00      
                  |L1.128|
000080  2a205072          DCB      "* Program Name : %s\r\n",0
000084  6f677261
000088  6d204e61
00008c  6d65203a
000090  2025730d
000094  0a00    
000096  00                DCB      0
000097  00                DCB      0
                  |L1.152|
000098  2a205570          DCB      "* Update Date  : %s\r\n",0
00009c  64617465
0000a0  20446174
0000a4  6520203a
0000a8  2025730d
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L1.176|
0000b0  2a205374          DCB      "* StdPeriph_Lib Version : V3.1.2\n\r",0
0000b4  64506572
0000b8  6970685f
0000bc  4c696220
0000c0  56657273
0000c4  696f6e20
0000c8  3a205633
0000cc  2e312e32
0000d0  0a0d00  
0000d3  00                DCB      0
                  |L1.212|
0000d4  2a200a0d          DCB      "* \n\r",0
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L1.220|
0000dc  2a20436f          DCB      "* Copyright:  GLEXER \r\n",0
0000e0  70797269
0000e4  6768743a
0000e8  2020474c
0000ec  45584552
0000f0  200d0a00
                  |L1.244|
0000f4  2a20456d          DCB      "* Email : pengjunfeng@glexer.com \r\n",0
0000f8  61696c20
0000fc  3a207065
000100  6e676a75
000104  6e66656e
000108  6740676c
00010c  65786572
000110  2e636f6d
000114  200d0a00

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;49     */
;;;50     void USART_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;51     {
000002  b086              SUB      sp,sp,#0x18
;;;52     	GPIO_InitTypeDef GPIO_InitStructure;
;;;53     	USART_InitTypeDef USART_InitStructure;
;;;54     
;;;55     	/* 第1步：打开GPIO和USART部件的时钟 */
;;;56     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;57     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;58     
;;;59     	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;60     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;61     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;62     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
;;;63     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000024  4c19              LDR      r4,|L2.140|
000026  f88d0012          STRB     r0,[sp,#0x12]         ;62
00002a  a904              ADD      r1,sp,#0x10
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       GPIO_Init
;;;64     
;;;65     	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;66     		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;67     		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;68     	*/
;;;69     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000032  1520              ASRS     r0,r4,#20
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;70     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;71     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       GPIO_Init
;;;72     	/*  第3步已经做了，因此这步可以不做
;;;73     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;74     	*/
;;;75     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000046  a904              ADD      r1,sp,#0x10
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       GPIO_Init
;;;76     
;;;77     
;;;78     	/* 第4步：配置USART参数
;;;79     	    - BaudRate = 115200 baud
;;;80     	    - Word Length = 8 Bits
;;;81     	    - One Stop Bit
;;;82     	    - No parity
;;;83     	    - Hardware flow control disabled (RTS and CTS signals)
;;;84     	    - Receive and transmit enabled
;;;85     	*/
;;;86     	USART_InitStructure.USART_BaudRate = 115200;
00004e  f44f30e1          MOV      r0,#0x1c200
;;;87     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000052  9000              STR      r0,[sp,#0]
000054  2000              MOVS     r0,#0
000056  f8ad0004          STRH     r0,[sp,#4]
;;;88     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00005a  f8ad0006          STRH     r0,[sp,#6]
;;;89     	USART_InitStructure.USART_Parity = USART_Parity_No;
00005e  f8ad0008          STRH     r0,[sp,#8]
;;;90     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000062  f8ad000c          STRH     r0,[sp,#0xc]
;;;91     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000066  200c              MOVS     r0,#0xc
;;;92     	USART_Init(USART1, &USART_InitStructure);
000068  4c09              LDR      r4,|L2.144|
00006a  f8ad000a          STRH     r0,[sp,#0xa]          ;91
00006e  4669              MOV      r1,sp
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       USART_Init
;;;93     
;;;94     	/* 第5步：使能 USART， 配置完毕 */
;;;95     	USART_Cmd(USART1, ENABLE);
000076  2101              MOVS     r1,#1
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       USART_Cmd
;;;96     
;;;97     	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;98     		如下语句解决第1个字节无法正确发送出去的问题 */
;;;99     	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送外城标志，Transmission Complete flag */
00007e  2140              MOVS     r1,#0x40
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       USART_ClearFlag
;;;100    }
000086  b006              ADD      sp,sp,#0x18
000088  bd10              POP      {r4,pc}
;;;101    
                          ENDP

00008a  0000              DCW      0x0000
                  |L2.140|
                          DCD      0x40010800
                  |L2.144|
                          DCD      0x40013800

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;128    */
;;;129    int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;130    {
;;;131    	/* 等待串口1输入数据 */
;;;132    	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
000002  4c06              LDR      r4,|L3.28|
                  |L3.4|
000004  2120              MOVS     r1,#0x20
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L3.4|
;;;133    	{}
;;;134    
;;;135    	return (int)USART_ReceiveData(USART1);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      USART_ReceiveData
;;;136    }
;;;137    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;108    */
;;;109    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;110    {
;;;111    	/* Place your implementation of fputc here */
;;;112    	/* e.g. write a character to the USART */
;;;113    	USART_SendData(USART1, (uint8_t) ch);
000002  4d07              LDR      r5,|L4.32|
000004  4604              MOV      r4,r0                 ;110
000006  b2c1              UXTB     r1,r0
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_SendData
                  |L4.14|
;;;114    
;;;115    	/* Loop until the end of transmission */
;;;116    	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
00000e  2140              MOVS     r1,#0x40
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L4.14|
;;;117    	{}
;;;118    
;;;119    	return ch;
00001a  4620              MOV      r0,r4
;;;120    }
00001c  bd70              POP      {r4-r6,pc}
;;;121    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40013800
