; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\psock.o --depend=.\Obj\psock.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Libraries\uIP-1.0\uip\psock.c]
                          THUMB

                          AREA ||i.buf_bufdata||, CODE, READONLY, ALIGN=1

                  buf_bufdata PROC
;;;82     static u8_t
;;;83     buf_bufdata(struct psock_buf *buf, u16_t len,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     	    u8_t **dataptr, u16_t *datalen)
;;;85     {
000004  4616              MOV      r6,r2
000006  461d              MOV      r5,r3
;;;86       if(*datalen < buf->left) {
000008  881a              LDRH     r2,[r3,#0]
00000a  4604              MOV      r4,r0                 ;85
00000c  8883              LDRH     r3,[r0,#4]
;;;87         memcpy(buf->ptr, *dataptr, *datalen);
;;;88         buf->ptr += *datalen;
;;;89         buf->left -= *datalen;
;;;90         *dataptr += *datalen;
;;;91         *datalen = 0;
00000e  2700              MOVS     r7,#0
000010  6800              LDR      r0,[r0,#0]            ;87
000012  6831              LDR      r1,[r6,#0]            ;86
000014  429a              CMP      r2,r3                 ;86
000016  d211              BCS      |L1.60|
000018  f7fffffe          BL       __aeabi_memcpy
00001c  8829              LDRH     r1,[r5,#0]            ;88
00001e  6820              LDR      r0,[r4,#0]            ;88
000020  4408              ADD      r0,r0,r1              ;88
000022  6020              STR      r0,[r4,#0]            ;89
000024  88a0              LDRH     r0,[r4,#4]            ;89
000026  8829              LDRH     r1,[r5,#0]            ;89
000028  1a40              SUBS     r0,r0,r1              ;89
00002a  80a0              STRH     r0,[r4,#4]            ;89
00002c  8829              LDRH     r1,[r5,#0]            ;90
00002e  6830              LDR      r0,[r6,#0]            ;90
000030  4408              ADD      r0,r0,r1              ;90
000032  6030              STR      r0,[r6,#0]
000034  802f              STRH     r7,[r5,#0]
;;;92         return BUF_NOT_FULL;
000036  2000              MOVS     r0,#0
                  |L1.56|
;;;93       } else if(*datalen == buf->left) {
;;;94         memcpy(buf->ptr, *dataptr, *datalen);
;;;95         buf->ptr += *datalen;
;;;96         buf->left = 0;
;;;97         *dataptr += *datalen;
;;;98         *datalen = 0;
;;;99         return BUF_FULL;
;;;100      } else {
;;;101        memcpy(buf->ptr, *dataptr, buf->left);
;;;102        buf->ptr += buf->left;
;;;103        *datalen -= buf->left;
;;;104        *dataptr += buf->left;
;;;105        buf->left = 0;
;;;106        return BUF_FULL;
;;;107      }
;;;108    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L1.60|
00003c  d10c              BNE      |L1.88|
00003e  f7fffffe          BL       __aeabi_memcpy
000042  8829              LDRH     r1,[r5,#0]            ;95
000044  6820              LDR      r0,[r4,#0]            ;95
000046  4408              ADD      r0,r0,r1              ;95
000048  6020              STR      r0,[r4,#0]            ;96
00004a  80a7              STRH     r7,[r4,#4]            ;96
00004c  8829              LDRH     r1,[r5,#0]            ;97
00004e  6830              LDR      r0,[r6,#0]            ;97
000050  4408              ADD      r0,r0,r1              ;97
000052  6030              STR      r0,[r6,#0]            ;98
000054  802f              STRH     r7,[r5,#0]            ;98
000056  e00e              B        |L1.118|
                  |L1.88|
000058  461a              MOV      r2,r3                 ;99
00005a  f7fffffe          BL       __aeabi_memcpy
00005e  88a0              LDRH     r0,[r4,#4]            ;102
000060  6821              LDR      r1,[r4,#0]            ;102
000062  4401              ADD      r1,r1,r0              ;102
000064  6021              STR      r1,[r4,#0]            ;103
000066  8829              LDRH     r1,[r5,#0]            ;103
000068  1a08              SUBS     r0,r1,r0              ;103
00006a  8028              STRH     r0,[r5,#0]            ;103
00006c  88a1              LDRH     r1,[r4,#4]            ;104
00006e  6830              LDR      r0,[r6,#0]            ;104
000070  4408              ADD      r0,r0,r1              ;104
000072  6030              STR      r0,[r6,#0]            ;105
000074  80a7              STRH     r7,[r4,#4]            ;105
                  |L1.118|
000076  2001              MOVS     r0,#1                 ;106
000078  e7de              B        |L1.56|
;;;109    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.data_acked||, CODE, READONLY, ALIGN=2

                  data_acked PROC
;;;159    static char
;;;160    data_acked(register struct psock *s)
000000  f8901020          LDRB     r1,[r0,#0x20]
;;;161    {
;;;162      if(s->state == STATE_DATA_SENT && uip_acked()) {
000004  2906              CMP      r1,#6
000006  d11a              BNE      |L2.62|
000008  490e              LDR      r1,|L2.68|
00000a  7809              LDRB     r1,[r1,#0]  ; uip_flags
00000c  07c9              LSLS     r1,r1,#31
00000e  d016              BEQ      |L2.62|
;;;163        if(s->sendlen > uip_mss()) {
000010  4a0d              LDR      r2,|L2.72|
000012  8a01              LDRH     r1,[r0,#0x10]
000014  6812              LDR      r2,[r2,#0]  ; uip_conn
000016  8a53              LDRH     r3,[r2,#0x12]
000018  4299              CMP      r1,r3
00001a  d906              BLS      |L2.42|
;;;164          s->sendlen -= uip_mss();
00001c  1ac9              SUBS     r1,r1,r3
00001e  8201              STRH     r1,[r0,#0x10]
;;;165          s->sendptr += uip_mss();
000020  8a52              LDRH     r2,[r2,#0x12]
000022  6841              LDR      r1,[r0,#4]
000024  4411              ADD      r1,r1,r2
000026  6041              STR      r1,[r0,#4]
000028  e004              B        |L2.52|
                  |L2.42|
;;;166        } else {
;;;167          s->sendptr += s->sendlen;
00002a  6842              LDR      r2,[r0,#4]
;;;168          s->sendlen = 0;
00002c  2300              MOVS     r3,#0
00002e  4411              ADD      r1,r1,r2              ;167
000030  6041              STR      r1,[r0,#4]
000032  8203              STRH     r3,[r0,#0x10]
                  |L2.52|
;;;169        }
;;;170        s->state = STATE_ACKED;
000034  2101              MOVS     r1,#1
000036  f8801020          STRB     r1,[r0,#0x20]
;;;171        return 1;
00003a  4608              MOV      r0,r1
;;;172      }
;;;173      return 0;
;;;174    }
00003c  4770              BX       lr
                  |L2.62|
00003e  2000              MOVS     r0,#0                 ;173
000040  4770              BX       lr
;;;175    /*---------------------------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      uip_flags
                  |L2.72|
                          DCD      uip_conn

                          AREA ||i.psock_datalen||, CODE, READONLY, ALIGN=1

                  psock_datalen PROC
;;;246    u16_t
;;;247    psock_datalen(struct psock *psock)
000000  69c1              LDR      r1,[r0,#0x1c]
;;;248    {
;;;249      return psock->bufsize - psock->buf.left;
000002  8b00              LDRH     r0,[r0,#0x18]
000004  1a08              SUBS     r0,r1,r0
000006  b280              UXTH     r0,r0
;;;250    }
000008  4770              BX       lr
;;;251    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.psock_generator_send||, CODE, READONLY, ALIGN=2

                  psock_generator_send PROC
;;;214    /*---------------------------------------------------------------------------*/
;;;215    PT_THREAD(psock_generator_send(register struct psock *s,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;216    			       unsigned short (*generate)(void *), void *arg))
;;;217    {
000004  4604              MOV      r4,r0
;;;218      PT_BEGIN(&s->psockpt);
000006  8840              LDRH     r0,[r0,#2]
000008  460d              MOV      r5,r1                 ;217
00000a  4690              MOV      r8,r2                 ;217
00000c  2600              MOVS     r6,#0
00000e  b110              CBZ      r0,|L4.22|
000010  28ee              CMP      r0,#0xee
000012  d11f              BNE      |L4.84|
000014  e010              B        |L4.56|
                  |L4.22|
;;;219    
;;;220      /* Ensure that there is a generator function to call. */
;;;221      if(generate == NULL) {
000016  b30d              CBZ      r5,|L4.92|
;;;222        PT_EXIT(&s->psockpt);
;;;223      }
;;;224    
;;;225      /* Call the generator function to generate the data in the
;;;226         uip_appdata buffer. */
;;;227      s->sendlen = generate(arg);
000018  4610              MOV      r0,r2
00001a  47a8              BLX      r5
00001c  8220              STRH     r0,[r4,#0x10]
;;;228      s->sendptr = uip_appdata;
00001e  4811              LDR      r0,|L4.100|
000020  6800              LDR      r0,[r0,#0]  ; uip_appdata
;;;229    
;;;230      s->state = STATE_NONE;
000022  6060              STR      r0,[r4,#4]
000024  f8846020          STRB     r6,[r4,#0x20]
                  |L4.40|
;;;231      do {
;;;232        /* Call the generator function again if we are called to perform a
;;;233           retransmission. */
;;;234        if(uip_rexmit()) {
000028  480f              LDR      r0,|L4.104|
00002a  7800              LDRB     r0,[r0,#0]  ; uip_flags
00002c  0740              LSLS     r0,r0,#29
00002e  d501              BPL      |L4.52|
;;;235          generate(arg);
000030  4640              MOV      r0,r8
000032  47a8              BLX      r5
                  |L4.52|
;;;236        }
;;;237        /* Wait until all data is sent and acknowledged. */
;;;238        PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
000034  20ee              MOVS     r0,#0xee
000036  8060              STRH     r0,[r4,#2]
                  |L4.56|
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       data_acked
00003e  4607              MOV      r7,r0
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       send_data
000046  4207              TST      r7,r0
000048  d00a              BEQ      |L4.96|
;;;239      } while(s->sendlen > 0);
00004a  8a20              LDRH     r0,[r4,#0x10]
00004c  2800              CMP      r0,#0
00004e  d1eb              BNE      |L4.40|
;;;240    
;;;241      s->state = STATE_NONE;
000050  f8846020          STRB     r6,[r4,#0x20]
                  |L4.84|
;;;242    
;;;243      PT_END(&s->psockpt);
000054  8066              STRH     r6,[r4,#2]
000056  2002              MOVS     r0,#2
                  |L4.88|
;;;244    }
000058  e8bd81f0          POP      {r4-r8,pc}
                  |L4.92|
00005c  2001              MOVS     r0,#1                 ;222
00005e  e7fb              B        |L4.88|
                  |L4.96|
000060  2000              MOVS     r0,#0                 ;238
000062  e7f9              B        |L4.88|
;;;245    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L4.100|
                          DCD      uip_appdata
                  |L4.104|
                          DCD      uip_flags

                          AREA ||i.psock_init||, CODE, READONLY, ALIGN=1

                  psock_init PROC
;;;327    void
;;;328    psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
000000  b510              PUSH     {r4,lr}
;;;329    {
;;;330      psock->state = STATE_NONE;
000002  2400              MOVS     r4,#0
000004  f8804020          STRB     r4,[r0,#0x20]
;;;331      psock->readlen = 0;
000008  8244              STRH     r4,[r0,#0x12]
00000a  60c1              STR      r1,[r0,#0xc]
00000c  61c2              STR      r2,[r0,#0x1c]
00000e  6141              STR      r1,[r0,#0x14]
000010  8302              STRH     r2,[r0,#0x18]
;;;332      psock->bufptr = buffer;
;;;333      psock->bufsize = buffersize;
;;;334      buf_setup(&psock->buf, buffer, buffersize);
;;;335      PT_INIT(&psock->pt);
000012  8004              STRH     r4,[r0,#0]
;;;336      PT_INIT(&psock->psockpt);
000014  8044              STRH     r4,[r0,#2]
;;;337    }
000016  bd10              POP      {r4,pc}
;;;338    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.psock_newdata||, CODE, READONLY, ALIGN=2

                  psock_newdata PROC
;;;252    char
;;;253    psock_newdata(struct psock *s)
000000  8a41              LDRH     r1,[r0,#0x12]
;;;254    {
;;;255      if(s->readlen > 0) {
000002  b939              CBNZ     r1,|L6.20|
;;;256        /* There is data in the uip_appdata buffer that has not yet been
;;;257           read with the PSOCK_READ functions. */
;;;258        return 1;
;;;259      } else if(s->state == STATE_READ) {
000004  f8901020          LDRB     r1,[r0,#0x20]
000008  2902              CMP      r1,#2
00000a  d005              BEQ      |L6.24|
;;;260        /* All data in uip_appdata buffer already consumed. */
;;;261        s->state = STATE_BLOCKED_NEWDATA;
;;;262        return 0;
;;;263      } else if(uip_newdata()) {
00000c  4805              LDR      r0,|L6.36|
00000e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000010  0780              LSLS     r0,r0,#30
000012  d504              BPL      |L6.30|
                  |L6.20|
;;;264        /* There is new data that has not been consumed. */
;;;265        return 1;
000014  2001              MOVS     r0,#1
;;;266      } else {
;;;267        /* There is no new data. */
;;;268        return 0;
;;;269      }
;;;270    }
000016  4770              BX       lr
                  |L6.24|
000018  2103              MOVS     r1,#3                 ;261
00001a  f8801020          STRB     r1,[r0,#0x20]         ;261
                  |L6.30|
00001e  2000              MOVS     r0,#0                 ;268
000020  4770              BX       lr
;;;271    /*---------------------------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      uip_flags

                          AREA ||i.psock_readbuf||, CODE, READONLY, ALIGN=2

                  psock_readbuf PROC
;;;298    /*---------------------------------------------------------------------------*/
;;;299    PT_THREAD(psock_readbuf(register struct psock *psock))
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;300    {
000004  4604              MOV      r4,r0
;;;301      PT_BEGIN(&psock->psockpt);
000006  8840              LDRH     r0,[r0,#2]
000008  2600              MOVS     r6,#0
00000a  f44f779b          MOV      r7,#0x136
;;;302    
;;;303      buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
00000e  f1040514          ADD      r5,r4,#0x14
000012  b110              CBZ      r0,|L7.26|
000014  42b8              CMP      r0,r7                 ;301
000016  d129              BNE      |L7.108|
000018  e006              B        |L7.40|
                  |L7.26|
00001a  68e1              LDR      r1,[r4,#0xc]          ;301
00001c  69e0              LDR      r0,[r4,#0x1c]         ;301
00001e  6029              STR      r1,[r5,#0]            ;301
000020  80a8              STRH     r0,[r5,#4]            ;301
                  |L7.34|
;;;304    
;;;305      /* XXX: Should add buf_checkmarker() before do{} loop, if
;;;306         incoming data has been handled while waiting for a write. */
;;;307    
;;;308      do {
;;;309        if(psock->readlen == 0) {
000022  8a60              LDRH     r0,[r4,#0x12]
000024  b988              CBNZ     r0,|L7.74|
;;;310          PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
000026  8067              STRH     r7,[r4,#2]
                  |L7.40|
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       psock_newdata
00002e  2800              CMP      r0,#0
000030  d01e              BEQ      |L7.112|
;;;311          printf("Waited for newdata\n");
000032  a013              ADR      r0,|L7.128|
000034  f7fffffe          BL       __2printf
;;;312          psock->state = STATE_READ;
000038  2002              MOVS     r0,#2
00003a  f8840020          STRB     r0,[r4,#0x20]
;;;313          psock->readptr = (u8_t *)uip_appdata;
00003e  4815              LDR      r0,|L7.148|
000040  6800              LDR      r0,[r0,#0]  ; uip_appdata
;;;314          psock->readlen = uip_datalen();
000042  60a0              STR      r0,[r4,#8]
000044  4814              LDR      r0,|L7.152|
000046  8800              LDRH     r0,[r0,#0]  ; uip_len
000048  8260              STRH     r0,[r4,#0x12]
                  |L7.74|
;;;315        }
;;;316      } while(buf_bufdata(&psock->buf, psock->bufsize,
00004a  69e0              LDR      r0,[r4,#0x1c]
00004c  f1040312          ADD      r3,r4,#0x12
000050  b281              UXTH     r1,r0
000052  f1040208          ADD      r2,r4,#8
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       buf_bufdata
00005c  2801              CMP      r0,#1
00005e  d1e0              BNE      |L7.34|
;;;317    			 &psock->readptr,
;;;318    			 &psock->readlen) != BUF_FULL);
;;;319    
;;;320      if(psock_datalen(psock) == 0) {
000060  8b21              LDRH     r1,[r4,#0x18]
000062  69e0              LDR      r0,[r4,#0x1c]
000064  1a40              SUBS     r0,r0,r1
000066  0400              LSLS     r0,r0,#16
000068  0c00              LSRS     r0,r0,#16
00006a  d003              BEQ      |L7.116|
                  |L7.108|
;;;321        psock->state = STATE_NONE;
;;;322        PT_RESTART(&psock->psockpt);
;;;323      }
;;;324      PT_END(&psock->psockpt);
00006c  8066              STRH     r6,[r4,#2]
00006e  2002              MOVS     r0,#2
                  |L7.112|
;;;325    }
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L7.116|
000074  f8846020          STRB     r6,[r4,#0x20]         ;321
000078  8066              STRH     r6,[r4,#2]            ;322
00007a  2000              MOVS     r0,#0                 ;322
00007c  e7f8              B        |L7.112|
;;;326    /*---------------------------------------------------------------------------*/
                          ENDP

00007e  0000              DCW      0x0000
                  |L7.128|
000080  57616974          DCB      "Waited for newdata\n",0
000084  65642066
000088  6f72206e
00008c  65776461
000090  74610a00
                  |L7.148|
                          DCD      uip_appdata
                  |L7.152|
                          DCD      uip_len

                          AREA ||i.psock_readto||, CODE, READONLY, ALIGN=2

                  psock_readto PROC
;;;271    /*---------------------------------------------------------------------------*/
;;;272    PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;273    {
000004  4602              MOV      r2,r0
;;;274      PT_BEGIN(&psock->psockpt);
000006  8840              LDRH     r0,[r0,#2]
000008  460f              MOV      r7,r1                 ;273
;;;275    
;;;276      buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
00000a  f1020314          ADD      r3,r2,#0x14
;;;277    
;;;278      /* XXX: Should add buf_checkmarker() before do{} loop, if
;;;279         incoming data has been handled while waiting for a write. */
;;;280    
;;;281      do {
;;;282        if(psock->readlen == 0) {
;;;283          PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
;;;284          psock->state = STATE_READ;
00000e  f04f0902          MOV      r9,#2
000012  f04f0800          MOV      r8,#0                 ;274
000016  b120              CBZ      r0,|L8.34|
000018  f5a07080          SUB      r0,r0,#0x100          ;274
00001c  381b              SUBS     r0,r0,#0x1b           ;274
00001e  d151              BNE      |L8.196|
000020  e008              B        |L8.52|
                  |L8.34|
000022  68d1              LDR      r1,[r2,#0xc]          ;274
000024  69d0              LDR      r0,[r2,#0x1c]         ;274
000026  6019              STR      r1,[r3,#0]            ;274
000028  8098              STRH     r0,[r3,#4]            ;274
                  |L8.42|
00002a  8a50              LDRH     r0,[r2,#0x12]         ;282
00002c  b978              CBNZ     r0,|L8.78|
00002e  f240101b          MOV      r0,#0x11b             ;283
000032  8050              STRH     r0,[r2,#2]            ;283
                  |L8.52|
000034  4610              MOV      r0,r2                 ;283
000036  f7fffffe          BL       psock_newdata
00003a  2800              CMP      r0,#0                 ;283
00003c  d045              BEQ      |L8.202|
;;;285          psock->readptr = (u8_t *)uip_appdata;
00003e  4827              LDR      r0,|L8.220|
000040  f8829020          STRB     r9,[r2,#0x20]         ;284
;;;286          psock->readlen = uip_datalen();
000044  4926              LDR      r1,|L8.224|
000046  6800              LDR      r0,[r0,#0]            ;285  ; uip_appdata
000048  6090              STR      r0,[r2,#8]
00004a  8808              LDRH     r0,[r1,#0]  ; uip_len
00004c  8250              STRH     r0,[r2,#0x12]
                  |L8.78|
;;;287        }
;;;288      } while((buf_bufto(&psock->buf, c,
00004e  461c              MOV      r4,r3
000050  f1020012          ADD      r0,r2,#0x12
000054  e013              B        |L8.126|
                  |L8.86|
000056  6895              LDR      r5,[r2,#8]
000058  6826              LDR      r6,[r4,#0]
00005a  782d              LDRB     r5,[r5,#0]
00005c  7035              STRB     r5,[r6,#0]
00005e  6891              LDR      r1,[r2,#8]
000060  1c49              ADDS     r1,r1,#1
000062  6091              STR      r1,[r2,#8]
000064  6821              LDR      r1,[r4,#0]
000066  1c49              ADDS     r1,r1,#1
000068  6021              STR      r1,[r4,#0]
00006a  8801              LDRH     r1,[r0,#0]
00006c  1e49              SUBS     r1,r1,#1
00006e  8001              STRH     r1,[r0,#0]
000070  88a1              LDRH     r1,[r4,#4]
000072  1e49              SUBS     r1,r1,#1
000074  80a1              STRH     r1,[r4,#4]
000076  42bd              CMP      r5,r7
000078  d101              BNE      |L8.126|
00007a  4648              MOV      r0,r9
00007c  e01a              B        |L8.180|
                  |L8.126|
00007e  88a1              LDRH     r1,[r4,#4]
000080  2900              CMP      r1,#0
000082  8801              LDRH     r1,[r0,#0]
000084  d002              BEQ      |L8.140|
000086  2900              CMP      r1,#0
000088  d1e5              BNE      |L8.86|
00008a  e000              B        |L8.142|
                  |L8.140|
00008c  b909              CBNZ     r1,|L8.146|
                  |L8.142|
00008e  4640              MOV      r0,r8
000090  e010              B        |L8.180|
                  |L8.146|
000092  6891              LDR      r1,[r2,#8]
000094  8804              LDRH     r4,[r0,#0]
000096  1e64              SUBS     r4,r4,#1
000098  7809              LDRB     r1,[r1,#0]
00009a  8004              STRH     r4,[r0,#0]
00009c  6894              LDR      r4,[r2,#8]
00009e  42b9              CMP      r1,r7
0000a0  f1040401          ADD      r4,r4,#1
0000a4  6094              STR      r4,[r2,#8]
0000a6  d101              BNE      |L8.172|
0000a8  2003              MOVS     r0,#3
0000aa  e003              B        |L8.180|
                  |L8.172|
0000ac  8801              LDRH     r1,[r0,#0]
0000ae  2900              CMP      r1,#0
0000b0  d1ef              BNE      |L8.146|
0000b2  2001              MOVS     r0,#1
                  |L8.180|
0000b4  0780              LSLS     r0,r0,#30
0000b6  d5b8              BPL      |L8.42|
;;;289    		     &psock->readptr,
;;;290    		     &psock->readlen) & BUF_FOUND) == 0);
;;;291    
;;;292      if(psock_datalen(psock) == 0) {
0000b8  8b11              LDRH     r1,[r2,#0x18]
0000ba  69d0              LDR      r0,[r2,#0x1c]
0000bc  1a40              SUBS     r0,r0,r1
0000be  0400              LSLS     r0,r0,#16
0000c0  0c00              LSRS     r0,r0,#16
0000c2  d004              BEQ      |L8.206|
                  |L8.196|
;;;293        psock->state = STATE_NONE;
;;;294        PT_RESTART(&psock->psockpt);
;;;295      }
;;;296      PT_END(&psock->psockpt);
0000c4  f8a28002          STRH     r8,[r2,#2]
0000c8  2002              MOVS     r0,#2
                  |L8.202|
;;;297    }
0000ca  e8bd83f0          POP      {r4-r9,pc}
                  |L8.206|
0000ce  f8828020          STRB     r8,[r2,#0x20]         ;293
0000d2  f8a28002          STRH     r8,[r2,#2]            ;294
0000d6  2000              MOVS     r0,#0                 ;294
0000d8  e7f7              B        |L8.202|
;;;298    /*---------------------------------------------------------------------------*/
                          ENDP

0000da  0000              DCW      0x0000
                  |L8.220|
                          DCD      uip_appdata
                  |L8.224|
                          DCD      uip_len

                          AREA ||i.psock_send||, CODE, READONLY, ALIGN=1

                  psock_send PROC
;;;175    /*---------------------------------------------------------------------------*/
;;;176    PT_THREAD(psock_send(register struct psock *s, const char *buf,
000000  b570              PUSH     {r4-r6,lr}
;;;177    		     unsigned int len))
;;;178    {
000002  4604              MOV      r4,r0
;;;179      PT_BEGIN(&s->psockpt);
000004  8840              LDRH     r0,[r0,#2]
000006  2500              MOVS     r5,#0
000008  b110              CBZ      r0,|L9.16|
00000a  28cf              CMP      r0,#0xcf
00000c  d118              BNE      |L9.64|
00000e  e009              B        |L9.36|
                  |L9.16|
;;;180    
;;;181      /* If there is no data to send, we exit immediately. */
;;;182      if(len == 0) {
000010  b122              CBZ      r2,|L9.28|
;;;183        PT_EXIT(&s->psockpt);
;;;184      }
;;;185    
;;;186      /* Save the length of and a pointer to the data that is to be
;;;187         sent. */
;;;188      s->sendptr = buf;
;;;189      s->sendlen = len;
000012  6061              STR      r1,[r4,#4]
000014  8222              STRH     r2,[r4,#0x10]
;;;190    
;;;191      s->state = STATE_NONE;
000016  f8845020          STRB     r5,[r4,#0x20]
;;;192    
;;;193      /* We loop here until all data is sent. The s->sendlen variable is
;;;194         updated by the data_sent() function. */
;;;195      while(s->sendlen > 0) {
00001a  e00c              B        |L9.54|
                  |L9.28|
00001c  2001              MOVS     r0,#1                 ;183
;;;196    
;;;197        /*
;;;198         * The condition for this PT_WAIT_UNTIL is a little tricky: the
;;;199         * protothread will wait here until all data has been acknowledged
;;;200         * (data_acked() returns true) and until all data has been sent
;;;201         * (send_data() returns true). The two functions data_acked() and
;;;202         * send_data() must be called in succession to ensure that all
;;;203         * data is sent. Therefore the & operator is used instead of the
;;;204         * && operator, which would cause only the data_acked() function
;;;205         * to be called when it returns false.
;;;206         */
;;;207        PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
;;;208      }
;;;209    
;;;210      s->state = STATE_NONE;
;;;211    
;;;212      PT_END(&s->psockpt);
;;;213    }
00001e  bd70              POP      {r4-r6,pc}
                  |L9.32|
000020  20cf              MOVS     r0,#0xcf              ;207
000022  8060              STRH     r0,[r4,#2]            ;207
                  |L9.36|
000024  4620              MOV      r0,r4                 ;207
000026  f7fffffe          BL       data_acked
00002a  4606              MOV      r6,r0                 ;207
00002c  4620              MOV      r0,r4                 ;207
00002e  f7fffffe          BL       send_data
000032  4206              TST      r6,r0                 ;207
000034  d007              BEQ      |L9.70|
                  |L9.54|
000036  8a20              LDRH     r0,[r4,#0x10]         ;195
000038  2800              CMP      r0,#0                 ;195
00003a  d1f1              BNE      |L9.32|
00003c  f8845020          STRB     r5,[r4,#0x20]         ;210
                  |L9.64|
000040  8065              STRH     r5,[r4,#2]            ;212
000042  2002              MOVS     r0,#2                 ;212
000044  bd70              POP      {r4-r6,pc}
                  |L9.70|
000046  2000              MOVS     r0,#0                 ;207
000048  bd70              POP      {r4-r6,pc}
;;;214    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.send_data||, CODE, READONLY, ALIGN=2

                  send_data PROC
;;;144    static char
;;;145    send_data(register struct psock *s)
000000  b510              PUSH     {r4,lr}
;;;146    {
000002  4604              MOV      r4,r0
;;;147      if(s->state != STATE_DATA_SENT || uip_rexmit()) {
000004  f8900020          LDRB     r0,[r0,#0x20]
000008  2806              CMP      r0,#6
00000a  d103              BNE      |L10.20|
00000c  480b              LDR      r0,|L10.60|
00000e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000010  0740              LSLS     r0,r0,#29
000012  d511              BPL      |L10.56|
                  |L10.20|
;;;148        if(s->sendlen > uip_mss()) {
000014  490a              LDR      r1,|L10.64|
000016  8a20              LDRH     r0,[r4,#0x10]
000018  6809              LDR      r1,[r1,#0]  ; uip_conn
00001a  8a49              LDRH     r1,[r1,#0x12]
00001c  4288              CMP      r0,r1
00001e  d901              BLS      |L10.36|
;;;149          uip_send(s->sendptr, uip_mss());
000020  6860              LDR      r0,[r4,#4]
000022  e002              B        |L10.42|
                  |L10.36|
;;;150        } else {
;;;151          uip_send(s->sendptr, s->sendlen);
000024  6862              LDR      r2,[r4,#4]
000026  4601              MOV      r1,r0
000028  4610              MOV      r0,r2
                  |L10.42|
00002a  f7fffffe          BL       uip_send
;;;152        }
;;;153        s->state = STATE_DATA_SENT;
00002e  2006              MOVS     r0,#6
000030  f8840020          STRB     r0,[r4,#0x20]
;;;154        return 1;
000034  2001              MOVS     r0,#1
;;;155      }
;;;156      return 0;
;;;157    }
000036  bd10              POP      {r4,pc}
                  |L10.56|
000038  2000              MOVS     r0,#0                 ;156
00003a  bd10              POP      {r4,pc}
;;;158    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L10.60|
                          DCD      uip_flags
                  |L10.64|
                          DCD      uip_conn
