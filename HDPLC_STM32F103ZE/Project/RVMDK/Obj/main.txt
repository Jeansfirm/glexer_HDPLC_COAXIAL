; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\main.o --depend=.\Obj\main.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Source\src\main.c]
                          THUMB

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;339    */
;;;340    void GPIO_Configuration(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;341    {
;;;342    	GPIO_InitTypeDef GPIO_InitStructure;
;;;343    
;;;344    	/* 第1步：打开GPIOA GPIOC GPIOD GPIOF GPIOG的时钟
;;;345    	   注意：这个地方可以一次性全打开
;;;346    	*/
;;;347    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOC
000002  2101              MOVS     r1,#1
000004  f44f70da          MOV      r0,#0x1b4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;348    			| RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG,
;;;349    				ENABLE);
;;;350    
;;;351    	/* 第2步：配置所有的按键GPIO为浮动输入模式(实际上CPUf复位后就是输入状态) */
;;;352    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
00000c  2001              MOVS     r0,#1
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;353    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000012  2004              MOVS     r0,#4
000014  f88d0003          STRB     r0,[sp,#3]
;;;354    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2403              MOVS     r4,#3
00001a  f88d4002          STRB     r4,[sp,#2]
;;;355    	GPIO_Init(GPIOA, &GPIO_InitStructure);	/* PA0 */
00001e  4669              MOV      r1,sp
000020  4816              LDR      r0,|L1.124|
000022  f7fffffe          BL       GPIO_Init
;;;356    
;;;357    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
000026  f44f5000          MOV      r0,#0x2000
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;358    	GPIO_Init(GPIOC, &GPIO_InitStructure);	/* PC13 */
00002e  4669              MOV      r1,sp
000030  4813              LDR      r0,|L1.128|
000032  f7fffffe          BL       GPIO_Init
;;;359    
;;;360    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
000036  2008              MOVS     r0,#8
000038  f8ad0000          STRH     r0,[sp,#0]
;;;361    	GPIO_Init(GPIOD, &GPIO_InitStructure);	/* PD3 */
00003c  4669              MOV      r1,sp
00003e  4811              LDR      r0,|L1.132|
000040  f7fffffe          BL       GPIO_Init
;;;362    
;;;363    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_13
000044  f24e1080          MOV      r0,#0xe180
000048  f8ad0000          STRH     r0,[sp,#0]
;;;364    					  | GPIO_Pin_14 | GPIO_Pin_15;
;;;365    	GPIO_Init(GPIOG, &GPIO_InitStructure);	/* PG7,8,13,14,15 */
00004c  4669              MOV      r1,sp
00004e  480e              LDR      r0,|L1.136|
000050  f7fffffe          BL       GPIO_Init
;;;366    
;;;367    	/* 第3步：配置所有的LED指示灯GPIO为推挽输出模式 */
;;;368    	/* 由于将GPIO设置为输出时，GPIO输出寄存器的值缺省是0，因此会驱动LED点亮
;;;369    		这是我不希望的，因此在改变GPIO为输出前，先修改输出寄存器的值为1 */
;;;370    	GPIO_SetBits(GPIOF,  GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9);
000054  4e0d              LDR      r6,|L1.140|
000056  f44f7570          MOV      r5,#0x3c0
00005a  4629              MOV      r1,r5
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       GPIO_SetBits
;;;371    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
000062  f8ad5000          STRH     r5,[sp,#0]
;;;372    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000066  2010              MOVS     r0,#0x10
000068  f88d0003          STRB     r0,[sp,#3]
;;;373    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00006c  f88d4002          STRB     r4,[sp,#2]
;;;374    	GPIO_Init(GPIOF, &GPIO_InitStructure);
000070  4669              MOV      r1,sp
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       GPIO_Init
;;;375    }
000078  bdf8              POP      {r3-r7,pc}
;;;376    
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
                          DCD      0x40010800
                  |L1.128|
                          DCD      0x40011000
                  |L1.132|
                          DCD      0x40011400
                  |L1.136|
                          DCD      0x40012000
                  |L1.140|
                          DCD      0x40011c00

                          AREA ||i.InitBoard||, CODE, READONLY, ALIGN=2

                  InitBoard PROC
;;;384    */
;;;385    static void InitBoard(void)
000000  b510              PUSH     {r4,lr}
;;;386    {
;;;387    	/*
;;;388    		这个函数是ST库中的函数，函数实体在
;;;389    		Libraries\CMSIS\Core\CM3\system_stm32f10x.c
;;;390    
;;;391    		配置内部Flash接口，初始化PLL，配置系统频率
;;;392    		系统时钟缺省配置为72MHz，你如果需要更改，则需要去修改相关的头文件中的宏定义
;;;393    	 */
;;;394    	SystemInit();
000002  f7fffffe          BL       SystemInit
;;;395    
;;;396    	/* 配置按键GPIO和LED GPIO */
;;;397    	GPIO_Configuration();
000006  f7fffffe          BL       GPIO_Configuration
;;;398    
;;;399    	/* 配置串口 */
;;;400    	USART_Configuration();
00000a  f7fffffe          BL       USART_Configuration
;;;401    
;;;402    	/* 在 SysTick_Config()前，必须先调用 */
;;;403    	InitButtonVar();
00000e  f7fffffe          BL       InitButtonVar
;;;404    
;;;405    	/* 配置systic作为1ms中断,这个函数在
;;;406    	\Libraries\CMSIS\Core\CM3\core_cm3.h */
;;;407    	SysTick_Config(SystemFrequency / 1000);
000012  480c              LDR      r0,|L2.68|
000014  f44f717a          MOV      r1,#0x3e8
000018  6800              LDR      r0,[r0,#0]  ; SystemFrequency
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  f1b07f80          CMP      r0,#0x1000000
000022  d20e              BCS      |L2.66|
000024  f020417f          BIC      r1,r0,#0xff000000
000028  f04f20e0          MOV      r0,#0xe000e000
00002c  1e49              SUBS     r1,r1,#1
00002e  6141              STR      r1,[r0,#0x14]
000030  4a05              LDR      r2,|L2.72|
000032  21f0              MOVS     r1,#0xf0
000034  7011              STRB     r1,[r2,#0]
000036  f04f0100          MOV      r1,#0
00003a  6181              STR      r1,[r0,#0x18]
00003c  f04f0107          MOV      r1,#7
000040  6101              STR      r1,[r0,#0x10]
                  |L2.66|
;;;408    }
000042  bd10              POP      {r4,pc}
;;;409    
                          ENDP

                  |L2.68|
                          DCD      SystemFrequency
                  |L2.72|
                          DCD      0xe000ed23

                          AREA ||i.InitNet||, CODE, READONLY, ALIGN=2

                  InitNet PROC
;;;246    */
;;;247    void InitNet(void)
000000  b510              PUSH     {r4,lr}
;;;248    {
;;;249    	uip_ipaddr_t ipaddr;
;;;250    
;;;251    	/* 检测网卡芯片 */
;;;252    	{
;;;253    		uint32_t vid;
;;;254    
;;;255    		vid = dm9k_ReadID();
000002  f7fffffe          BL       dm9k_ReadID
;;;256    		if (vid == DM9000A_ID_OK)
;;;257    		{
;;;258    			//printf("DM9000AE Detect Ok, vid&pid = %08X\n\r", vid);
;;;259    		}
;;;260    		else
;;;261    		{
;;;262    			//printf("DM9000AE Detect Failed, vid&pid = %08X, Expected = %08X\n\r", vid, DM9000A_ID_OK);
;;;263    		}
;;;264    	}
;;;265    
;;;266    	tapdev_init();
000006  f7fffffe          BL       tapdev_init
;;;267    
;;;268    	//printf("uip_init\n\r");
;;;269    	uip_init();
00000a  f7fffffe          BL       uip_init
;;;270    
;;;271    	//printf("uip ip address : 192,168,20,11\n\r");
;;;272    	uip_ipaddr(ipaddr, 192,168,20,11);
;;;273    	uip_sethostaddr(ipaddr);
00000e  4909              LDR      r1,|L3.52|
000010  f64a00c0          MOV      r0,#0xa8c0            ;272
000014  f6403214          MOV      r2,#0xb14             ;272
000018  8008              STRH     r0,[r1,#0]
00001a  804a              STRH     r2,[r1,#2]
;;;274    
;;;275    	//printf("uip route address : 192,168,20,1\n\r");
;;;276    	uip_ipaddr(ipaddr, 192,168,20,1);
;;;277    	uip_setdraddr(ipaddr);
00001c  4906              LDR      r1,|L3.56|
00001e  f44f728a          MOV      r2,#0x114             ;276
000022  8008              STRH     r0,[r1,#0]
000024  804a              STRH     r2,[r1,#2]
;;;278    
;;;279    	//printf("uip net mask : 255,255,255,0\n\r");
;;;280    	uip_ipaddr(ipaddr, 255,255,255,0);
;;;281    	uip_setnetmask(ipaddr);
000026  4805              LDR      r0,|L3.60|
000028  f64f72ff          MOV      r2,#0xffff            ;280
00002c  21ff              MOVS     r1,#0xff              ;280
00002e  8002              STRH     r2,[r0,#0]
000030  8041              STRH     r1,[r0,#2]
;;;282    }
000032  bd10              POP      {r4,pc}
;;;283    
                          ENDP

                  |L3.52|
                          DCD      uip_hostaddr
                  |L3.56|
                          DCD      uip_draddr
                  |L3.60|
                          DCD      uip_netmask

                          AREA ||i.SetIP1||, CODE, READONLY, ALIGN=2

                  SetIP1 PROC
;;;284    
;;;285    void SetIP1(void)
000000  b510              PUSH     {r4,lr}
;;;286    {
;;;287    	uip_ipaddr_t ipaddr;
;;;288    
;;;289    	tapdev_init();
000002  f7fffffe          BL       tapdev_init
;;;290    	uip_init();
000006  f7fffffe          BL       uip_init
;;;291    
;;;292    	//printf("uip ip address : 192,168,20,11\n\r");
;;;293    	uip_ipaddr(ipaddr, 192,168,20,11);
;;;294    	uip_sethostaddr(ipaddr);
00000a  4909              LDR      r1,|L4.48|
00000c  f64a00c0          MOV      r0,#0xa8c0            ;293
000010  f6403214          MOV      r2,#0xb14             ;293
000014  8008              STRH     r0,[r1,#0]
000016  804a              STRH     r2,[r1,#2]
;;;295    
;;;296    	//printf("uip route address : 192,168,20,1\n\r");
;;;297    	uip_ipaddr(ipaddr, 192,168,20,1);
;;;298    	uip_setdraddr(ipaddr);
000018  4906              LDR      r1,|L4.52|
00001a  f44f728a          MOV      r2,#0x114             ;297
00001e  8008              STRH     r0,[r1,#0]
000020  804a              STRH     r2,[r1,#2]
;;;299    
;;;300    	//printf("uip net mask : 255,255,255,0\n\r");
;;;301    	uip_ipaddr(ipaddr, 255,255,255,0);
;;;302    	uip_setnetmask(ipaddr);
000022  4805              LDR      r0,|L4.56|
000024  f64f72ff          MOV      r2,#0xffff            ;301
000028  21ff              MOVS     r1,#0xff              ;301
00002a  8002              STRH     r2,[r0,#0]
00002c  8041              STRH     r1,[r0,#2]
;;;303    }
00002e  bd10              POP      {r4,pc}
;;;304    
                          ENDP

                  |L4.48|
                          DCD      uip_hostaddr
                  |L4.52|
                          DCD      uip_draddr
                  |L4.56|
                          DCD      uip_netmask

                          AREA ||i.SetIP2||, CODE, READONLY, ALIGN=2

                  SetIP2 PROC
;;;304    
;;;305    void SetIP2(void)
000000  b510              PUSH     {r4,lr}
;;;306    {
;;;307    	uip_ipaddr_t ipaddr;
;;;308    
;;;309    	tapdev_init();
000002  f7fffffe          BL       tapdev_init
;;;310    	uip_init();
000006  f7fffffe          BL       uip_init
;;;311    
;;;312    	//printf("uip ip address : 192,168,20,11\n\r");
;;;313    	uip_ipaddr(ipaddr, 192,168,20,12);
;;;314    	uip_sethostaddr(ipaddr);
00000a  4909              LDR      r1,|L5.48|
00000c  f64a00c0          MOV      r0,#0xa8c0            ;313
000010  f6404214          MOV      r2,#0xc14             ;313
000014  8008              STRH     r0,[r1,#0]
000016  804a              STRH     r2,[r1,#2]
;;;315    
;;;316    	//printf("uip route address : 192,168,20,1\n\r");
;;;317    	uip_ipaddr(ipaddr, 192,168,20,1);
;;;318    	uip_setdraddr(ipaddr);
000018  4906              LDR      r1,|L5.52|
00001a  f44f728a          MOV      r2,#0x114             ;317
00001e  8008              STRH     r0,[r1,#0]
000020  804a              STRH     r2,[r1,#2]
;;;319    
;;;320    	//printf("uip net mask : 255,255,255,0\n\r");
;;;321    	uip_ipaddr(ipaddr, 255,255,255,0);
;;;322    	uip_setnetmask(ipaddr);
000022  4805              LDR      r0,|L5.56|
000024  f64f72ff          MOV      r2,#0xffff            ;321
000028  21ff              MOVS     r1,#0xff              ;321
00002a  8002              STRH     r2,[r0,#0]
00002c  8041              STRH     r1,[r0,#2]
;;;323    }
00002e  bd10              POP      {r4,pc}
;;;324    
                          ENDP

                  |L5.48|
                          DCD      uip_hostaddr
                  |L5.52|
                          DCD      uip_draddr
                  |L5.56|
                          DCD      uip_netmask

                          AREA ||i.UipPro||, CODE, READONLY, ALIGN=2

                  UipPro PROC
;;;143    */
;;;144    void UipPro(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;145    {
;;;146    	uint8_t i;
;;;147    	static struct timer periodic_timer, arp_timer;
;;;148    	static char timer_ok = 0;	/* armfly */
;;;149    
;;;150    	/* 创建2个定时器，只用执行1次 */
;;;151    	if (timer_ok == 0)
000004  483d              LDR      r0,|L6.252|
000006  7801              LDRB     r1,[r0,#0]  ; timer_ok
000008  b959              CBNZ     r1,|L6.34|
;;;152    	{
;;;153    		timer_ok = 1;
00000a  2101              MOVS     r1,#1
00000c  7001              STRB     r1,[r0,#0]
;;;154    		timer_set(&periodic_timer, CLOCK_SECOND / 2);  /* 创建1个0.5秒的定时器 */
00000e  2132              MOVS     r1,#0x32
000010  3018              ADDS     r0,r0,#0x18
000012  f7fffffe          BL       timer_set
;;;155    		timer_set(&arp_timer, CLOCK_SECOND * 10);	   /* 创建1个10秒的定时器 */
000016  4839              LDR      r0,|L6.252|
000018  f44f717a          MOV      r1,#0x3e8
00001c  3020              ADDS     r0,r0,#0x20
00001e  f7fffffe          BL       timer_set
                  |L6.34|
;;;156    	}
;;;157    
;;;158    	/*
;;;159    		从网络设备读取一个IP包,返回数据长度 (非阻塞)
;;;160    		这个地方没有使用DM9000AEP的中断功能，采用的是查询方式
;;;161    	*/
;;;162    	uip_len = tapdev_read();	/* uip_len 是在uip中定义的全局变量 */
000022  f7fffffe          BL       tapdev_read
000026  4c36              LDR      r4,|L6.256|
000028  8020              STRH     r0,[r4,#0]
;;;163    	if(uip_len > 0)
00002a  b300              CBZ      r0,|L6.110|
;;;164    	{
;;;165    		/* 处理IP数据包(只有校验通过的IP包才会被接收) */
;;;166    		if(BUF->type == htons(UIP_ETHTYPE_IP))
00002c  f44f6000          MOV      r0,#0x800
000030  f7fffffe          BL       htons
000034  4d33              LDR      r5,|L6.260|
000036  89a9              LDRH     r1,[r5,#0xc]  ; uip_buf
000038  4288              CMP      r0,r1
00003a  d108              BNE      |L6.78|
;;;167    		{
;;;168    			uip_arp_ipin();
;;;169    			uip_input();
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       uip_process
;;;170    			/*
;;;171    				当上面的函数执行后，如果需要发送数据，则全局变量 uip_len > 0
;;;172    				需要发送的数据在uip_buf, 长度是uip_len  (这是2个全局变量)
;;;173    			*/
;;;174    			if (uip_len > 0)
000042  8820              LDRH     r0,[r4,#0]  ; uip_len
000044  2800              CMP      r0,#0
000046  d057              BEQ      |L6.248|
;;;175    			{
;;;176    				uip_arp_out();
000048  f7fffffe          BL       uip_arp_out
;;;177    				tapdev_send();
00004c  e00b              B        |L6.102|
                  |L6.78|
;;;178    			}
;;;179    		}
;;;180    		/* 处理arp报文 */
;;;181    		else if (BUF->type == htons(UIP_ETHTYPE_ARP))
00004e  f6400006          MOV      r0,#0x806
000052  f7fffffe          BL       htons
000056  89a9              LDRH     r1,[r5,#0xc]  ; uip_buf
000058  4288              CMP      r0,r1
00005a  d14d              BNE      |L6.248|
;;;182    		{
;;;183    			uip_arp_arpin();
00005c  f7fffffe          BL       uip_arp_arpin
;;;184    			/*
;;;185    				当上面的函数执行后，如果需要发送数据，则全局变量 uip_len > 0
;;;186    				需要发送的数据在uip_buf, 长度是uip_len  (这是2个全局变量)
;;;187    			*/
;;;188    			if (uip_len > 0)
000060  8820              LDRH     r0,[r4,#0]  ; uip_len
000062  2800              CMP      r0,#0
000064  d048              BEQ      |L6.248|
                  |L6.102|
;;;189    			{
;;;190    				tapdev_send();
000066  e8bd41f0          POP      {r4-r8,lr}
00006a  f7ffbffe          B.W      tapdev_send
                  |L6.110|
;;;191    			}
;;;192    		}
;;;193    	}
;;;194    	else if(timer_expired(&periodic_timer))	/* 0.5秒定时器超时 */
00006e  4823              LDR      r0,|L6.252|
000070  3018              ADDS     r0,r0,#0x18
000072  f7fffffe          BL       timer_expired
000076  2800              CMP      r0,#0
000078  d03e              BEQ      |L6.248|
;;;195    	{
;;;196    		timer_reset(&periodic_timer);	/* 复位0.5秒定时器 */
00007a  4820              LDR      r0,|L6.252|
00007c  3018              ADDS     r0,r0,#0x18
00007e  f7fffffe          BL       timer_reset
;;;197    
;;;198    		/* 轮流处理每个TCP连接, UIP_CONNS缺省是10个 */
;;;199    		for(i = 0; i < UIP_CONNS; i++)
;;;200    		{
;;;201    			uip_periodic(i);	/* 处理TCP通信事件 */
000082  4e21              LDR      r6,|L6.264|
000084  4f21              LDR      r7,|L6.268|
000086  2500              MOVS     r5,#0                 ;199
                  |L6.136|
000088  eb050045          ADD      r0,r5,r5,LSL #1
00008c  ebc01045          RSB      r0,r0,r5,LSL #5
000090  eb060080          ADD      r0,r6,r0,LSL #2
000094  6038              STR      r0,[r7,#0]  ; uip_conn
000096  2002              MOVS     r0,#2
000098  f7fffffe          BL       uip_process
;;;202    			/*
;;;203    				当上面的函数执行后，如果需要发送数据，则全局变量 uip_len > 0
;;;204    				需要发送的数据在uip_buf, 长度是uip_len  (这是2个全局变量)
;;;205    			*/
;;;206    			if(uip_len > 0)
00009c  8820              LDRH     r0,[r4,#0]  ; uip_len
00009e  b118              CBZ      r0,|L6.168|
;;;207    			{
;;;208    				uip_arp_out();
0000a0  f7fffffe          BL       uip_arp_out
;;;209    				tapdev_send();
0000a4  f7fffffe          BL       tapdev_send
                  |L6.168|
0000a8  1c6d              ADDS     r5,r5,#1              ;199
0000aa  b2ed              UXTB     r5,r5                 ;199
0000ac  2d28              CMP      r5,#0x28              ;199
0000ae  d3eb              BCC      |L6.136|
;;;210    			}
;;;211    		}
;;;212    
;;;213    	#if UIP_UDP
;;;214    		/* 轮流处理每个UDP连接, UIP_UDP_CONNS缺省是10个 */
;;;215    		for(i = 0; i < UIP_UDP_CONNS; i++)
;;;216    		{
;;;217    			uip_udp_periodic(i);	/*处理UDP通信事件 */
0000b0  4e17              LDR      r6,|L6.272|
0000b2  4f18              LDR      r7,|L6.276|
0000b4  2500              MOVS     r5,#0                 ;215
0000b6  bf00              NOP      
                  |L6.184|
0000b8  eb050045          ADD      r0,r5,r5,LSL #1
0000bc  eb0600c0          ADD      r0,r6,r0,LSL #3
0000c0  6038              STR      r0,[r7,#0]  ; uip_udp_conn
0000c2  2005              MOVS     r0,#5
0000c4  f7fffffe          BL       uip_process
;;;218    			/* If the above function invocation resulted in data that
;;;219    			should be sent out on the network, the global variable
;;;220    			uip_len is set to a value > 0. */
;;;221    			if(uip_len > 0)
0000c8  8820              LDRH     r0,[r4,#0]  ; uip_len
0000ca  b118              CBZ      r0,|L6.212|
;;;222    			{
;;;223    			uip_arp_out();
0000cc  f7fffffe          BL       uip_arp_out
;;;224    			tapdev_send();
0000d0  f7fffffe          BL       tapdev_send
                  |L6.212|
0000d4  1c6d              ADDS     r5,r5,#1              ;215
0000d6  b2ed              UXTB     r5,r5                 ;215
0000d8  2d0a              CMP      r5,#0xa               ;215
0000da  d3ed              BCC      |L6.184|
;;;225    			}
;;;226    		}
;;;227    	#endif /* UIP_UDP */
;;;228    
;;;229    		/* 每隔10秒调用1次ARP定时器函数 */
;;;230    		if (timer_expired(&arp_timer))
0000dc  4807              LDR      r0,|L6.252|
0000de  3020              ADDS     r0,r0,#0x20
0000e0  f7fffffe          BL       timer_expired
0000e4  2800              CMP      r0,#0
0000e6  d007              BEQ      |L6.248|
;;;231    		{
;;;232    			timer_reset(&arp_timer);
0000e8  4804              LDR      r0,|L6.252|
0000ea  3020              ADDS     r0,r0,#0x20
0000ec  f7fffffe          BL       timer_reset
;;;233    			uip_arp_timer();
0000f0  e8bd41f0          POP      {r4-r8,lr}
0000f4  f7ffbffe          B.W      uip_arp_timer
                  |L6.248|
;;;234    		}
;;;235    	}
;;;236    }
0000f8  e8bd81f0          POP      {r4-r8,pc}
;;;237    
                          ENDP

                  |L6.252|
                          DCD      ||.data||
                  |L6.256|
                          DCD      uip_len
                  |L6.260|
                          DCD      uip_buf
                  |L6.264|
                          DCD      uip_conns
                  |L6.268|
                          DCD      uip_conn
                  |L6.272|
                          DCD      uip_udp_conns
                  |L6.276|
                          DCD      uip_udp_conn

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _scanf_string
                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  main PROC
;;;59     
;;;60     int main(void)
000000  f7fffffe          BL       InitBoard
;;;61     {  
;;;62     
;;;63     	InitBoard();	/* 为了是main函数看起来更简洁些，我们将初始化的代码封装到这个函数 */
000004  a12d              ADR      r1,|L7.188|
000006  a030              ADR      r0,|L7.200|
000008  f7fffffe          BL       PrintfLogo
;;;64     	DispLogo();		/* 显示例程Logo */
;;;65     
;;;66     	InitNet();		/* 初始化网络设备以及UIP协议栈，配置IP地址 */
00000c  f7fffffe          BL       InitNet
;;;67     
;;;68     	/* 创建一个TCP监听端口，端口号为1000 */
;;;69     	//uip_listen(HTONS(1000));
;;;70     
;;;71     	printf("\n\rBuilding UDP connectiong to 192.168.20.156...\n\n\r");
000010  a032              ADR      r0,|L7.220|
000012  f7fffffe          BL       __2printf
;;;72     
;;;73     	while(1)
;;;74     	{
;;;75     		 //InitNet();
;;;76     		 if(i_ip==0)
000016  2500              MOVS     r5,#0
000018  4c3d              LDR      r4,|L7.272|
;;;77     		 {
;;;78     		 	SetIP1();
;;;79     			i_ip=1;
00001a  2601              MOVS     r6,#1
                  |L7.28|
00001c  6960              LDR      r0,[r4,#0x14]         ;76  ; i_ip
00001e  b140              CBZ      r0,|L7.50|
;;;80     		 }
;;;81     		 else
;;;82     		 {
;;;83     		 	SetIP2();
000020  f7fffffe          BL       SetIP2
;;;84     			i_ip=0;
000024  f8c45014          STR.W    r5,[r4,#0x14]
                  |L7.40|
;;;85     		 }
;;;86     
;;;87     		uip_udp_init();
000028  f7fffffe          BL       uip_udp_init
;;;88     
;;;89     		if(circle_flag==0)
00002c  68e0              LDR      r0,[r4,#0xc]  ; circle_flag
00002e  b120              CBZ      r0,|L7.58|
000030  e03e              B        |L7.176|
                  |L7.50|
000032  f7fffffe          BL       SetIP1
000036  6166              STR      r6,[r4,#0x14]         ;79  ; i_ip
000038  e7f6              B        |L7.40|
                  |L7.58|
;;;90     		{
;;;91     		//display main menu
;;;92     		printf("\t\t<--Main Menu-->\t\t\n\n\r");
00003a  a036              ADR      r0,|L7.276|
00003c  f7fffffe          BL       __2printf
;;;93     		printf(" 1.	Get Status\n\r");
000040  a03a              ADR      r0,|L7.300|
000042  f7fffffe          BL       __2printf
;;;94     		printf(" 2.	Start SpeedTest\n\r");
000046  a03e              ADR      r0,|L7.320|
000048  f7fffffe          BL       __2printf
;;;95     		printf(" 3.	Get SpeedTestStatus\n\r");
00004c  a042              ADR      r0,|L7.344|
00004e  f7fffffe          BL       __2printf
;;;96     		printf(" 4.	Get PhyRate\n\r");
000052  a048              ADR      r0,|L7.372|
000054  f7fffffe          BL       __2printf
;;;97     		printf(" 5.	System Command\n\r");
000058  a04b              ADR      r0,|L7.392|
00005a  f7fffffe          BL       __2printf
;;;98     		printf(" 6.	System GetPhyRate\n\r");
00005e  a050              ADR      r0,|L7.416|
000060  f7fffffe          BL       __2printf
;;;99     		printf(" 7.	Get All Messages\n\r");
000064  a054              ADR      r0,|L7.440|
000066  f7fffffe          BL       __2printf
;;;100    		printf(" 8.	Set Mac Address\n\r");
00006a  a059              ADR      r0,|L7.464|
00006c  f7fffffe          BL       __2printf
;;;101    		printf(" 9.	Start ChannelEstimate\n\r");
000070  a05d              ADR      r0,|L7.488|
000072  f7fffffe          BL       __2printf
;;;102    		printf(" a.	Get CINR Map\n\r");
000076  a063              ADR      r0,|L7.516|
000078  f7fffffe          BL       __2printf
;;;103    		printf(" 0.	Exit\n\r");
00007c  a066              ADR      r0,|L7.536|
00007e  f7fffffe          BL       __2printf
;;;104    		printf("\n\r	Input-->");
000082  a068              ADR      r0,|L7.548|
000084  f7fffffe          BL       __2printf
;;;105    
;;;106    		//c_choice=getc(stdin);
;;;107    		scanf("%s",inStr); 
000088  4969              LDR      r1,|L7.560|
00008a  a06a              ADR      r0,|L7.564|
00008c  f7fffffe          BL       __0scanf
;;;108    		c_choice=(unsigned char)inStr[0];	 		
000090  4867              LDR      r0,|L7.560|
000092  7801              LDRB     r1,[r0,#0]  ; inStr
000094  7061              STRB     r1,[r4,#1]
;;;109    
;;;110    		if(c_choice=='7'||c_choice=='8')
000096  2937              CMP      r1,#0x37
000098  d001              BEQ      |L7.158|
00009a  2938              CMP      r1,#0x38
00009c  d101              BNE      |L7.162|
                  |L7.158|
00009e  e9c46503          STRD     r6,r5,[r4,#0xc]
                  |L7.162|
;;;111    		{
;;;112    			circle_flag=1;
;;;113    			circle_state=0;
;;;114    		}
;;;115    		send_flag=1;
;;;116    		rec_flag=0;
;;;117    		uip_len=0; 
0000a2  4865              LDR      r0,|L7.568|
0000a4  e9c46501          STRD     r6,r5,[r4,#4]
0000a8  8005              STRH     r5,[r0,#0]
;;;118    		printf(" %c\n\n\r",c_choice);
0000aa  a064              ADR      r0,|L7.572|
0000ac  f7fffffe          BL       __2printf
                  |L7.176|
;;;119    
;;;120    		}
;;;121    
;;;122    		while (1)
;;;123    		{
;;;124    			UipPro();		/* 处理uip事件，必须插入到用户程序的循环体中 */
0000b0  f7fffffe          BL       UipPro
;;;125    
;;;126    			//uip_udp_init();	
;;;127    
;;;128    			if(rec_flag)break;		 
0000b4  68a0              LDR      r0,[r4,#8]  ; rec_flag
0000b6  2800              CMP      r0,#0
0000b8  d0fa              BEQ      |L7.176|
0000ba  e7af              B        |L7.28|
;;;129    			
;;;130    		}	
;;;131    
;;;132    
;;;133    	}
;;;134    }
;;;135    
                          ENDP

                  |L7.188|
0000bc  32303135          DCB      "2015-10-14",0
0000c0  2d31302d
0000c4  313400  
0000c7  00                DCB      0
                  |L7.200|
0000c8  6864706c          DCB      "hdplc_testProgram",0
0000cc  635f7465
0000d0  73745072
0000d4  6f677261
0000d8  6d00    
0000da  00                DCB      0
0000db  00                DCB      0
                  |L7.220|
0000dc  0a0d4275          DCB      "\n\rBuilding UDP connectiong to 192.168.20.156...\n\n\r"
0000e0  696c6469
0000e4  6e672055
0000e8  44502063
0000ec  6f6e6e65
0000f0  6374696f
0000f4  6e672074
0000f8  6f203139
0000fc  322e3136
000100  382e3230
000104  2e313536
000108  2e2e2e0a
00010c  0a0d    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L7.272|
                          DCD      ||.data||
                  |L7.276|
000114  09093c2d          DCB      "\t\t<--Main Menu-->\t\t\n\n\r",0
000118  2d4d6169
00011c  6e204d65
000120  6e752d2d
000124  3e09090a
000128  0a0d00  
00012b  00                DCB      0
                  |L7.300|
00012c  20312e09          DCB      " 1.\tGet Status\n\r",0
000130  47657420
000134  53746174
000138  75730a0d
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L7.320|
000140  20322e09          DCB      " 2.\tStart SpeedTest\n\r",0
000144  53746172
000148  74205370
00014c  65656454
000150  6573740a
000154  0d00    
000156  00                DCB      0
000157  00                DCB      0
                  |L7.344|
000158  20332e09          DCB      " 3.\tGet SpeedTestStatus\n\r",0
00015c  47657420
000160  53706565
000164  64546573
000168  74537461
00016c  7475730a
000170  0d00    
000172  00                DCB      0
000173  00                DCB      0
                  |L7.372|
000174  20342e09          DCB      " 4.\tGet PhyRate\n\r",0
000178  47657420
00017c  50687952
000180  6174650a
000184  0d00    
000186  00                DCB      0
000187  00                DCB      0
                  |L7.392|
000188  20352e09          DCB      " 5.\tSystem Command\n\r",0
00018c  53797374
000190  656d2043
000194  6f6d6d61
000198  6e640a0d
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L7.416|
0001a0  20362e09          DCB      " 6.\tSystem GetPhyRate\n\r",0
0001a4  53797374
0001a8  656d2047
0001ac  65745068
0001b0  79526174
0001b4  650a0d00
                  |L7.440|
0001b8  20372e09          DCB      " 7.\tGet All Messages\n\r",0
0001bc  47657420
0001c0  416c6c20
0001c4  4d657373
0001c8  61676573
0001cc  0a0d00  
0001cf  00                DCB      0
                  |L7.464|
0001d0  20382e09          DCB      " 8.\tSet Mac Address\n\r",0
0001d4  53657420
0001d8  4d616320
0001dc  41646472
0001e0  6573730a
0001e4  0d00    
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L7.488|
0001e8  20392e09          DCB      " 9.\tStart ChannelEstimate\n\r",0
0001ec  53746172
0001f0  74204368
0001f4  616e6e65
0001f8  6c457374
0001fc  696d6174
000200  650a0d00
                  |L7.516|
000204  20612e09          DCB      " a.\tGet CINR Map\n\r",0
000208  47657420
00020c  43494e52
000210  204d6170
000214  0a0d00  
000217  00                DCB      0
                  |L7.536|
000218  20302e09          DCB      " 0.\tExit\n\r",0
00021c  45786974
000220  0a0d00  
000223  00                DCB      0
                  |L7.548|
000224  0a0d0949          DCB      "\n\r\tInput-->",0
000228  6e707574
00022c  2d2d3e00
                  |L7.560|
                          DCD      ||.bss||
                  |L7.564|
000234  257300            DCB      "%s",0
000237  00                DCB      0
                  |L7.568|
                          DCD      uip_len
                  |L7.572|
00023c  2025630a          DCB      " %c\n\n\r",0
000240  0a0d00  
000243  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  inStr
                          %        100

                          AREA ||.data||, DATA, ALIGN=2

                  timer_ok
000000  00                DCB      0x00
                  c_choice
000001  000000            DCB      0x00,0x00,0x00
                  send_flag
                          DCD      0x00000000
                  rec_flag
                          DCD      0x00000000
                  circle_flag
                          DCD      0x00000000
                  circle_state
                          DCD      0x00000000
                  i_ip
                          DCD      0x00000000
                  periodic_timer
                          %        8
                  arp_timer
                          %        8

                  __ARM_use_no_argv EQU 0
