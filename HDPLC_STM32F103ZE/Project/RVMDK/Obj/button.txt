; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\button.o --depend=.\Obj\button.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Source\src\button.c]
                          THUMB

                          AREA ||i.DetectButton||, CODE, READONLY, ALIGN=1

                  DetectButton PROC
;;;192    */
;;;193    static void DetectButton(BUTTON_T *_pBtn)
000000  b510              PUSH     {r4,lr}
;;;194    {
000002  4604              MOV      r4,r0
;;;195    	/* 如果没有初始化按键函数，则报错
;;;196    	if (_pBtn->IsKeyDownFunc == 0)
;;;197    	{
;;;198    		printf("Fault : DetectButton(), _pBtn->IsKeyDownFunc undefine");
;;;199    	}
;;;200    	*/
;;;201    
;;;202    	if (_pBtn->IsKeyDownFunc())
000004  6800              LDR      r0,[r0,#0]
000006  4780              BLX      r0
000008  2800              CMP      r0,#0
;;;203    	{
;;;204    		if (_pBtn->Count < _pBtn->FilterTime)
;;;205    		{
;;;206    			_pBtn->Count = _pBtn->FilterTime;
;;;207    		}
;;;208    		else if(_pBtn->Count < 2 * _pBtn->FilterTime)
;;;209    		{
;;;210    			_pBtn->Count++;
;;;211    		}
;;;212    		else
;;;213    		{
;;;214    			if (_pBtn->State == 0)
;;;215    			{
;;;216    				_pBtn->State = 1;
;;;217    
;;;218    				/* 发送按钮按下的消息 */
;;;219    				if (_pBtn->KeyCodeDown > 0)
;;;220    				{
;;;221    					/* 键值放入按键FIFO */
;;;222    					PutKey(_pBtn->KeyCodeDown);
;;;223    				}
;;;224    			}
;;;225    
;;;226    			if (_pBtn->LongTime > 0)
;;;227    			{
;;;228    				if (_pBtn->LongCount < _pBtn->LongTime)
;;;229    				{
;;;230    					/* 发送按钮持续按下的消息 */
;;;231    					if (++_pBtn->LongCount == _pBtn->LongTime)
;;;232    					{
;;;233    						/* 键值放入按键FIFO */
;;;234    						PutKey(_pBtn->KeyCodeLong);
;;;235    					}
;;;236    				}
;;;237    			}
;;;238    		}
;;;239    	}
;;;240    	else
;;;241    	{
;;;242    		if(_pBtn->Count > _pBtn->FilterTime)
00000a  7920              LDRB     r0,[r4,#4]
00000c  7961              LDRB     r1,[r4,#5]
00000e  d021              BEQ      |L1.84|
000010  4288              CMP      r0,r1                 ;204
000012  d201              BCS      |L1.24|
000014  7121              STRB     r1,[r4,#4]            ;206
;;;243    		{
;;;244    			_pBtn->Count = _pBtn->FilterTime;
;;;245    		}
;;;246    		else if(_pBtn->Count != 0)
;;;247    		{
;;;248    			_pBtn->Count--;
;;;249    		}
;;;250    		else
;;;251    		{
;;;252    			if (_pBtn->State == 1)
;;;253    			{
;;;254    				_pBtn->State = 0;
;;;255    
;;;256    				/* 发送按钮弹起的消息 */
;;;257    				if (_pBtn->KeyCodeUp > 0)
;;;258    				{
;;;259    					/* 键值放入按键FIFO */
;;;260    					PutKey(_pBtn->KeyCodeUp);
;;;261    				}
;;;262    			}
;;;263    		}
;;;264    
;;;265    		_pBtn->LongCount = 0;
;;;266    	}
;;;267    }
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  ebb00f41          CMP      r0,r1,LSL #1          ;208
00001c  d202              BCS      |L1.36|
00001e  1c40              ADDS     r0,r0,#1              ;210
000020  7120              STRB     r0,[r4,#4]            ;210
                  |L1.34|
000022  bd10              POP      {r4,pc}
                  |L1.36|
000024  7aa0              LDRB     r0,[r4,#0xa]          ;214
000026  b928              CBNZ     r0,|L1.52|
000028  2001              MOVS     r0,#1                 ;216
00002a  72a0              STRB     r0,[r4,#0xa]          ;216
00002c  7b20              LDRB     r0,[r4,#0xc]          ;219
00002e  b108              CBZ      r0,|L1.52|
000030  f7fffffe          BL       PutKey
                  |L1.52|
000034  8920              LDRH     r0,[r4,#8]            ;226
000036  2800              CMP      r0,#0                 ;226
000038  d0f3              BEQ      |L1.34|
00003a  88e1              LDRH     r1,[r4,#6]            ;228
00003c  4281              CMP      r1,r0                 ;228
00003e  d2f0              BCS      |L1.34|
000040  1c49              ADDS     r1,r1,#1              ;231
000042  b289              UXTH     r1,r1                 ;231
000044  80e1              STRH     r1,[r4,#6]            ;231
000046  4281              CMP      r1,r0                 ;231
000048  d1eb              BNE      |L1.34|
00004a  7b60              LDRB     r0,[r4,#0xd]          ;234
00004c  e8bd4010          POP      {r4,lr}               ;234
000050  f7ffbffe          B.W      PutKey
                  |L1.84|
000054  2300              MOVS     r3,#0                 ;214
000056  4288              CMP      r0,r1                 ;242
000058  d901              BLS      |L1.94|
00005a  7121              STRB     r1,[r4,#4]            ;244
00005c  e00b              B        |L1.118|
                  |L1.94|
00005e  b110              CBZ      r0,|L1.102|
000060  1e40              SUBS     r0,r0,#1              ;248
000062  7120              STRB     r0,[r4,#4]            ;248
000064  e007              B        |L1.118|
                  |L1.102|
000066  7aa0              LDRB     r0,[r4,#0xa]          ;252
000068  2801              CMP      r0,#1                 ;252
00006a  d104              BNE      |L1.118|
00006c  72a3              STRB     r3,[r4,#0xa]          ;254
00006e  7ae0              LDRB     r0,[r4,#0xb]          ;257
000070  b108              CBZ      r0,|L1.118|
000072  f7fffffe          BL       PutKey
                  |L1.118|
000076  80e3              STRH     r3,[r4,#6]            ;265
000078  bd10              POP      {r4,pc}
;;;268    
                          ENDP


                          AREA ||i.GetKey||, CODE, READONLY, ALIGN=2

                  GetKey PROC
;;;166    */
;;;167    uint8_t GetKey(void)
000000  4907              LDR      r1,|L2.32|
;;;168    {
;;;169    	uint8_t ret;
;;;170    
;;;171    	if (s_Key.Read == s_Key.Write)
000002  7d0a              LDRB     r2,[r1,#0x14]  ; s_Key
000004  7d48              LDRB     r0,[r1,#0x15]  ; s_Key
000006  4282              CMP      r2,r0
000008  d101              BNE      |L2.14|
;;;172    	{
;;;173    		return KEY_NONE;
00000a  2000              MOVS     r0,#0
                  |L2.12|
;;;174    	}
;;;175    	else
;;;176    	{
;;;177    		ret = s_Key.Buf[s_Key.Read];
;;;178    
;;;179    		if (++s_Key.Read >= KEY_FIFO_SIZE)
;;;180    		{
;;;181    			s_Key.Read = 0;
;;;182    		}
;;;183    		return ret;
;;;184    	}
;;;185    }
00000c  4770              BX       lr
                  |L2.14|
00000e  5c88              LDRB     r0,[r1,r2]            ;177
000010  1c52              ADDS     r2,r2,#1              ;179
000012  b2d2              UXTB     r2,r2                 ;179
000014  750a              STRB     r2,[r1,#0x14]         ;179
000016  2a14              CMP      r2,#0x14              ;179
000018  d3f8              BCC      |L2.12|
00001a  2200              MOVS     r2,#0                 ;181
00001c  750a              STRB     r2,[r1,#0x14]         ;181
00001e  4770              BX       lr
;;;186    
                          ENDP

                  |L2.32|
                          DCD      ||.bss||+0x80

                          AREA ||i.InitButtonVar||, CODE, READONLY, ALIGN=2

                  InitButtonVar PROC
;;;57     */
;;;58     void InitButtonVar(void)
000000  b510              PUSH     {r4,lr}
;;;59     {
;;;60     	/* 对按键FIFO读写指针清零 */
;;;61     	s_Key.Read = 0;
000002  4930              LDR      r1,|L3.196|
000004  2000              MOVS     r0,#0
;;;62     	s_Key.Write = 0;
;;;63     
;;;64     	/* 初始化USER按键变量 */
;;;65     	s_BtnUser.IsKeyDownFunc = IsKeyDownUser;	/* 判断按键按下的函数 */
000006  4b2f              LDR      r3,|L3.196|
000008  7508              STRB     r0,[r1,#0x14]         ;61
00000a  7548              STRB     r0,[r1,#0x15]         ;62
00000c  3b80              SUBS     r3,r3,#0x80
00000e  492e              LDR      r1,|L3.200|
;;;66     	s_BtnUser.FilterTime = BUTTON_FILTER_TIME;	/* 按键滤波时间 */
000010  6019              STR      r1,[r3,#0]  ; s_BtnUser
000012  2105              MOVS     r1,#5
000014  7159              STRB     r1,[r3,#5]
;;;67     	s_BtnUser.LongTime = BUTTON_LONG_TIME;		/* 长按时间 */
000016  2264              MOVS     r2,#0x64
000018  811a              STRH     r2,[r3,#8]
;;;68     	s_BtnUser.Count = s_BtnUser.FilterTime / 2;	/* 计数器设置为滤波时间的一半 */
00001a  2202              MOVS     r2,#2
00001c  711a              STRB     r2,[r3,#4]
;;;69     	s_BtnUser.State = 0;						/* 按键缺省状态，0为未按下 */
00001e  7298              STRB     r0,[r3,#0xa]
;;;70     	s_BtnUser.KeyCodeDown = KEY_DOWN_USER;		/* 按键按下的键值代码 */
000020  2401              MOVS     r4,#1
000022  731c              STRB     r4,[r3,#0xc]
;;;71     	s_BtnUser.KeyCodeUp = KEY_UP_USER;			/* 按键弹起的键值代码 */
000024  72da              STRB     r2,[r3,#0xb]
;;;72     	s_BtnUser.KeyCodeLong = KEY_HOLD_USER;		/* 按键被持续按下的键值代码 */
000026  2403              MOVS     r4,#3
000028  735c              STRB     r4,[r3,#0xd]
;;;73     
;;;74     	/* 初始化TAMPER按键变量 */
;;;75     	s_BtnTamper.IsKeyDownFunc = IsKeyDownTamper;	/* 判断按键按下的函数 */
00002a  3310              ADDS     r3,r3,#0x10
00002c  4c27              LDR      r4,|L3.204|
;;;76     	s_BtnTamper.FilterTime = BUTTON_FILTER_TIME;	/* 按键滤波时间 */
00002e  601c              STR      r4,[r3,#0]  ; s_BtnTamper
000030  7159              STRB     r1,[r3,#5]
;;;77     	s_BtnTamper.LongTime = 0;						/* 长按时间, 0表示不检测 */
000032  8118              STRH     r0,[r3,#8]
;;;78     	s_BtnTamper.Count = s_BtnTamper.FilterTime / 2;	/* 计数器设置为滤波时间的一半 */
000034  711a              STRB     r2,[r3,#4]
;;;79     	s_BtnTamper.State = 0;							/* 按键缺省状态，0为未按下 */
000036  7298              STRB     r0,[r3,#0xa]
;;;80     	s_BtnTamper.KeyCodeDown = KEY_DOWN_TAMPER;		/* 按键按下的键值代码 */
000038  7319              STRB     r1,[r3,#0xc]
;;;81     	s_BtnTamper.KeyCodeUp = 0;						/* 按键弹起的键值代码 */
00003a  72d8              STRB     r0,[r3,#0xb]
;;;82     	s_BtnTamper.KeyCodeLong = 0;					/* 按键被持续按下的键值代码 */
00003c  7358              STRB     r0,[r3,#0xd]
;;;83     
;;;84     	/* 初始化WAKEUP按键变量 */
;;;85     	s_BtnWakeUp.IsKeyDownFunc = IsKeyDownWakeUp;	/* 判断按键按下的函数 */
00003e  3310              ADDS     r3,r3,#0x10
000040  4c23              LDR      r4,|L3.208|
;;;86     	s_BtnWakeUp.FilterTime = BUTTON_FILTER_TIME;	/* 按键滤波时间 */
000042  601c              STR      r4,[r3,#0]  ; s_BtnWakeUp
000044  7159              STRB     r1,[r3,#5]
;;;87     	s_BtnWakeUp.LongTime = 0;						/* 长按时间 */
000046  8118              STRH     r0,[r3,#8]
;;;88     	s_BtnWakeUp.Count = s_BtnWakeUp.FilterTime / 2;	/* 计数器设置为滤波时间的一半 */
000048  711a              STRB     r2,[r3,#4]
;;;89     	s_BtnWakeUp.State = 0;							/* 按键缺省状态，0为未按下 */
00004a  7298              STRB     r0,[r3,#0xa]
;;;90     	s_BtnWakeUp.KeyCodeUp = 0;						/* 按键弹起的键值代码，0表示不检测 */
00004c  72d8              STRB     r0,[r3,#0xb]
;;;91     	s_BtnWakeUp.KeyCodeDown = KEY_DOWN_WAKEUP;		/* 按键按下的键值代码 */
00004e  2404              MOVS     r4,#4
000050  731c              STRB     r4,[r3,#0xc]
;;;92     	s_BtnWakeUp.KeyCodeLong = 0;					/* 按键被持续按下的键值代码，0表示不检测 */
000052  7358              STRB     r0,[r3,#0xd]
;;;93     
;;;94     	/* 初始化UP按键变量 */
;;;95     	s_BtnUp.IsKeyDownFunc = IsKeyDownUp;		/* 判断按键按下的函数 */
000054  3310              ADDS     r3,r3,#0x10
000056  4c1f              LDR      r4,|L3.212|
;;;96     	s_BtnUp.FilterTime = BUTTON_FILTER_TIME;	/* 按键滤波时间 */
000058  601c              STR      r4,[r3,#0]  ; s_BtnUp
00005a  7159              STRB     r1,[r3,#5]
;;;97     	s_BtnUp.LongTime = 0;						/* 长按时间 */
00005c  8118              STRH     r0,[r3,#8]
;;;98     	s_BtnUp.Count = s_BtnUp.FilterTime / 2;		/* 计数器设置为滤波时间的一半 */
00005e  711a              STRB     r2,[r3,#4]
;;;99     	s_BtnUp.State = 0;							/* 按键缺省状态，0为未按下 */
000060  7298              STRB     r0,[r3,#0xa]
;;;100    	s_BtnUp.KeyCodeDown = KEY_DOWN_JOY_UP;		/* 按键按下的键值代码 */
000062  2406              MOVS     r4,#6
000064  731c              STRB     r4,[r3,#0xc]
;;;101    	s_BtnUp.KeyCodeUp = 0;						/* 按键弹起的键值代码，0表示不检测 */
000066  72d8              STRB     r0,[r3,#0xb]
;;;102    	s_BtnUp.KeyCodeLong = 0;					/* 按键被持续按下的键值代码，0表示不检测 */
000068  7358              STRB     r0,[r3,#0xd]
;;;103    
;;;104    	/* 初始化DOWN按键变量 */
;;;105    	s_BtnDown.IsKeyDownFunc = IsKeyDownDown;	/* 判断按键按下的函数 */
00006a  3310              ADDS     r3,r3,#0x10
00006c  4c1a              LDR      r4,|L3.216|
;;;106    	s_BtnDown.FilterTime = BUTTON_FILTER_TIME;	/* 按键滤波时间 */
00006e  601c              STR      r4,[r3,#0]  ; s_BtnDown
000070  7159              STRB     r1,[r3,#5]
;;;107    	s_BtnDown.LongTime = 0;						/* 长按时间 */
000072  8118              STRH     r0,[r3,#8]
;;;108    	s_BtnDown.Count = s_BtnDown.FilterTime / 2;	/* 计数器设置为滤波时间的一半 */
000074  711a              STRB     r2,[r3,#4]
;;;109    	s_BtnDown.State = 0;						/* 按键缺省状态，0为未按下 */
000076  7298              STRB     r0,[r3,#0xa]
;;;110    	s_BtnDown.KeyCodeDown = KEY_DOWN_JOY_DOWN;	/* 按键按下的键值代码 */
000078  2407              MOVS     r4,#7
00007a  731c              STRB     r4,[r3,#0xc]
;;;111    	s_BtnDown.KeyCodeUp = 0;					/* 按键弹起的键值代码，0表示不检测 */
00007c  72d8              STRB     r0,[r3,#0xb]
;;;112    	s_BtnDown.KeyCodeLong = 0;					/* 按键被持续按下的键值代码，0表示不检测 */
00007e  7358              STRB     r0,[r3,#0xd]
;;;113    
;;;114    	/* 初始化LEFT按键变量 */
;;;115    	s_BtnLeft.IsKeyDownFunc = IsKeyDownLeft;	/* 判断按键按下的函数 */
000080  3310              ADDS     r3,r3,#0x10
000082  4c16              LDR      r4,|L3.220|
;;;116    	s_BtnLeft.FilterTime = BUTTON_FILTER_TIME;	/* 按键滤波时间 */
000084  601c              STR      r4,[r3,#0]  ; s_BtnLeft
000086  7159              STRB     r1,[r3,#5]
;;;117    	s_BtnLeft.LongTime = 0;						/* 长按时间 */
000088  8118              STRH     r0,[r3,#8]
;;;118    	s_BtnLeft.Count = s_BtnLeft.FilterTime / 2;	/* 计数器设置为滤波时间的一半 */
00008a  711a              STRB     r2,[r3,#4]
;;;119    	s_BtnLeft.State = 0;						/* 按键缺省状态，0为未按下 */
00008c  7298              STRB     r0,[r3,#0xa]
;;;120    	s_BtnLeft.KeyCodeDown = KEY_DOWN_JOY_LEFT;	/* 按键按下的键值代码 */
00008e  2408              MOVS     r4,#8
000090  731c              STRB     r4,[r3,#0xc]
;;;121    	s_BtnLeft.KeyCodeUp = 0;					/* 按键弹起的键值代码，0表示不检测 */
000092  72d8              STRB     r0,[r3,#0xb]
;;;122    	s_BtnLeft.KeyCodeLong = 0;					/* 按键被持续按下的键值代码，0表示不检测 */
000094  7358              STRB     r0,[r3,#0xd]
;;;123    
;;;124    	/* 初始化RIGHT按键变量 */
;;;125    	s_BtnRight.IsKeyDownFunc = IsKeyDownRight;	/* 判断按键按下的函数 */
000096  3310              ADDS     r3,r3,#0x10
000098  4c11              LDR      r4,|L3.224|
;;;126    	s_BtnRight.FilterTime = BUTTON_FILTER_TIME;	/* 按键滤波时间 */
00009a  601c              STR      r4,[r3,#0]  ; s_BtnRight
00009c  7159              STRB     r1,[r3,#5]
;;;127    	s_BtnRight.LongTime = 0;					/* 长按时间 */
00009e  8118              STRH     r0,[r3,#8]
;;;128    	s_BtnRight.Count = s_BtnRight.FilterTime / 2;/* 计数器设置为滤波时间的一半 */
0000a0  711a              STRB     r2,[r3,#4]
;;;129    	s_BtnRight.State = 0;						/* 按键缺省状态，0为未按下 */
0000a2  7298              STRB     r0,[r3,#0xa]
;;;130    	s_BtnRight.KeyCodeDown = KEY_DOWN_JOY_RIGHT;/* 按键按下的键值代码 */
0000a4  2409              MOVS     r4,#9
0000a6  731c              STRB     r4,[r3,#0xc]
;;;131    	s_BtnRight.KeyCodeUp = 0;					/* 按键弹起的键值代码，0表示不检测 */
0000a8  72d8              STRB     r0,[r3,#0xb]
;;;132    	s_BtnRight.KeyCodeLong = 0;					/* 按键被持续按下的键值代码，0表示不检测 */
0000aa  7358              STRB     r0,[r3,#0xd]
;;;133    
;;;134    	/* 初始化OK按键变量 */
;;;135    	s_BtnOk.IsKeyDownFunc = IsKeyDownOk;		/* 判断按键按下的函数 */
0000ac  3310              ADDS     r3,r3,#0x10
0000ae  4c0d              LDR      r4,|L3.228|
;;;136    	s_BtnOk.FilterTime = BUTTON_FILTER_TIME;	/* 按键滤波时间 */
0000b0  601c              STR      r4,[r3,#0]  ; s_BtnOk
0000b2  7159              STRB     r1,[r3,#5]
;;;137    	s_BtnOk.LongTime = 0;						/* 长按时间 */
0000b4  8118              STRH     r0,[r3,#8]
;;;138    	s_BtnOk.Count = s_BtnOk.FilterTime / 2;		/* 计数器设置为滤波时间的一半 */
0000b6  711a              STRB     r2,[r3,#4]
;;;139    	s_BtnOk.State = 0;							/* 按键缺省状态，0为未按下 */
0000b8  7298              STRB     r0,[r3,#0xa]
;;;140    	s_BtnOk.KeyCodeDown = KEY_DOWN_JOY_OK;		/* 按键按下的键值代码 */
0000ba  210a              MOVS     r1,#0xa
0000bc  7319              STRB     r1,[r3,#0xc]
;;;141    	s_BtnOk.KeyCodeUp = 0;						/* 按键弹起的键值代码，0表示不检测 */
0000be  72d8              STRB     r0,[r3,#0xb]
;;;142    	s_BtnOk.KeyCodeLong = 0;					/* 按键被持续按下的键值代码，0表示不检测 */
0000c0  7358              STRB     r0,[r3,#0xd]
;;;143    }
0000c2  bd10              POP      {r4,pc}
;;;144    
                          ENDP

                  |L3.196|
                          DCD      ||.bss||+0x80
                  |L3.200|
                          DCD      IsKeyDownUser
                  |L3.204|
                          DCD      IsKeyDownTamper
                  |L3.208|
                          DCD      IsKeyDownWakeUp
                  |L3.212|
                          DCD      IsKeyDownUp
                  |L3.216|
                          DCD      IsKeyDownDown
                  |L3.220|
                          DCD      IsKeyDownLeft
                  |L3.224|
                          DCD      IsKeyDownRight
                  |L3.228|
                          DCD      IsKeyDownOk

                          AREA ||i.IsKeyDownDown||, CODE, READONLY, ALIGN=2

                  IsKeyDownDown PROC
;;;46     static uint8_t IsKeyDownUp(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_15) == Bit_SET) return 0; return 1;}
;;;47     static uint8_t IsKeyDownDown(void) 		{if (GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_3) == Bit_SET) return 0; return 1;}
000000  b510              PUSH     {r4,lr}
000002  2108              MOVS     r1,#8
000004  4804              LDR      r0,|L4.24|
000006  f7fffffe          BL       GPIO_ReadInputDataBit
00000a  2801              CMP      r0,#1
00000c  d001              BEQ      |L4.18|
00000e  2001              MOVS     r0,#1
000010  bd10              POP      {r4,pc}
                  |L4.18|
000012  2000              MOVS     r0,#0
000014  bd10              POP      {r4,pc}
;;;48     static uint8_t IsKeyDownLeft(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_14) == Bit_SET) return 0; return 1;}
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x40011400

                          AREA ||i.IsKeyDownLeft||, CODE, READONLY, ALIGN=2

                  IsKeyDownLeft PROC
;;;47     static uint8_t IsKeyDownDown(void) 		{if (GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_3) == Bit_SET) return 0; return 1;}
;;;48     static uint8_t IsKeyDownLeft(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_14) == Bit_SET) return 0; return 1;}
000000  b510              PUSH     {r4,lr}
000002  f44f4180          MOV      r1,#0x4000
000006  4804              LDR      r0,|L5.24|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L5.20|
000010  2001              MOVS     r0,#1
000012  bd10              POP      {r4,pc}
                  |L5.20|
000014  2000              MOVS     r0,#0
000016  bd10              POP      {r4,pc}
;;;49     static uint8_t IsKeyDownRight(void) 	{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_13) == Bit_SET) return 0; return 1;}
                          ENDP

                  |L5.24|
                          DCD      0x40012000

                          AREA ||i.IsKeyDownOk||, CODE, READONLY, ALIGN=2

                  IsKeyDownOk PROC
;;;49     static uint8_t IsKeyDownRight(void) 	{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_13) == Bit_SET) return 0; return 1;}
;;;50     static uint8_t IsKeyDownOk(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_7) == Bit_SET) return 0; return 1;}
000000  b510              PUSH     {r4,lr}
000002  2180              MOVS     r1,#0x80
000004  4804              LDR      r0,|L6.24|
000006  f7fffffe          BL       GPIO_ReadInputDataBit
00000a  2801              CMP      r0,#1
00000c  d001              BEQ      |L6.18|
00000e  2001              MOVS     r0,#1
000010  bd10              POP      {r4,pc}
                  |L6.18|
000012  2000              MOVS     r0,#0
000014  bd10              POP      {r4,pc}
;;;51     																						  
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x40012000

                          AREA ||i.IsKeyDownRight||, CODE, READONLY, ALIGN=2

                  IsKeyDownRight PROC
;;;48     static uint8_t IsKeyDownLeft(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_14) == Bit_SET) return 0; return 1;}
;;;49     static uint8_t IsKeyDownRight(void) 	{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_13) == Bit_SET) return 0; return 1;}
000000  b510              PUSH     {r4,lr}
000002  f44f5100          MOV      r1,#0x2000
000006  4804              LDR      r0,|L7.24|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L7.20|
000010  2001              MOVS     r0,#1
000012  bd10              POP      {r4,pc}
                  |L7.20|
000014  2000              MOVS     r0,#0
000016  bd10              POP      {r4,pc}
;;;50     static uint8_t IsKeyDownOk(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_7) == Bit_SET) return 0; return 1;}
                          ENDP

                  |L7.24|
                          DCD      0x40012000

                          AREA ||i.IsKeyDownTamper||, CODE, READONLY, ALIGN=2

                  IsKeyDownTamper PROC
;;;43     static uint8_t IsKeyDownUser(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_8) == Bit_SET) return 0; return 1;}
;;;44     static uint8_t IsKeyDownTamper(void) 	{if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == Bit_SET) return 0; return 1;}
000000  b510              PUSH     {r4,lr}
000002  f44f5100          MOV      r1,#0x2000
000006  4804              LDR      r0,|L8.24|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L8.20|
000010  2001              MOVS     r0,#1
000012  bd10              POP      {r4,pc}
                  |L8.20|
000014  2000              MOVS     r0,#0
000016  bd10              POP      {r4,pc}
;;;45     static uint8_t IsKeyDownWakeUp(void) 	{if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == Bit_SET) return 1; return 0;}
                          ENDP

                  |L8.24|
                          DCD      0x40011000

                          AREA ||i.IsKeyDownUp||, CODE, READONLY, ALIGN=2

                  IsKeyDownUp PROC
;;;45     static uint8_t IsKeyDownWakeUp(void) 	{if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == Bit_SET) return 1; return 0;}
;;;46     static uint8_t IsKeyDownUp(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_15) == Bit_SET) return 0; return 1;}
000000  b510              PUSH     {r4,lr}
000002  f44f4100          MOV      r1,#0x8000
000006  4804              LDR      r0,|L9.24|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L9.20|
000010  2001              MOVS     r0,#1
000012  bd10              POP      {r4,pc}
                  |L9.20|
000014  2000              MOVS     r0,#0
000016  bd10              POP      {r4,pc}
;;;47     static uint8_t IsKeyDownDown(void) 		{if (GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_3) == Bit_SET) return 0; return 1;}
                          ENDP

                  |L9.24|
                          DCD      0x40012000

                          AREA ||i.IsKeyDownUser||, CODE, READONLY, ALIGN=2

                  IsKeyDownUser PROC
;;;42     */
;;;43     static uint8_t IsKeyDownUser(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_8) == Bit_SET) return 0; return 1;}
000000  b510              PUSH     {r4,lr}
000002  f44f7180          MOV      r1,#0x100
000006  4804              LDR      r0,|L10.24|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L10.20|
000010  2001              MOVS     r0,#1
000012  bd10              POP      {r4,pc}
                  |L10.20|
000014  2000              MOVS     r0,#0
000016  bd10              POP      {r4,pc}
;;;44     static uint8_t IsKeyDownTamper(void) 	{if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == Bit_SET) return 0; return 1;}
                          ENDP

                  |L10.24|
                          DCD      0x40012000

                          AREA ||i.IsKeyDownWakeUp||, CODE, READONLY, ALIGN=2

                  IsKeyDownWakeUp PROC
;;;44     static uint8_t IsKeyDownTamper(void) 	{if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == Bit_SET) return 0; return 1;}
;;;45     static uint8_t IsKeyDownWakeUp(void) 	{if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == Bit_SET) return 1; return 0;}
000000  b510              PUSH     {r4,lr}
000002  2101              MOVS     r1,#1
000004  4803              LDR      r0,|L11.20|
000006  f7fffffe          BL       GPIO_ReadInputDataBit
00000a  2801              CMP      r0,#1
00000c  d000              BEQ      |L11.16|
00000e  2000              MOVS     r0,#0
                  |L11.16|
000010  bd10              POP      {r4,pc}
;;;46     static uint8_t IsKeyDownUp(void) 		{if (GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_15) == Bit_SET) return 0; return 1;}
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x40010800

                          AREA ||i.KeyPro||, CODE, READONLY, ALIGN=2

                  KeyPro PROC
;;;274    */
;;;275    void KeyPro(void)
000000  b510              PUSH     {r4,lr}
;;;276    {
;;;277    	DetectButton(&s_BtnUser);	/* USER 键 */
000002  4810              LDR      r0,|L12.68|
000004  f7fffffe          BL       DetectButton
;;;278    	DetectButton(&s_BtnTamper);	/* TAMPER 键 */
000008  480e              LDR      r0,|L12.68|
00000a  3010              ADDS     r0,r0,#0x10
00000c  f7fffffe          BL       DetectButton
;;;279    	DetectButton(&s_BtnWakeUp);	/* WAKEUP 键 */
000010  480c              LDR      r0,|L12.68|
000012  3020              ADDS     r0,r0,#0x20
000014  f7fffffe          BL       DetectButton
;;;280    	DetectButton(&s_BtnUp);		/* 摇杆UP键 */
000018  480a              LDR      r0,|L12.68|
00001a  3030              ADDS     r0,r0,#0x30
00001c  f7fffffe          BL       DetectButton
;;;281    	DetectButton(&s_BtnDown);	/* 摇杆DOWN键 */
000020  4808              LDR      r0,|L12.68|
000022  3040              ADDS     r0,r0,#0x40
000024  f7fffffe          BL       DetectButton
;;;282    	DetectButton(&s_BtnLeft);	/* 摇杆LEFT键 */
000028  4806              LDR      r0,|L12.68|
00002a  3050              ADDS     r0,r0,#0x50
00002c  f7fffffe          BL       DetectButton
;;;283    	DetectButton(&s_BtnRight);	/* 摇杆RIGHT键 */
000030  4804              LDR      r0,|L12.68|
000032  3060              ADDS     r0,r0,#0x60
000034  f7fffffe          BL       DetectButton
;;;284    	DetectButton(&s_BtnOk);		/* 摇杆OK键 */
000038  4802              LDR      r0,|L12.68|
00003a  e8bd4010          POP      {r4,lr}
00003e  3070              ADDS     r0,r0,#0x70
000040  f7ffbffe          B.W      DetectButton
;;;285    }
                          ENDP

                  |L12.68|
                          DCD      ||.bss||

                          AREA ||i.PutKey||, CODE, READONLY, ALIGN=2

                  PutKey PROC
;;;150    */
;;;151    void PutKey(uint8_t _KeyCode)
000000  4905              LDR      r1,|L13.24|
;;;152    {
;;;153    	s_Key.Buf[s_Key.Write] = _KeyCode;
000002  7d4a              LDRB     r2,[r1,#0x15]  ; s_Key
000004  5488              STRB     r0,[r1,r2]
;;;154    
;;;155    	if (++s_Key.Write  >= KEY_FIFO_SIZE)
000006  7d48              LDRB     r0,[r1,#0x15]  ; s_Key
000008  1c40              ADDS     r0,r0,#1
00000a  b2c0              UXTB     r0,r0
00000c  7548              STRB     r0,[r1,#0x15]
00000e  2814              CMP      r0,#0x14
000010  d301              BCC      |L13.22|
;;;156    	{
;;;157    		s_Key.Write = 0;
000012  2000              MOVS     r0,#0
000014  7548              STRB     r0,[r1,#0x15]
                  |L13.22|
;;;158    	}
;;;159    }
000016  4770              BX       lr
;;;160    
                          ENDP

                  |L13.24|
                          DCD      ||.bss||+0x80

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_BtnUser
                          %        16
                  s_BtnTamper
                          %        16
                  s_BtnWakeUp
                          %        16
                  s_BtnUp
                          %        16
                  s_BtnDown
                          %        16
                  s_BtnLeft
                          %        16
                  s_BtnRight
                          %        16
                  s_BtnOk
                          %        16
                  s_Key
                          %        22
