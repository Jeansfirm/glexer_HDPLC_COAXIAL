; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\systick.o --depend=.\Obj\systick.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Source\src\systick.c]
                          THUMB

                          AREA ||i.CheckTimer||, CODE, READONLY, ALIGN=2

                  CheckTimer PROC
;;;133    */
;;;134    uint8_t CheckTimer(uint8_t _id)
000000  2804              CMP      r0,#4
;;;135    {
;;;136    	if (_id >= TMR_COUNT)
000002  d301              BCC      |L1.8|
;;;137    	{
;;;138    		return 0;
000004  2000              MOVS     r0,#0
;;;139    	}
;;;140    
;;;141    	return g_Tmr[_id].flag;
;;;142    }
000006  4770              BX       lr
                  |L1.8|
000008  4902              LDR      r1,|L1.20|
00000a  eb0100c0          ADD      r0,r1,r0,LSL #3       ;141
00000e  7900              LDRB     r0,[r0,#4]            ;141
000010  4770              BX       lr
;;;143    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      ||.bss||

                          AREA ||i.DelayMS||, CODE, READONLY, ALIGN=2

                  DelayMS PROC
;;;88     */
;;;89     void DelayMS(uint32_t n)
000000  2801              CMP      r0,#1
;;;90     {
;;;91     	/* 避免 n = 1 出现主程序死锁 */
;;;92     	if (n == 1)
000002  d100              BNE      |L2.6|
;;;93     	{
;;;94     		n = 2;
000004  2002              MOVS     r0,#2
                  |L2.6|
;;;95     	}
;;;96     	g_Tmr[0].count = n;
000006  4904              LDR      r1,|L2.24|
000008  6008              STR      r0,[r1,#0]  ; g_Tmr
;;;97     	g_Tmr[0].flag = 0;
00000a  2000              MOVS     r0,#0
00000c  7108              STRB     r0,[r1,#4]
                  |L2.14|
;;;98     
;;;99     	/* while 循环体最好让CPU进入IDLE状态，已降低功耗 */
;;;100    	while (1)
;;;101    	{
;;;102    		CPU_IDLE();
;;;103    
;;;104    		if (g_Tmr[0].flag == 1)
00000e  7908              LDRB     r0,[r1,#4]  ; g_Tmr
000010  2801              CMP      r0,#1
000012  d1fc              BNE      |L2.14|
;;;105    		{
;;;106    			break;
;;;107    		}
;;;108    	}
;;;109    }
000014  4770              BX       lr
;;;110    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      ||.bss||

                          AREA ||i.GetRunTime||, CODE, READONLY, ALIGN=2

                  GetRunTime PROC
;;;149    */
;;;150    int32_t GetRunTime(void)
000000  2001              MOVS     r0,#1
000002  f3808810          MSR      PRIMASK,r0
;;;151    {
;;;152    	int runtime; 
;;;153    
;;;154    	__set_PRIMASK(1);  		/* 关中断 */
;;;155    	
;;;156    	runtime = g_RunTime;	/* 由于在Systick中断被改写，因此关中断进行保护 */
000006  4803              LDR      r0,|L3.20|
000008  6840              LDR      r0,[r0,#4]  ; g_RunTime
00000a  2100              MOVS     r1,#0
00000c  f3818810          MSR      PRIMASK,r1
;;;157    		
;;;158    	__set_PRIMASK(0);  		/* 开中断 */
;;;159    
;;;160    	return runtime;
;;;161    }
000010  4770              BX       lr
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      ||.data||

                          AREA ||i.StartTimer||, CODE, READONLY, ALIGN=2

                  StartTimer PROC
;;;116    */
;;;117    void StartTimer(uint8_t _id, uint32_t _period)
000000  2804              CMP      r0,#4
;;;118    {
;;;119    	if (_id >= TMR_COUNT)
000002  d206              BCS      |L4.18|
;;;120    	{
;;;121    		return;
;;;122    	}
;;;123    
;;;124    	g_Tmr[_id].count = _period;
000004  4a03              LDR      r2,|L4.20|
000006  f8421030          STR      r1,[r2,r0,LSL #3]
;;;125    	g_Tmr[_id].flag = 0;
00000a  eb0200c0          ADD      r0,r2,r0,LSL #3
00000e  2100              MOVS     r1,#0
000010  7101              STRB     r1,[r0,#4]
                  |L4.18|
;;;126    }
000012  4770              BX       lr
;;;127    
                          ENDP

                  |L4.20|
                          DCD      ||.bss||

                          AREA ||i.SysTick_ISR||, CODE, READONLY, ALIGN=2

                  SysTick_ISR PROC
;;;54     */
;;;55     void SysTick_ISR(void)
000000  b430              PUSH     {r4,r5}
;;;56     {
;;;57     	static uint8_t s_count = 0;
;;;58     	uint8_t i;
;;;59     
;;;60     	for (i = 0; i < TMR_COUNT; i++)
000002  2000              MOVS     r0,#0
;;;61     	{
;;;62     		SoftTimerDec(&g_Tmr[i]);
000004  4a13              LDR      r2,|L5.84|
000006  2301              MOVS     r3,#1
                  |L5.8|
000008  eb0201c0          ADD      r1,r2,r0,LSL #3
00000c  790c              LDRB     r4,[r1,#4]
00000e  b934              CBNZ     r4,|L5.30|
000010  680c              LDR      r4,[r1,#0]
000012  b124              CBZ      r4,|L5.30|
000014  680c              LDR      r4,[r1,#0]
000016  1e64              SUBS     r4,r4,#1
000018  600c              STR      r4,[r1,#0]
00001a  d100              BNE      |L5.30|
00001c  710b              STRB     r3,[r1,#4]
                  |L5.30|
00001e  1c40              ADDS     r0,r0,#1              ;60
000020  b2c0              UXTB     r0,r0                 ;60
000022  2804              CMP      r0,#4                 ;60
000024  d3f0              BCC      |L5.8|
;;;63     	}
;;;64     
;;;65     	/* 下面的代码实现所有按键的检测
;;;66     		按键检测每隔10ms一次就行了，一般做40ms的滤波处理就可以有效过滤掉机械动作造成的
;;;67     		按键抖动。
;;;68     	*/
;;;69     	if (++s_count >= 10)
000026  480c              LDR      r0,|L5.88|
000028  7801              LDRB     r1,[r0,#0]  ; s_count
00002a  1c49              ADDS     r1,r1,#1
00002c  b2c9              UXTB     r1,r1
00002e  7001              STRB     r1,[r0,#0]
000030  290a              CMP      r1,#0xa
000032  d30c              BCC      |L5.78|
;;;70     	{
;;;71     		s_count = 0;
000034  2100              MOVS     r1,#0
000036  7001              STRB     r1,[r0,#0]
;;;72     
;;;73     		g_RunTime++;	/* 全局运行时间每10ms增1 */	
000038  6842              LDR      r2,[r0,#4]  ; g_RunTime
00003a  1c52              ADDS     r2,r2,#1
00003c  6042              STR      r2,[r0,#4]  ; g_RunTime
;;;74     		if (g_RunTime == 0x80000000)
00003e  6842              LDR      r2,[r0,#4]  ; g_RunTime
000040  f1b24f00          CMP      r2,#0x80000000
000044  d100              BNE      |L5.72|
;;;75     		{
;;;76     			g_RunTime = 0;
000046  6041              STR      r1,[r0,#4]  ; g_RunTime
                  |L5.72|
;;;77     		}
;;;78     		
;;;79     		KeyPro();		/* 该函数在 button.c 中实现 */
000048  bc30              POP      {r4,r5}
00004a  f7ffbffe          B.W      KeyPro
                  |L5.78|
;;;80     	}
;;;81     }
00004e  bc30              POP      {r4,r5}
000050  4770              BX       lr
;;;82     
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
                          DCD      ||.bss||
                  |L5.88|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Tmr
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  s_count
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  g_RunTime
                          DCD      0x00000000
