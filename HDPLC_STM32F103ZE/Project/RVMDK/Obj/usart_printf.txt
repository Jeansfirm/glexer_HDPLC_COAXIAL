; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\usart_printf.o --depend=.\Obj\usart_printf.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Source\src\usart_printf.c]
                          THUMB

                          AREA ||i.PrintfLogo||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  PrintfLogo PROC
;;;25     */
;;;26     void PrintfLogo(char *strName, char *strDate)
000000  b570              PUSH     {r4-r6,lr}
;;;27     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;28     	printf("*************************************************************\n\r");
000006  a00f              ADR      r0,|L1.68|
000008  f7fffffe          BL       __2printf
;;;29     	printf("* Program Name : %s\r\n", strName);
00000c  4629              MOV      r1,r5
00000e  a01d              ADR      r0,|L1.132|
000010  f7fffffe          BL       __2printf
;;;30     	printf("* Update Date  : %s\r\n", strDate);
000014  4621              MOV      r1,r4
000016  a021              ADR      r0,|L1.156|
000018  f7fffffe          BL       __2printf
;;;31     	printf("* StdPeriph_Lib Version : V3.1.2\n\r");
00001c  a025              ADR      r0,|L1.180|
00001e  f7fffffe          BL       __2printf
;;;32     	printf("* \n\r");
000022  a02d              ADR      r0,|L1.216|
000024  f7fffffe          BL       __2printf
;;;33     	printf("* Copyright GLEXER \r\n");
000028  a02d              ADR      r0,|L1.224|
00002a  f7fffffe          BL       __2printf
;;;34     	printf("* QQ    : 719296013 \r\n");
00002e  a032              ADR      r0,|L1.248|
000030  f7fffffe          BL       __2printf
;;;35     	printf("* Email : pengjunfeng@glexer.com \r\n");
000034  a036              ADR      r0,|L1.272|
000036  f7fffffe          BL       __2printf
;;;36     	printf("*************************************************************\n\r");
00003a  e8bd4070          POP      {r4-r6,lr}
00003e  a001              ADR      r0,|L1.68|
000040  f7ffbffe          B.W      __2printf
;;;37     }
;;;38     
                          ENDP

                  |L1.68|
000044  2a2a2a2a          DCB      "*******************************************************"
000048  2a2a2a2a
00004c  2a2a2a2a
000050  2a2a2a2a
000054  2a2a2a2a
000058  2a2a2a2a
00005c  2a2a2a2a
000060  2a2a2a2a
000064  2a2a2a2a
000068  2a2a2a2a
00006c  2a2a2a2a
000070  2a2a2a2a
000074  2a2a2a2a
000078  2a2a2a  
00007b  2a2a2a2a          DCB      "******\n\r",0
00007f  2a2a0a0d
000083  00      
                  |L1.132|
000084  2a205072          DCB      "* Program Name : %s\r\n",0
000088  6f677261
00008c  6d204e61
000090  6d65203a
000094  2025730d
000098  0a00    
00009a  00                DCB      0
00009b  00                DCB      0
                  |L1.156|
00009c  2a205570          DCB      "* Update Date  : %s\r\n",0
0000a0  64617465
0000a4  20446174
0000a8  6520203a
0000ac  2025730d
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L1.180|
0000b4  2a205374          DCB      "* StdPeriph_Lib Version : V3.1.2\n\r",0
0000b8  64506572
0000bc  6970685f
0000c0  4c696220
0000c4  56657273
0000c8  696f6e20
0000cc  3a205633
0000d0  2e312e32
0000d4  0a0d00  
0000d7  00                DCB      0
                  |L1.216|
0000d8  2a200a0d          DCB      "* \n\r",0
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L1.224|
0000e0  2a20436f          DCB      "* Copyright GLEXER \r\n",0
0000e4  70797269
0000e8  67687420
0000ec  474c4558
0000f0  4552200d
0000f4  0a00    
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L1.248|
0000f8  2a205151          DCB      "* QQ    : 719296013 \r\n",0
0000fc  20202020
000100  3a203731
000104  39323936
000108  30313320
00010c  0d0a00  
00010f  00                DCB      0
                  |L1.272|
000110  2a20456d          DCB      "* Email : pengjunfeng@glexer.com \r\n",0
000114  61696c20
000118  3a207065
00011c  6e676a75
000120  6e66656e
000124  6740676c
000128  65786572
00012c  2e636f6d
000130  200d0a00

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;50     */
;;;51     void USART_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;52     {
000002  b086              SUB      sp,sp,#0x18
;;;53     	GPIO_InitTypeDef GPIO_InitStructure;
;;;54     	USART_InitTypeDef USART_InitStructure;
;;;55     
;;;56     	/* 第1步：打开GPIO和USART部件的时钟 */
;;;57     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;58     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;59     
;;;60     	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;61     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;62     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;63     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
;;;64     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000024  4c19              LDR      r4,|L2.140|
000026  f88d0012          STRB     r0,[sp,#0x12]         ;63
00002a  a904              ADD      r1,sp,#0x10
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       GPIO_Init
;;;65     
;;;66     	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;67     		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;68     		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;69     	*/
;;;70     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000032  1520              ASRS     r0,r4,#20
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;71     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;72     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       GPIO_Init
;;;73     	/*  第3步已经做了，因此这步可以不做
;;;74     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;75     	*/
;;;76     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000046  a904              ADD      r1,sp,#0x10
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       GPIO_Init
;;;77     
;;;78     
;;;79     	/* 第4步：配置USART参数
;;;80     	    - BaudRate = 115200 baud
;;;81     	    - Word Length = 8 Bits
;;;82     	    - One Stop Bit
;;;83     	    - No parity
;;;84     	    - Hardware flow control disabled (RTS and CTS signals)
;;;85     	    - Receive and transmit enabled
;;;86     	*/
;;;87     	USART_InitStructure.USART_BaudRate = 115200;
00004e  f44f30e1          MOV      r0,#0x1c200
;;;88     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000052  9000              STR      r0,[sp,#0]
000054  2000              MOVS     r0,#0
000056  f8ad0004          STRH     r0,[sp,#4]
;;;89     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00005a  f8ad0006          STRH     r0,[sp,#6]
;;;90     	USART_InitStructure.USART_Parity = USART_Parity_No;
00005e  f8ad0008          STRH     r0,[sp,#8]
;;;91     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000062  f8ad000c          STRH     r0,[sp,#0xc]
;;;92     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000066  200c              MOVS     r0,#0xc
;;;93     	USART_Init(USART1, &USART_InitStructure);
000068  4c09              LDR      r4,|L2.144|
00006a  f8ad000a          STRH     r0,[sp,#0xa]          ;92
00006e  4669              MOV      r1,sp
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       USART_Init
;;;94     
;;;95     	/* 第5步：使能 USART， 配置完毕 */
;;;96     	USART_Cmd(USART1, ENABLE);
000076  2101              MOVS     r1,#1
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       USART_Cmd
;;;97     
;;;98     	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;99     		如下语句解决第1个字节无法正确发送出去的问题 */
;;;100    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送外城标志，Transmission Complete flag */
00007e  2140              MOVS     r1,#0x40
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       USART_ClearFlag
;;;101    }
000086  b006              ADD      sp,sp,#0x18
000088  bd10              POP      {r4,pc}
;;;102    
                          ENDP

00008a  0000              DCW      0x0000
                  |L2.140|
                          DCD      0x40010800
                  |L2.144|
                          DCD      0x40013800

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;129    */
;;;130    int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;131    {
;;;132    	/* 等待串口1输入数据 */
;;;133    	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
000002  4c06              LDR      r4,|L3.28|
                  |L3.4|
000004  2120              MOVS     r1,#0x20
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L3.4|
;;;134    	{}
;;;135    
;;;136    	return (int)USART_ReceiveData(USART1);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      USART_ReceiveData
;;;137    }
;;;138    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;109    */
;;;110    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
;;;112    	/* Place your implementation of fputc here */
;;;113    	/* e.g. write a character to the USART */
;;;114    	USART_SendData(USART1, (uint8_t) ch);
000002  4d07              LDR      r5,|L4.32|
000004  4604              MOV      r4,r0                 ;111
000006  b2c1              UXTB     r1,r0
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_SendData
                  |L4.14|
;;;115    
;;;116    	/* Loop until the end of transmission */
;;;117    	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
00000e  2140              MOVS     r1,#0x40
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       USART_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L4.14|
;;;118    	{}
;;;119    
;;;120    	return ch;
00001a  4620              MOV      r0,r4
;;;121    }
00001c  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40013800
