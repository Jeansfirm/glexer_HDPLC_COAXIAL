; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\systick.o --depend=.\Obj\systick.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Source\src\systick.c]
                          THUMB

                          AREA ||i.CheckTimer||, CODE, READONLY, ALIGN=2

                  CheckTimer PROC
;;;132    */
;;;133    uint8_t CheckTimer(uint8_t _id)
000000  2804              CMP      r0,#4
;;;134    {
;;;135    	if (_id >= TMR_COUNT)
000002  d301              BCC      |L1.8|
;;;136    	{
;;;137    		return 0;
000004  2000              MOVS     r0,#0
;;;138    	}
;;;139    
;;;140    	return g_Tmr[_id].flag;
;;;141    }
000006  4770              BX       lr
                  |L1.8|
000008  4902              LDR      r1,|L1.20|
00000a  eb0100c0          ADD      r0,r1,r0,LSL #3       ;140
00000e  7900              LDRB     r0,[r0,#4]            ;140
000010  4770              BX       lr
;;;142    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      ||.bss||

                          AREA ||i.DelayMS||, CODE, READONLY, ALIGN=2

                  DelayMS PROC
;;;87     */
;;;88     void DelayMS(uint32_t n)
000000  2801              CMP      r0,#1
;;;89     {
;;;90     	/* 避免 n = 1 出现主程序死锁 */
;;;91     	if (n == 1)
000002  d100              BNE      |L2.6|
;;;92     	{
;;;93     		n = 2;
000004  2002              MOVS     r0,#2
                  |L2.6|
;;;94     	}
;;;95     	g_Tmr[0].count = n;
000006  4904              LDR      r1,|L2.24|
000008  6008              STR      r0,[r1,#0]  ; g_Tmr
;;;96     	g_Tmr[0].flag = 0;
00000a  2000              MOVS     r0,#0
00000c  7108              STRB     r0,[r1,#4]
                  |L2.14|
;;;97     
;;;98     	/* while 循环体最好让CPU进入IDLE状态，已降低功耗 */
;;;99     	while (1)
;;;100    	{
;;;101    		CPU_IDLE();
;;;102    
;;;103    		if (g_Tmr[0].flag == 1)
00000e  7908              LDRB     r0,[r1,#4]  ; g_Tmr
000010  2801              CMP      r0,#1
000012  d1fc              BNE      |L2.14|
;;;104    		{
;;;105    			break;
;;;106    		}
;;;107    	}
;;;108    }
000014  4770              BX       lr
;;;109    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      ||.bss||

                          AREA ||i.GetRunTime||, CODE, READONLY, ALIGN=2

                  GetRunTime PROC
;;;148    */
;;;149    int32_t GetRunTime(void)
000000  2001              MOVS     r0,#1
000002  f3808810          MSR      PRIMASK,r0
;;;150    {
;;;151    	int runtime; 
;;;152    
;;;153    	__set_PRIMASK(1);  		/* 关中断 */
;;;154    	
;;;155    	runtime = g_RunTime;	/* 由于在Systick中断被改写，因此关中断进行保护 */
000006  4803              LDR      r0,|L3.20|
000008  6840              LDR      r0,[r0,#4]  ; g_RunTime
00000a  2100              MOVS     r1,#0
00000c  f3818810          MSR      PRIMASK,r1
;;;156    		
;;;157    	__set_PRIMASK(0);  		/* 开中断 */
;;;158    
;;;159    	return runtime;
;;;160    }
000010  4770              BX       lr
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      ||.data||

                          AREA ||i.StartTimer||, CODE, READONLY, ALIGN=2

                  StartTimer PROC
;;;115    */
;;;116    void StartTimer(uint8_t _id, uint32_t _period)
000000  2804              CMP      r0,#4
;;;117    {
;;;118    	if (_id >= TMR_COUNT)
000002  d206              BCS      |L4.18|
;;;119    	{
;;;120    		return;
;;;121    	}
;;;122    
;;;123    	g_Tmr[_id].count = _period;
000004  4a03              LDR      r2,|L4.20|
000006  f8421030          STR      r1,[r2,r0,LSL #3]
;;;124    	g_Tmr[_id].flag = 0;
00000a  eb0200c0          ADD      r0,r2,r0,LSL #3
00000e  2100              MOVS     r1,#0
000010  7101              STRB     r1,[r0,#4]
                  |L4.18|
;;;125    }
000012  4770              BX       lr
;;;126    
                          ENDP

                  |L4.20|
                          DCD      ||.bss||

                          AREA ||i.SysTick_ISR||, CODE, READONLY, ALIGN=2

                  SysTick_ISR PROC
;;;54     */
;;;55     void SysTick_ISR(void)
000000  b510              PUSH     {r4,lr}
;;;56     {
;;;57     	static uint8_t s_count = 0;
;;;58     	uint8_t i;
;;;59     
;;;60     	for (i = 0; i < TMR_COUNT; i++)
000002  2000              MOVS     r0,#0
;;;61     	{
;;;62     		SoftTimerDec(&g_Tmr[i]);
000004  4a11              LDR      r2,|L5.76|
000006  2301              MOVS     r3,#1
                  |L5.8|
000008  eb0201c0          ADD      r1,r2,r0,LSL #3
00000c  790c              LDRB     r4,[r1,#4]
00000e  b934              CBNZ     r4,|L5.30|
000010  680c              LDR      r4,[r1,#0]
000012  b124              CBZ      r4,|L5.30|
000014  680c              LDR      r4,[r1,#0]
000016  1e64              SUBS     r4,r4,#1
000018  600c              STR      r4,[r1,#0]
00001a  d100              BNE      |L5.30|
00001c  710b              STRB     r3,[r1,#4]
                  |L5.30|
00001e  1c40              ADDS     r0,r0,#1              ;60
000020  b2c0              UXTB     r0,r0                 ;60
000022  2804              CMP      r0,#4                 ;60
000024  d3f0              BCC      |L5.8|
;;;63     	}
;;;64     
;;;65     	/* 下面的代码实现所有按键的检测
;;;66     		按键检测每隔10ms一次就行了，一般做40ms的滤波处理就可以有效过滤掉机械动作造成的
;;;67     		按键抖动。
;;;68     	*/
;;;69     	if (++s_count >= 10)
000026  480a              LDR      r0,|L5.80|
000028  7801              LDRB     r1,[r0,#0]  ; s_count
00002a  1c49              ADDS     r1,r1,#1
00002c  b2c9              UXTB     r1,r1
00002e  7001              STRB     r1,[r0,#0]
000030  290a              CMP      r1,#0xa
000032  d309              BCC      |L5.72|
;;;70     	{
;;;71     		s_count = 0;
000034  2100              MOVS     r1,#0
000036  7001              STRB     r1,[r0,#0]
;;;72     
;;;73     		g_RunTime++;	/* 全局运行时间每10ms增1 */	
000038  6842              LDR      r2,[r0,#4]  ; g_RunTime
00003a  1c52              ADDS     r2,r2,#1
00003c  6042              STR      r2,[r0,#4]  ; g_RunTime
;;;74     		if (g_RunTime == 0x80000000)
00003e  6842              LDR      r2,[r0,#4]  ; g_RunTime
000040  f1b24f00          CMP      r2,#0x80000000
000044  d100              BNE      |L5.72|
;;;75     		{
;;;76     			g_RunTime = 0;
000046  6041              STR      r1,[r0,#4]  ; g_RunTime
                  |L5.72|
;;;77     		}
;;;78     
;;;79     	}
;;;80     }
000048  bd10              POP      {r4,pc}
;;;81     
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      ||.bss||
                  |L5.80|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Tmr
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  s_count
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  g_RunTime
                          DCD      0x00000000
