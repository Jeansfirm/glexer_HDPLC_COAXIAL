; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\stm32f10x_rcc.o --depend=.\Obj\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;761      */
;;;762    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000000  4a03              LDR      r2,|L1.16|
;;;763    {
;;;764      uint32_t tmpreg = 0;
;;;765      /* Check the parameters */
;;;766      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;767      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;768      /* Clear ADCPRE[1:0] bits */
;;;769      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000004  f4214140          BIC      r1,r1,#0xc000
;;;770      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;771      tmpreg |= RCC_PCLK2;
000008  4301              ORRS     r1,r1,r0
;;;772      /* Store the new value */
;;;773      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;774    }
00000c  4770              BX       lr
;;;775    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1046     */
;;;1047   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1048   {
;;;1049     /* Check the parameters */
;;;1050     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1051     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1052   
;;;1053     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1054     {
;;;1055       RCC->AHBENR |= RCC_AHBPeriph;
;;;1056     }
;;;1057     else
;;;1058     {
;;;1059       RCC->AHBENR &= ~RCC_AHBPeriph;
000004  6951              LDR      r1,[r2,#0x14]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;1055
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6151              STR      r1,[r2,#0x14]         ;1055
;;;1060     }
;;;1061   }
000010  4770              BX       lr
;;;1062   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1105     */
;;;1106   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1107   {
;;;1108     /* Check the parameters */
;;;1109     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1110     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1111     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1112     {
;;;1113       RCC->APB1ENR |= RCC_APB1Periph;
;;;1114     }
;;;1115     else
;;;1116     {
;;;1117       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;1113
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  61d1              STR      r1,[r2,#0x1c]         ;1113
;;;1118     }
;;;1119   }
000010  4770              BX       lr
;;;1120   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1192     */
;;;1193   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1194   {
;;;1195     /* Check the parameters */
;;;1196     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1197     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1198     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1199     {
;;;1200       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1201     }
;;;1202     else
;;;1203     {
;;;1204       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;1200
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  6111              STR      r1,[r2,#0x10]         ;1200
;;;1205     }
;;;1206   }
000010  4770              BX       lr
;;;1207   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1075     */
;;;1076   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1077   {
;;;1078     /* Check the parameters */
;;;1079     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1080     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1081     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1082     {
;;;1083       RCC->APB2ENR |= RCC_APB2Periph;
;;;1084     }
;;;1085     else
;;;1086     {
;;;1087       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6991              LDR      r1,[r2,#0x18]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1083
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6191              STR      r1,[r2,#0x18]         ;1083
;;;1088     }
;;;1089   }
000010  4770              BX       lr
;;;1090   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1162     */
;;;1163   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1164   {
;;;1165     /* Check the parameters */
;;;1166     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1167     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1168     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1169     {
;;;1170       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1171     }
;;;1172     else
;;;1173     {
;;;1174       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  68d1              LDR      r1,[r2,#0xc]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1170
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  60d1              STR      r1,[r2,#0xc]          ;1170
;;;1175     }
;;;1176   }
000010  4770              BX       lr
;;;1177   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;333      */
;;;334    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4903              LDR      r1,|L7.16|
;;;335    {
;;;336      uint32_t tmpreg = 0;
;;;337      /* Check the parameters */
;;;338      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;339      tmpreg = RCC->CR;
000002  680a              LDR      r2,[r1,#0]
;;;340      /* Clear HSITRIM[4:0] bits */
;;;341      tmpreg &= CR_HSITRIM_Mask;
000004  f02202f8          BIC      r2,r2,#0xf8
;;;342      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;343      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;344      /* Store the new value */
;;;345      RCC->CR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;346    }
00000e  4770              BX       lr
;;;347    
                          ENDP

                  |L7.16|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1213     */
;;;1214   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;1215   {
;;;1216     /* Check the parameters */
;;;1217     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1218     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1219   }
000004  4770              BX       lr
;;;1220   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1347     */
;;;1348   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L9.12|
;;;1349   {
;;;1350     /* Set RMVF bit to clear the reset flags */
;;;1351     RCC->CSR |= CSR_RMVF_Set;
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6241              STR      r1,[r0,#0x24]
;;;1352   }
00000a  4770              BX       lr
;;;1353   
                          ENDP

                  |L9.12|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1424     */
;;;1425   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L10.8|
;;;1426   {
;;;1427     /* Check the parameters */
;;;1428     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1429   
;;;1430     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1431        pending bits */
;;;1432     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1433   }
000004  4770              BX       lr
;;;1434   
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;1226     */
;;;1227   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;1228   {
;;;1229     /* Check the parameters */
;;;1230     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1231     *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;1232   }
000004  4770              BX       lr
;;;1233   
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;223      */
;;;224    void RCC_DeInit(void)
000000  480c              LDR      r0,|L12.52|
;;;225    {
;;;226      /* Set HSION bit */
;;;227      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;228    
;;;229      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;230    #ifndef STM32F10X_CL
;;;231      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0a              LDR      r2,|L12.56|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;232    #else
;;;233      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;234    #endif /* STM32F10X_CL */   
;;;235      
;;;236      /* Reset HSEON, CSSON and PLLON bits */
;;;237      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  4a09              LDR      r2,|L12.60|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;238    
;;;239      /* Reset HSEBYP bit */
;;;240      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4212180          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;241    
;;;242      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;243      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000022  6842              LDR      r2,[r0,#4]
;;;244    
;;;245    #ifndef STM32F10X_CL
;;;246      /* Disable all interrupts and clear pending bits  */
;;;247      RCC->CIR = 0x009F0000;
000024  f44f011f          MOV      r1,#0x9f0000
000028  f42202fe          BIC      r2,r2,#0x7f0000       ;243
00002c  6042              STR      r2,[r0,#4]            ;243
00002e  6081              STR      r1,[r0,#8]
;;;248    #else
;;;249      /* Reset PLL2ON and PLL3ON bits */
;;;250      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;251    
;;;252      /* Disable all interrupts and clear pending bits  */
;;;253      RCC->CIR = 0x00FF0000;
;;;254    
;;;255      /* Reset CFGR2 register */
;;;256      RCC->CFGR2 = 0x00000000;
;;;257    #endif /* STM32F10X_CL */
;;;258    }
000030  4770              BX       lr
;;;259    
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      0x40021000
                  |L12.56|
                          DCD      0xf8ff0000
                  |L12.60|
                          DCD      0xfef6ffff

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;901      */
;;;902    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  4921              LDR      r1,|L13.136|
;;;903    {
000002  b510              PUSH     {r4,lr}
;;;904      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
;;;905    
;;;906    #ifdef  STM32F10X_CL
;;;907      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;908    #endif /* STM32F10X_CL */
;;;909        
;;;910      /* Get SYSCLK source -------------------------------------------------------*/
;;;911      tmp = RCC->CFGR & CFGR_SWS_Mask;
000004  684b              LDR      r3,[r1,#4]
;;;912      
;;;913      switch (tmp)
;;;914      {
;;;915        case 0x00:  /* HSI used as system clock */
;;;916          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
000006  4a21              LDR      r2,|L13.140|
000008  f013030c          ANDS     r3,r3,#0xc            ;911
00000c  d003              BEQ      |L13.22|
00000e  2b04              CMP      r3,#4                 ;913
000010  d001              BEQ      |L13.22|
000012  2b08              CMP      r3,#8                 ;913
000014  d026              BEQ      |L13.100|
                  |L13.22|
;;;917          break;
;;;918        case 0x04:  /* HSE used as system clock */
;;;919          RCC_Clocks->SYSCLK_Frequency = HSE_Value;
;;;920          break;
;;;921        case 0x08:  /* PLL used as system clock */
;;;922    
;;;923          /* Get PLL clock source and multiplication factor ----------------------*/
;;;924          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
;;;925          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
;;;926          
;;;927    #ifndef STM32F10X_CL      
;;;928          pllmull = ( pllmull >> 18) + 2;
;;;929          
;;;930          if (pllsource == 0x00)
;;;931          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;932            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
;;;933          }
;;;934          else
;;;935          {/* HSE selected as PLL clock entry */
;;;936            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
;;;937            {/* HSE oscillator clock divided by 2 */
;;;938              RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
;;;939            }
;;;940            else
;;;941            {
;;;942              RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
;;;943            }
;;;944          }
;;;945    #else
;;;946          pllmull = pllmull >> 18;
;;;947          
;;;948          if (pllmull != 0x0D)
;;;949          {
;;;950             pllmull += 2;
;;;951          }
;;;952          else
;;;953          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;954            pllmull = 13 / 2; 
;;;955          }
;;;956                
;;;957          if (pllsource == 0x00)
;;;958          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;959            RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
;;;960          }
;;;961          else
;;;962          {/* PREDIV1 selected as PLL clock entry */
;;;963            
;;;964            /* Get PREDIV1 clock source and division factor */
;;;965            prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
;;;966            prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;967            
;;;968            if (prediv1source == 0)
;;;969            { /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;970              RCC_Clocks->SYSCLK_Frequency = (HSE_Value / prediv1factor) * pllmull;          
;;;971            }
;;;972            else
;;;973            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;974              
;;;975              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;976              prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
;;;977              pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;978              RCC_Clocks->SYSCLK_Frequency = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;979            }
;;;980          }
;;;981    #endif /* STM32F10X_CL */ 
;;;982          break;
;;;983    
;;;984        default:
;;;985          RCC_Clocks->SYSCLK_Frequency = HSI_Value;
;;;986          break;
;;;987      }
;;;988    
;;;989      /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;990      /* Get HCLK prescaler */
;;;991      tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
000016  6002              STR      r2,[r0,#0]
000018  684a              LDR      r2,[r1,#4]
;;;992      tmp = tmp >> 4;
;;;993      presc = APBAHBPrescTable[tmp];
00001a  4b1d              LDR      r3,|L13.144|
00001c  f00202f0          AND      r2,r2,#0xf0           ;991
000020  0912              LSRS     r2,r2,#4              ;992
000022  5c9c              LDRB     r4,[r3,r2]
;;;994      /* HCLK clock frequency */
;;;995      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
000024  6802              LDR      r2,[r0,#0]
000026  40e2              LSRS     r2,r2,r4
;;;996      /* Get PCLK1 prescaler */
;;;997      tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
000028  6042              STR      r2,[r0,#4]
00002a  684c              LDR      r4,[r1,#4]
00002c  f40464e0          AND      r4,r4,#0x700
;;;998      tmp = tmp >> 8;
000030  0a24              LSRS     r4,r4,#8
;;;999      presc = APBAHBPrescTable[tmp];
000032  5d1c              LDRB     r4,[r3,r4]
;;;1000     /* PCLK1 clock frequency */
;;;1001     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000034  fa22f404          LSR      r4,r2,r4
;;;1002     /* Get PCLK2 prescaler */
;;;1003     tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000038  6084              STR      r4,[r0,#8]
00003a  684c              LDR      r4,[r1,#4]
00003c  f4045460          AND      r4,r4,#0x3800
;;;1004     tmp = tmp >> 11;
000040  ea4f24d4          LSR      r4,r4,#11
;;;1005     presc = APBAHBPrescTable[tmp];
000044  5d1b              LDRB     r3,[r3,r4]
;;;1006     /* PCLK2 clock frequency */
;;;1007     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
000046  fa22f203          LSR      r2,r2,r3
;;;1008     /* Get ADCCLK prescaler */
;;;1009     tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
00004a  60c2              STR      r2,[r0,#0xc]
00004c  6849              LDR      r1,[r1,#4]
;;;1010     tmp = tmp >> 14;
;;;1011     presc = ADCPrescTable[tmp];
00004e  4b10              LDR      r3,|L13.144|
000050  f4014140          AND      r1,r1,#0xc000         ;1009
000054  ea4f3191          LSR      r1,r1,#14             ;1010
000058  1f1b              SUBS     r3,r3,#4
00005a  5c59              LDRB     r1,[r3,r1]
;;;1012     /* ADCCLK clock frequency */
;;;1013     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
00005c  fbb2f1f1          UDIV     r1,r2,r1
000060  6101              STR      r1,[r0,#0x10]
;;;1014   }
000062  bd10              POP      {r4,pc}
                  |L13.100|
000064  684a              LDR      r2,[r1,#4]            ;924
000066  684b              LDR      r3,[r1,#4]            ;925
000068  2402              MOVS     r4,#2                 ;928
00006a  f4021270          AND      r2,r2,#0x3c0000       ;924
00006e  eb044292          ADD      r2,r4,r2,LSR #18      ;928
000072  f4133f80          TST      r3,#0x10000           ;925
000076  d002              BEQ      |L13.126|
000078  684b              LDR      r3,[r1,#4]            ;936
00007a  039b              LSLS     r3,r3,#14             ;936
00007c  d501              BPL      |L13.130|
                  |L13.126|
00007e  4b05              LDR      r3,|L13.148|
000080  e000              B        |L13.132|
                  |L13.130|
000082  4b02              LDR      r3,|L13.140|
                  |L13.132|
000084  435a              MULS     r2,r3,r2              ;938
000086  e7c6              B        |L13.22|
;;;1015   
                          ENDP

                  |L13.136|
                          DCD      0x40021000
                  |L13.140|
                          DCD      0x007a1200
                  |L13.144|
                          DCD      ||.data||+0x4
                  |L13.148|
                          DCD      0x003d0900

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1302     */
;;;1303   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4602              MOV      r2,r0
;;;1304   {
;;;1305     uint32_t tmp = 0;
;;;1306     uint32_t statusreg = 0;
;;;1307     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1308     /* Check the parameters */
;;;1309     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1310   
;;;1311     /* Get the RCC register index */
;;;1312     tmp = RCC_FLAG >> 5;
000004  0953              LSRS     r3,r2,#5
;;;1313     if (tmp == 1)               /* The flag to check is in CR register */
;;;1314     {
;;;1315       statusreg = RCC->CR;
000006  4909              LDR      r1,|L14.44|
000008  2b01              CMP      r3,#1                 ;1313
00000a  d00b              BEQ      |L14.36|
;;;1316     }
;;;1317     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000c  2b02              CMP      r3,#2
00000e  d00b              BEQ      |L14.40|
;;;1318     {
;;;1319       statusreg = RCC->BDCR;
;;;1320     }
;;;1321     else                       /* The flag to check is in CSR register */
;;;1322     {
;;;1323       statusreg = RCC->CSR;
000010  f8d11024          LDR.W    r1,[r1,#0x24]
                  |L14.20|
;;;1324     }
;;;1325   
;;;1326     /* Get the flag position */
;;;1327     tmp = RCC_FLAG & FLAG_Mask;
000014  f002021f          AND      r2,r2,#0x1f
;;;1328     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000018  2301              MOVS     r3,#1
00001a  4093              LSLS     r3,r3,r2
00001c  420b              TST      r3,r1
00001e  d000              BEQ      |L14.34|
;;;1329     {
;;;1330       bitstatus = SET;
000020  2001              MOVS     r0,#1
                  |L14.34|
;;;1331     }
;;;1332     else
;;;1333     {
;;;1334       bitstatus = RESET;
;;;1335     }
;;;1336   
;;;1337     /* Return the flag status */
;;;1338     return bitstatus;
;;;1339   }
000022  4770              BX       lr
                  |L14.36|
000024  6809              LDR      r1,[r1,#0]            ;1315
000026  e7f5              B        |L14.20|
                  |L14.40|
000028  6a09              LDR      r1,[r1,#0x20]         ;1319
00002a  e7f3              B        |L14.20|
;;;1340   
                          ENDP

                  |L14.44|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1378     */
;;;1379   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L15.16|
;;;1380   {
000002  4601              MOV      r1,r0
;;;1381     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1382     /* Check the parameters */
;;;1383     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1384   
;;;1385     /* Check the status of the specified RCC interrupt */
;;;1386     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6892              LDR      r2,[r2,#8]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L15.14|
;;;1387     {
;;;1388       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L15.14|
;;;1389     }
;;;1390     else
;;;1391     {
;;;1392       bitstatus = RESET;
;;;1393     }
;;;1394   
;;;1395     /* Return the RCC_IT status */
;;;1396     return  bitstatus;
;;;1397   }
00000e  4770              BX       lr
;;;1398   
                          ENDP

                  |L15.16|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;582      */
;;;583    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;584    {
;;;585      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;586    }
000008  4770              BX       lr
;;;587    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;603      */
;;;604    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L17.16|
;;;605    {
;;;606      uint32_t tmpreg = 0;
;;;607      /* Check the parameters */
;;;608      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;609      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;610      /* Clear HPRE[3:0] bits */
;;;611      tmpreg &= CFGR_HPRE_Reset_Mask;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;612      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;613      tmpreg |= RCC_SYSCLK;
000008  4301              ORRS     r1,r1,r0
;;;614      /* Store the new value */
;;;615      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;616    }
00000c  4770              BX       lr
;;;617    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;269      */
;;;270    void RCC_HSEConfig(uint32_t RCC_HSE)
000000  490b              LDR      r1,|L18.48|
;;;271    {
;;;272      /* Check the parameters */
;;;273      assert_param(IS_RCC_HSE(RCC_HSE));
;;;274      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;275      /* Reset HSEON bit */
;;;276      RCC->CR &= CR_HSEON_Reset;
000002  680a              LDR      r2,[r1,#0]
000004  f4223280          BIC      r2,r2,#0x10000
000008  600a              STR      r2,[r1,#0]
;;;277      /* Reset HSEBYP bit */
;;;278      RCC->CR &= CR_HSEBYP_Reset;
00000a  680a              LDR      r2,[r1,#0]
;;;279      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;280      switch(RCC_HSE)
00000c  f5b03f80          CMP      r0,#0x10000
000010  f4222280          BIC      r2,r2,#0x40000        ;278
000014  600a              STR      r2,[r1,#0]            ;278
000016  d007              BEQ      |L18.40|
000018  f5b02f80          CMP      r0,#0x40000
00001c  d103              BNE      |L18.38|
;;;281      {
;;;282        case RCC_HSE_ON:
;;;283          /* Set HSEON bit */
;;;284          RCC->CR |= CR_HSEON_Set;
;;;285          break;
;;;286          
;;;287        case RCC_HSE_Bypass:
;;;288          /* Set HSEBYP and HSEON bits */
;;;289          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
00001e  6808              LDR      r0,[r1,#0]
000020  f44020a0          ORR      r0,r0,#0x50000
                  |L18.36|
000024  6008              STR      r0,[r1,#0]
                  |L18.38|
;;;290          break;
;;;291          
;;;292        default:
;;;293          break;
;;;294      }
;;;295    }
000026  4770              BX       lr
                  |L18.40|
000028  6808              LDR      r0,[r1,#0]            ;284
00002a  f4403080          ORR      r0,r0,#0x10000        ;284
00002e  e7f9              B        |L18.36|
;;;296    
                          ENDP

                  |L18.48|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;353      */
;;;354    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L19.8|
;;;355    {
;;;356      /* Check the parameters */
;;;357      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;358      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;359    }
000004  4770              BX       lr
;;;360    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;695      */
;;;696    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L20.20|
;;;697    {
;;;698      /* Check the parameters */
;;;699      assert_param(IS_RCC_IT(RCC_IT));
;;;700      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;701      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;702      {
;;;703        /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
;;;704        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;705      }
;;;706      else
;;;707      {
;;;708        /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
;;;709        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7a51              LDRB     r1,[r2,#9]
000006  d001              BEQ      |L20.12|
000008  4301              ORRS     r1,r1,r0              ;704
00000a  e000              B        |L20.14|
                  |L20.12|
00000c  4381              BICS     r1,r1,r0
                  |L20.14|
00000e  7251              STRB     r1,[r2,#9]            ;704
;;;710      }
;;;711    }
000010  4770              BX       lr
;;;712    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;824      */
;;;825    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4906              LDR      r1,|L21.28|
;;;826    {
;;;827      /* Check the parameters */
;;;828      assert_param(IS_RCC_LSE(RCC_LSE));
;;;829      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;830      /* Reset LSEON bit */
;;;831      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;832      /* Reset LSEBYP bit */
;;;833      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  f8012920          STRB     r2,[r1],#-0x20
;;;834      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;835      switch(RCC_LSE)
00000a  2801              CMP      r0,#1
00000c  d002              BEQ      |L21.20|
00000e  2804              CMP      r0,#4
000010  d102              BNE      |L21.24|
;;;836      {
;;;837        case RCC_LSE_ON:
;;;838          /* Set LSEON bit */
;;;839          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;840          break;
;;;841          
;;;842        case RCC_LSE_Bypass:
;;;843          /* Set LSEBYP and LSEON bits */
;;;844          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000012  2005              MOVS     r0,#5
                  |L21.20|
000014  f8810020          STRB     r0,[r1,#0x20]
                  |L21.24|
;;;845          break;            
;;;846          
;;;847        default:
;;;848          break;      
;;;849      }
;;;850    }
000018  4770              BX       lr
;;;851    
                          ENDP

00001a  0000              DCW      0x0000
                  |L21.28|
                          DCD      0x40021020

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;857      */
;;;858    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L22.8|
;;;859    {
;;;860      /* Check the parameters */
;;;861      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;862      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;863    }
000004  4770              BX       lr
;;;864    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;1258     */
;;;1259   void RCC_MCOConfig(uint8_t RCC_MCO)
000000  4901              LDR      r1,|L23.8|
;;;1260   {
;;;1261     /* Check the parameters */
;;;1262     assert_param(IS_RCC_MCO(RCC_MCO));
;;;1263   
;;;1264     /* Perform Byte access to MCO bits to select the MCO source */
;;;1265     *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000002  71c8              STRB     r0,[r1,#7]
;;;1266   }
000004  4770              BX       lr
;;;1267   
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;629      */
;;;630    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L24.16|
;;;631    {
;;;632      uint32_t tmpreg = 0;
;;;633      /* Check the parameters */
;;;634      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;635      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;636      /* Clear PPRE1[2:0] bits */
;;;637      tmpreg &= CFGR_PPRE1_Reset_Mask;
000004  f42161e0          BIC      r1,r1,#0x700
;;;638      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;639      tmpreg |= RCC_HCLK;
000008  4301              ORRS     r1,r1,r0
;;;640      /* Store the new value */
;;;641      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;642    }
00000c  4770              BX       lr
;;;643    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;655      */
;;;656    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L25.16|
;;;657    {
;;;658      uint32_t tmpreg = 0;
;;;659      /* Check the parameters */
;;;660      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;661      tmpreg = RCC->CFGR;
000002  684a              LDR      r2,[r1,#4]
;;;662      /* Clear PPRE2[2:0] bits */
;;;663      tmpreg &= CFGR_PPRE2_Reset_Mask;
000004  f4225260          BIC      r2,r2,#0x3800
;;;664      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;665      tmpreg |= RCC_HCLK << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;666      /* Store the new value */
;;;667      RCC->CFGR = tmpreg;
00000c  6048              STR      r0,[r1,#4]
;;;668    }
00000e  4770              BX       lr
;;;669    
                          ENDP

                  |L25.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;400      */
;;;401    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;402    {
;;;403      /* Check the parameters */
;;;404      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;405    
;;;406      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;407    }
000004  4770              BX       lr
;;;408    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;377      */
;;;378    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  4a03              LDR      r2,|L27.16|
;;;379    {
;;;380      uint32_t tmpreg = 0;
;;;381    
;;;382      /* Check the parameters */
;;;383      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;384      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;385    
;;;386      tmpreg = RCC->CFGR;
000002  6853              LDR      r3,[r2,#4]
;;;387      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;388      tmpreg &= CFGR_PLL_Mask;
;;;389      /* Set the PLL configuration bits */
;;;390      tmpreg |= RCC_PLLSource | RCC_PLLMul;
000004  4308              ORRS     r0,r0,r1
000006  f423137c          BIC      r3,r3,#0x3f0000       ;388
00000a  4318              ORRS     r0,r0,r3
;;;391      /* Store the new value */
;;;392      RCC->CFGR = tmpreg;
00000c  6050              STR      r0,[r2,#4]
;;;393    }
00000e  4770              BX       lr
;;;394    
                          ENDP

                  |L27.16|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;888      */
;;;889    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;890    {
;;;891      /* Check the parameters */
;;;892      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;893      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;894    }
000004  4770              BX       lr
;;;895    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;874      */
;;;875    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L29.12|
;;;876    {
;;;877      /* Check the parameters */
;;;878      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;879      /* Select the RTC clock source */
;;;880      RCC->BDCR |= RCC_RTCCLKSource;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  4302              ORRS     r2,r2,r0
000006  620a              STR      r2,[r1,#0x20]
;;;881    }
000008  4770              BX       lr
;;;882    
                          ENDP

00000a  0000              DCW      0x0000
                  |L29.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;559      */
;;;560    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L30.16|
;;;561    {
;;;562      uint32_t tmpreg = 0;
;;;563      /* Check the parameters */
;;;564      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;565      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;566      /* Clear SW[1:0] bits */
;;;567      tmpreg &= CFGR_SW_Mask;
000004  f0210103          BIC      r1,r1,#3
;;;568      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;569      tmpreg |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;570      /* Store the new value */
;;;571      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;572    }
00000c  4770              BX       lr
;;;573    
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;723      */
;;;724    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  4901              LDR      r1,|L31.8|
;;;725    {
;;;726      /* Check the parameters */
;;;727      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;728    
;;;729      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  6008              STR      r0,[r1,#0]
;;;730    }
000004  4770              BX       lr
;;;731    #else
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      0x424200d8

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;303      */
;;;304    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b530              PUSH     {r4,r5,lr}
;;;305    {
;;;306      __IO uint32_t StartUpCounter = 0;
000002  2400              MOVS     r4,#0
;;;307      ErrorStatus status = ERROR;
;;;308      FlagStatus HSEStatus = RESET;
;;;309      
;;;310      /* Wait till HSE is ready and if Time out is reached exit */
;;;311      do
;;;312      {
;;;313        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;314        StartUpCounter++;  
;;;315      } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
000004  f44f65a0          MOV      r5,#0x500
                  |L32.8|
000008  2031              MOVS     r0,#0x31              ;313
00000a  f7fffffe          BL       RCC_GetFlagStatus
00000e  1c64              ADDS     r4,r4,#1              ;314
000010  42ac              CMP      r4,r5
000012  d001              BEQ      |L32.24|
000014  2800              CMP      r0,#0
000016  d0f7              BEQ      |L32.8|
                  |L32.24|
;;;316      
;;;317      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000018  2031              MOVS     r0,#0x31
00001a  f7fffffe          BL       RCC_GetFlagStatus
00001e  2800              CMP      r0,#0
000020  d000              BEQ      |L32.36|
;;;318      {
;;;319        status = SUCCESS;
000022  2001              MOVS     r0,#1
                  |L32.36|
;;;320      }
;;;321      else
;;;322      {
;;;323        status = ERROR;
;;;324      }  
;;;325      return (status);
;;;326    }
000024  bd30              POP      {r4,r5,pc}
;;;327    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  ADCPrescTable
000000  02040608          DCB      0x02,0x04,0x06,0x08
                  APBAHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
