; generated by ARM C/C++ Compiler, 4.1 [Build 561]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\Obj\uip-fw.o --depend=.\Obj\uip-fw.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_DM9000 -I..\..\Libraries\uIP-1.0\apps\hello-world -ID:\Keil4\ARM\INC -ID:\Keil4\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\Libraries\uIP-1.0\uip\uip-fw.c]
                          THUMB

                          AREA ||i.fwcache_register||, CODE, READONLY, ALIGN=2

                  fwcache_register PROC
;;;281    static void
;;;282    fwcache_register(void)
000000  b530              PUSH     {r4,r5,lr}
;;;283    {
;;;284      struct fwcache_entry *fw;
;;;285      int i, oldest;
;;;286    
;;;287      oldest = FW_TIME;
000002  2314              MOVS     r3,#0x14
;;;288      fw = NULL;
000004  2000              MOVS     r0,#0
;;;289    
;;;290      /* Find the oldest entry in the cache. */
;;;291      for(i = 0; i < FWCACHE_SIZE; ++i) {
;;;292        if(fwcache[i].timer == 0) {
000006  4a12              LDR      r2,|L1.80|
000008  4601              MOV      r1,r0                 ;291
00000a  bf00              NOP      
                  |L1.12|
00000c  ebc105c1          RSB      r5,r1,r1,LSL #3
000010  f8324015          LDRH     r4,[r2,r5,LSL #1]
000014  b1bc              CBZ      r4,|L1.70|
;;;293          fw = &fwcache[i];
;;;294          break;
;;;295        } else if(fwcache[i].timer <= oldest) {
000016  429c              CMP      r4,r3
000018  dc02              BGT      |L1.32|
;;;296          fw = &fwcache[i];
00001a  eb020045          ADD      r0,r2,r5,LSL #1
00001e  4623              MOV      r3,r4
                  |L1.32|
000020  1c49              ADDS     r1,r1,#1              ;291
000022  2902              CMP      r1,#2                 ;291
000024  dbf2              BLT      |L1.12|
                  |L1.38|
;;;297          oldest = fwcache[i].timer;
;;;298        }
;;;299      }
;;;300    
;;;301      fw->timer = FW_TIME;
000026  2114              MOVS     r1,#0x14
000028  8001              STRH     r1,[r0,#0]
;;;302      fw->ipid = BUF->ipid;
00002a  490a              LDR      r1,|L1.84|
00002c  8a4a              LDRH     r2,[r1,#0x12]  ; uip_buf
00002e  8142              STRH     r2,[r0,#0xa]
;;;303      fw->srcipaddr[0] = BUF->srcipaddr[0];
000030  8b4a              LDRH     r2,[r1,#0x1a]  ; uip_buf
000032  8042              STRH     r2,[r0,#2]
;;;304      fw->srcipaddr[1] = BUF->srcipaddr[1];
000034  8b8a              LDRH     r2,[r1,#0x1c]  ; uip_buf
000036  8082              STRH     r2,[r0,#4]
;;;305      fw->destipaddr[0] = BUF->destipaddr[0];
000038  8bca              LDRH     r2,[r1,#0x1e]  ; uip_buf
00003a  80c2              STRH     r2,[r0,#6]
;;;306      fw->destipaddr[1] = BUF->destipaddr[1];
00003c  8c0a              LDRH     r2,[r1,#0x20]  ; uip_buf
00003e  8102              STRH     r2,[r0,#8]
;;;307      fw->proto = BUF->proto;
000040  7dc9              LDRB     r1,[r1,#0x17]  ; uip_buf
000042  7301              STRB     r1,[r0,#0xc]
;;;308    #if notdef
;;;309      fw->payload[0] = BUF->srcport;
;;;310      fw->payload[1] = BUF->destport;
;;;311    #endif
;;;312    #if UIP_REASSEMBLY > 0
;;;313      fw->len = BUF->len;
;;;314      fw->offset = BUF->ipoffset;
;;;315    #endif
;;;316    }
000044  bd30              POP      {r4,r5,pc}
                  |L1.70|
000046  ebc100c1          RSB      r0,r1,r1,LSL #3       ;293
00004a  eb020040          ADD      r0,r2,r0,LSL #1       ;293
00004e  e7ea              B        |L1.38|
;;;317    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L1.80|
                          DCD      ||.bss||
                  |L1.84|
                          DCD      uip_buf

                          AREA ||i.time_exceeded||, CODE, READONLY, ALIGN=2

                  time_exceeded PROC
;;;221    static void
;;;222    time_exceeded(void)
000000  b570              PUSH     {r4-r6,lr}
;;;223    {
;;;224      u16_t tmp16;
;;;225    
;;;226      /* We don't send out ICMP errors for ICMP messages. */
;;;227      if(ICMPBUF->proto == UIP_PROTO_ICMP) {
000002  4c1d              LDR      r4,|L2.120|
;;;228        uip_len = 0;
000004  2500              MOVS     r5,#0
000006  4e1d              LDR      r6,|L2.124|
000008  7de0              LDRB     r0,[r4,#0x17]         ;227  ; uip_buf
00000a  2801              CMP      r0,#1                 ;227
00000c  d031              BEQ      |L2.114|
;;;229        return;
;;;230      }
;;;231      /* Copy fields from packet header into payload of this ICMP packet. */
;;;232      memcpy(&(ICMPBUF->payload[0]), ICMPBUF, 28);
00000e  f104010e          ADD      r1,r4,#0xe
000012  221c              MOVS     r2,#0x1c
000014  f101001c          ADD      r0,r1,#0x1c
000018  f7fffffe          BL       __aeabi_memcpy
;;;233    
;;;234      /* Set the ICMP type and code. */
;;;235      ICMPBUF->type = ICMP_TE;
00001c  f104040e          ADD      r4,r4,#0xe
000020  200b              MOVS     r0,#0xb
000022  7520              STRB     r0,[r4,#0x14]
;;;236      ICMPBUF->icode = 0;
;;;237    
;;;238      /* Calculate the ICMP checksum. */
;;;239      ICMPBUF->icmpchksum = 0;
;;;240      ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
000024  4814              LDR      r0,|L2.120|
000026  7565              STRB     r5,[r4,#0x15]         ;236
000028  82e5              STRH     r5,[r4,#0x16]         ;239
00002a  f04f0124          MOV      r1,#0x24
00002e  f1000022          ADD      r0,r0,#0x22
000032  f7fffffe          BL       uip_chksum
000036  43c0              MVNS     r0,r0
000038  82e0              STRH     r0,[r4,#0x16]
;;;241    
;;;242      /* Set the IP destination address to be the source address of the
;;;243         original packet. */
;;;244      tmp16= BUF->destipaddr[0];
;;;245      BUF->destipaddr[0] = BUF->srcipaddr[0];
00003a  89a0              LDRH     r0,[r4,#0xc]  ; uip_buf
00003c  8220              STRH     r0,[r4,#0x10]
;;;246      BUF->srcipaddr[0] = tmp16;
;;;247      tmp16 = BUF->destipaddr[1];
;;;248      BUF->destipaddr[1] = BUF->srcipaddr[1];
00003e  89e0              LDRH     r0,[r4,#0xe]  ; uip_buf
000040  8260              STRH     r0,[r4,#0x12]
;;;249      BUF->srcipaddr[1] = tmp16;
;;;250    
;;;251      /* Set our IP address as the source address. */
;;;252      BUF->srcipaddr[0] = uip_hostaddr[0];
000042  480f              LDR      r0,|L2.128|
000044  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
000046  81a1              STRH     r1,[r4,#0xc]
;;;253      BUF->srcipaddr[1] = uip_hostaddr[1];
000048  8840              LDRH     r0,[r0,#2]  ; uip_hostaddr
00004a  81e0              STRH     r0,[r4,#0xe]
;;;254    
;;;255      /* The size of the ICMP time exceeded packet is 36 + the size of the
;;;256         IP header (20) = 56. */
;;;257      uip_len = 56;
00004c  2038              MOVS     r0,#0x38
00004e  8030              STRH     r0,[r6,#0]
;;;258      ICMPBUF->len[0] = 0;
000050  70a5              STRB     r5,[r4,#2]
;;;259      ICMPBUF->len[1] = uip_len;
000052  70e0              STRB     r0,[r4,#3]
;;;260    
;;;261      /* Fill in the other fields in the IP header. */
;;;262      ICMPBUF->vhl = 0x45;
000054  2045              MOVS     r0,#0x45
000056  7020              STRB     r0,[r4,#0]
;;;263      ICMPBUF->tos = 0;
000058  7065              STRB     r5,[r4,#1]
;;;264      ICMPBUF->ipoffset[0] = ICMPBUF->ipoffset[1] = 0;
00005a  71e5              STRB     r5,[r4,#7]
00005c  71a5              STRB     r5,[r4,#6]
;;;265      ICMPBUF->ttl  = UIP_TTL;
00005e  2040              MOVS     r0,#0x40
000060  7220              STRB     r0,[r4,#8]
;;;266      ICMPBUF->proto = UIP_PROTO_ICMP;
000062  2001              MOVS     r0,#1
000064  7260              STRB     r0,[r4,#9]
;;;267    
;;;268      /* Calculate IP checksum. */
;;;269      ICMPBUF->ipchksum = 0;
000066  8165              STRH     r5,[r4,#0xa]
;;;270      ICMPBUF->ipchksum = ~(uip_ipchksum());
000068  f7fffffe          BL       uip_ipchksum
00006c  43c0              MVNS     r0,r0
00006e  8160              STRH     r0,[r4,#0xa]
;;;271    
;;;272    
;;;273    }
000070  bd70              POP      {r4-r6,pc}
                  |L2.114|
000072  8035              STRH     r5,[r6,#0]            ;228
000074  bd70              POP      {r4-r6,pc}
;;;274    /*------------------------------------------------------------------------------*/
                          ENDP

000076  0000              DCW      0x0000
                  |L2.120|
                          DCD      uip_buf
                  |L2.124|
                          DCD      uip_len
                  |L2.128|
                          DCD      uip_hostaddr

                          AREA ||i.uip_fw_default||, CODE, READONLY, ALIGN=2

                  uip_fw_default PROC
;;;512    void
;;;513    uip_fw_default(struct uip_fw_netif *netif)
000000  4901              LDR      r1,|L3.8|
;;;514    {
;;;515      defaultnetif = netif;
000002  6048              STR      r0,[r1,#4]  ; defaultnetif
;;;516    }
000004  4770              BX       lr
;;;517    /*------------------------------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.uip_fw_forward||, CODE, READONLY, ALIGN=2

                  uip_fw_forward PROC
;;;405    u8_t
;;;406    uip_fw_forward(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;407    {
;;;408      struct fwcache_entry *fw;
;;;409    
;;;410      /* First check if the packet is destined for ourselves and return 0
;;;411         to indicate that the packet should be processed locally. */
;;;412      if(BUF->destipaddr[0] == uip_hostaddr[0] &&
000004  4c28              LDR      r4,|L4.168|
000006  4829              LDR      r0,|L4.172|
000008  4621              MOV      r1,r4
00000a  8be3              LDRH     r3,[r4,#0x1e]  ; uip_buf
00000c  8802              LDRH     r2,[r0,#0]  ; uip_hostaddr
;;;413         BUF->destipaddr[1] == uip_hostaddr[1]) {
00000e  8c09              LDRH     r1,[r1,#0x20]
000010  4293              CMP      r3,r2                 ;412
000012  d102              BNE      |L4.26|
000014  8840              LDRH     r0,[r0,#2]  ; uip_hostaddr
000016  4281              CMP      r1,r0
000018  d029              BEQ      |L4.110|
                  |L4.26|
;;;414        return UIP_FW_LOCAL;
;;;415      }
;;;416    
;;;417      /* If we use ping IP address configuration, and our IP address is
;;;418         not yet configured, we should intercept all ICMP echo packets. */
;;;419    #if UIP_PINGADDRCONF
;;;420      if((uip_hostaddr[0] | uip_hostaddr[1]) == 0 &&
;;;421         BUF->proto == UIP_PROTO_ICMP &&
;;;422         ICMPBUF->type == ICMP_ECHO) {
;;;423        return UIP_FW_LOCAL;
;;;424      }
;;;425    #endif /* UIP_PINGADDRCONF */
;;;426    
;;;427      /* Check if the packet is in the forwarding cache already, and if so
;;;428         we drop it. */
;;;429    
;;;430      for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {
00001a  4825              LDR      r0,|L4.176|
;;;431        if(fw->timer != 0 &&
;;;432    #if UIP_REASSEMBLY > 0
;;;433           fw->len == BUF->len &&
;;;434           fw->offset == BUF->ipoffset &&
;;;435    #endif
;;;436           fw->ipid == BUF->ipid &&
00001c  8a65              LDRH     r5,[r4,#0x12]
;;;437           fw->srcipaddr[0] == BUF->srcipaddr[0] &&
00001e  f8b4e01a          LDRH     lr,[r4,#0x1a]
;;;438           fw->srcipaddr[1] == BUF->srcipaddr[1] &&
000022  8ba6              LDRH     r6,[r4,#0x1c]
;;;439           fw->destipaddr[0] == BUF->destipaddr[0] &&
;;;440           fw->destipaddr[1] == BUF->destipaddr[1] &&
;;;441    #if notdef
;;;442           fw->payload[0] == BUF->srcport &&
;;;443           fw->payload[1] == BUF->destport &&
;;;444    #endif
;;;445           fw->proto == BUF->proto) {
000024  f894c017          LDRB     r12,[r4,#0x17]
000028  f100021c          ADD      r2,r0,#0x1c           ;430
00002c  e014              B        |L4.88|
                  |L4.46|
00002e  8807              LDRH     r7,[r0,#0]            ;431
000030  b18f              CBZ      r7,|L4.86|
000032  8947              LDRH     r7,[r0,#0xa]          ;436
000034  42af              CMP      r7,r5                 ;436
000036  d10e              BNE      |L4.86|
000038  8847              LDRH     r7,[r0,#2]            ;437
00003a  4577              CMP      r7,lr                 ;437
00003c  d10b              BNE      |L4.86|
00003e  8887              LDRH     r7,[r0,#4]            ;438
000040  42b7              CMP      r7,r6                 ;438
000042  d108              BNE      |L4.86|
000044  88c7              LDRH     r7,[r0,#6]            ;439
000046  429f              CMP      r7,r3                 ;439
000048  d105              BNE      |L4.86|
00004a  8907              LDRH     r7,[r0,#8]            ;440
00004c  428f              CMP      r7,r1                 ;440
00004e  d102              BNE      |L4.86|
000050  7b07              LDRB     r7,[r0,#0xc]
000052  4567              CMP      r7,r12
000054  d025              BEQ      |L4.162|
                  |L4.86|
000056  300e              ADDS     r0,r0,#0xe            ;430
                  |L4.88|
000058  4290              CMP      r0,r2                 ;430
00005a  d3e8              BCC      |L4.46|
;;;446          /* Drop packet. */
;;;447          return UIP_FW_FORWARDED;
;;;448        }
;;;449      }
;;;450    
;;;451      /* If the TTL reaches zero we produce an ICMP time exceeded message
;;;452         in the uip_buf buffer and forward that packet back to the sender
;;;453         of the packet. */
;;;454      if(BUF->ttl <= 1) {
00005c  7da0              LDRB     r0,[r4,#0x16]  ; uip_buf
00005e  2801              CMP      r0,#1
000060  d80a              BHI      |L4.120|
;;;455        /* No time exceeded for broadcasts and multicasts! */
;;;456        if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {
000062  f64f70ff          MOV      r0,#0xffff
000066  4283              CMP      r3,r0
000068  d104              BNE      |L4.116|
00006a  4281              CMP      r1,r0
00006c  d102              BNE      |L4.116|
                  |L4.110|
;;;457          return UIP_FW_LOCAL;
00006e  2000              MOVS     r0,#0
                  |L4.112|
;;;458        }
;;;459        time_exceeded();
;;;460      }
;;;461    
;;;462      /* Decrement the TTL (time-to-live) value in the IP header */
;;;463      BUF->ttl = BUF->ttl - 1;
;;;464    
;;;465      /* Update the IP checksum. */
;;;466      if(BUF->ipchksum >= HTONS(0xffff - 0x0100)) {
;;;467        BUF->ipchksum = BUF->ipchksum + HTONS(0x0100) + 1;
;;;468      } else {
;;;469        BUF->ipchksum = BUF->ipchksum + HTONS(0x0100);
;;;470      }
;;;471    
;;;472      if(uip_len > 0) {
;;;473        uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN];
;;;474        uip_fw_output();
;;;475      }
;;;476    
;;;477    #if UIP_BROADCAST
;;;478      if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {
;;;479        return UIP_FW_LOCAL;
;;;480      }
;;;481    #endif /* UIP_BROADCAST */
;;;482    
;;;483      /* Return non-zero to indicate that the packet was forwarded and that no
;;;484         other processing should be made. */
;;;485      return UIP_FW_FORWARDED;
;;;486    }
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L4.116|
000074  f7fffffe          BL       time_exceeded
                  |L4.120|
000078  7da0              LDRB     r0,[r4,#0x16]         ;463  ; uip_buf
00007a  f64f71fe          MOV      r1,#0xfffe            ;466
00007e  1e40              SUBS     r0,r0,#1              ;463
000080  75a0              STRB     r0,[r4,#0x16]         ;463
000082  8b20              LDRH     r0,[r4,#0x18]         ;466  ; uip_buf
000084  4288              CMP      r0,r1                 ;466
000086  d301              BCC      |L4.140|
000088  1c80              ADDS     r0,r0,#2              ;467
00008a  e000              B        |L4.142|
                  |L4.140|
00008c  1c40              ADDS     r0,r0,#1              ;469
                  |L4.142|
00008e  8320              STRH     r0,[r4,#0x18]         ;469
000090  4808              LDR      r0,|L4.180|
000092  8800              LDRH     r0,[r0,#0]            ;472  ; uip_len
000094  b128              CBZ      r0,|L4.162|
000096  4804              LDR      r0,|L4.168|
000098  4907              LDR      r1,|L4.184|
00009a  3036              ADDS     r0,r0,#0x36           ;473
00009c  6008              STR      r0,[r1,#0]            ;474  ; uip_appdata
00009e  f7fffffe          BL       uip_fw_output
                  |L4.162|
0000a2  2001              MOVS     r0,#1                 ;485
0000a4  e7e4              B        |L4.112|
;;;487    /*------------------------------------------------------------------------------*/
                          ENDP

0000a6  0000              DCW      0x0000
                  |L4.168|
                          DCD      uip_buf
                  |L4.172|
                          DCD      uip_hostaddr
                  |L4.176|
                          DCD      ||.bss||
                  |L4.180|
                          DCD      uip_len
                  |L4.184|
                          DCD      uip_appdata

                          AREA ||i.uip_fw_init||, CODE, READONLY, ALIGN=2

                  uip_fw_init PROC
;;;182    void
;;;183    uip_fw_init(void)
000000  4905              LDR      r1,|L5.24|
;;;184    {
;;;185      struct uip_fw_netif *t;
;;;186      defaultnetif = NULL;
000002  2200              MOVS     r2,#0
;;;187      while(netifs != NULL) {
;;;188        t = netifs;
000004  604a              STR      r2,[r1,#4]  ; defaultnetif
;;;189        netifs = netifs->next;
;;;190        t->next = NULL;
000006  6808              LDR      r0,[r1,#0]  ; netifs
000008  e002              B        |L5.16|
                  |L5.10|
00000a  4603              MOV      r3,r0                 ;188
00000c  6800              LDR      r0,[r0,#0]            ;189
00000e  601a              STR      r2,[r3,#0]
                  |L5.16|
000010  2800              CMP      r0,#0                 ;187
000012  d1fa              BNE      |L5.10|
000014  6008              STR      r0,[r1,#0]            ;189  ; netifs
;;;191      }
;;;192    }
000016  4770              BX       lr
;;;193    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L5.24|
                          DCD      ||.data||

                          AREA ||i.uip_fw_output||, CODE, READONLY, ALIGN=2

                  uip_fw_output PROC
;;;357    u8_t
;;;358    uip_fw_output(void)
000000  b570              PUSH     {r4-r6,lr}
;;;359    {
;;;360      struct uip_fw_netif *netif;
;;;361    
;;;362      if(uip_len == 0) {
000002  4813              LDR      r0,|L6.80|
000004  8800              LDRH     r0,[r0,#0]  ; uip_len
000006  b138              CBZ      r0,|L6.24|
;;;363        return UIP_FW_ZEROLEN;
;;;364      }
;;;365    
;;;366      fwcache_register();
000008  f7fffffe          BL       fwcache_register
00000c  4912              LDR      r1,|L6.88|
00000e  4b11              LDR      r3,|L6.84|
000010  8bca              LDRH     r2,[r1,#0x1e]
000012  8c09              LDRH     r1,[r1,#0x20]
000014  6818              LDR      r0,[r3,#0]  ; netifs
000016  e010              B        |L6.58|
                  |L6.24|
000018  2002              MOVS     r0,#2                 ;363
;;;367    
;;;368    #if UIP_BROADCAST
;;;369      /* Link local broadcasts go out on all interfaces. */
;;;370      if(/*BUF->proto == UIP_PROTO_UDP &&*/
;;;371         BUF->destipaddr[0] == 0xffff &&
;;;372         BUF->destipaddr[1] == 0xffff) {
;;;373        if(defaultnetif != NULL) {
;;;374          defaultnetif->output();
;;;375        }
;;;376        for(netif = netifs; netif != NULL; netif = netif->next) {
;;;377          netif->output();
;;;378        }
;;;379        return UIP_FW_OK;
;;;380      }
;;;381    #endif /* UIP_BROADCAST */
;;;382    
;;;383      netif = find_netif();
;;;384      /*  printf("uip_fw_output: netif %p ->output %p len %d\n", netif,
;;;385    	 netif->output,
;;;386    	 uip_len);*/
;;;387    
;;;388      if(netif == NULL) {
;;;389        return UIP_FW_NOROUTE;
;;;390      }
;;;391      /* If we now have found a suitable network interface, we call its
;;;392         output function to send out the packet. */
;;;393      return netif->output();
;;;394    }
00001a  bd70              POP      {r4-r6,pc}
                  |L6.28|
00001c  8905              LDRH     r5,[r0,#8]
00001e  8886              LDRH     r6,[r0,#4]
000020  ea020405          AND      r4,r2,r5
000024  402e              ANDS     r6,r6,r5
000026  42b4              CMP      r4,r6
000028  d106              BNE      |L6.56|
00002a  8945              LDRH     r5,[r0,#0xa]
00002c  88c6              LDRH     r6,[r0,#6]
00002e  ea010405          AND      r4,r1,r5
000032  402e              ANDS     r6,r6,r5
000034  42b4              CMP      r4,r6
000036  d003              BEQ      |L6.64|
                  |L6.56|
000038  6800              LDR      r0,[r0,#0]
                  |L6.58|
00003a  2800              CMP      r0,#0
00003c  d1ee              BNE      |L6.28|
00003e  6858              LDR      r0,[r3,#4]  ; defaultnetif
                  |L6.64|
000040  b118              CBZ      r0,|L6.74|
000042  68c0              LDR      r0,[r0,#0xc]          ;393
000044  e8bd4070          POP      {r4-r6,lr}            ;393
000048  4700              BX       r0                    ;393
                  |L6.74|
00004a  2004              MOVS     r0,#4                 ;389
00004c  bd70              POP      {r4-r6,pc}
;;;395    /*------------------------------------------------------------------------------*/
                          ENDP

00004e  0000              DCW      0x0000
                  |L6.80|
                          DCD      uip_len
                  |L6.84|
                          DCD      ||.data||
                  |L6.88|
                          DCD      uip_buf

                          AREA ||i.uip_fw_periodic||, CODE, READONLY, ALIGN=2

                  uip_fw_periodic PROC
;;;522    void
;;;523    uip_fw_periodic(void)
000000  4805              LDR      r0,|L7.24|
;;;524    {
;;;525      struct fwcache_entry *fw;
;;;526      for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {
000002  f100011c          ADD      r1,r0,#0x1c
000006  e004              B        |L7.18|
                  |L7.8|
;;;527        if(fw->timer > 0) {
000008  8802              LDRH     r2,[r0,#0]
00000a  b10a              CBZ      r2,|L7.16|
;;;528          --fw->timer;
00000c  1e52              SUBS     r2,r2,#1
00000e  8002              STRH     r2,[r0,#0]
                  |L7.16|
000010  300e              ADDS     r0,r0,#0xe            ;526
                  |L7.18|
000012  4288              CMP      r0,r1                 ;526
000014  d3f8              BCC      |L7.8|
;;;529        }
;;;530      }
;;;531    }
000016  4770              BX       lr
;;;532    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L7.24|
                          DCD      ||.bss||

                          AREA ||i.uip_fw_register||, CODE, READONLY, ALIGN=2

                  uip_fw_register PROC
;;;495    void
;;;496    uip_fw_register(struct uip_fw_netif *netif)
000000  4902              LDR      r1,|L8.12|
;;;497    {
;;;498      netif->next = netifs;
000002  680a              LDR      r2,[r1,#0]  ; netifs
;;;499      netifs = netif;
000004  6002              STR      r2,[r0,#0]
000006  6008              STR      r0,[r1,#0]  ; netifs
;;;500    }
000008  4770              BX       lr
;;;501    /*------------------------------------------------------------------------------*/
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  fwcache
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  netifs
                          DCD      0x00000000
                  defaultnetif
                          DCD      0x00000000
